
import
  json, options, hashes, uri, rest, os, uri, strutils, httpcore

## auto-generated via openapi macro
## title: Service Fabric Client APIs
## version: 6.0.0.1
## termsOfService: (not provided)
## license: (not provided)
## 
## Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
## 
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_567667 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_567667](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_567667): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  macServiceName = "servicefabric"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_CancelRepairTask_567889 = ref object of OpenApiRestCall_567667
proc url_CancelRepairTask_567891(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelRepairTask_567890(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568063 = query.getOrDefault("api-version")
  valid_568063 = validateParameter(valid_568063, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568063 != nil:
    section.add "api-version", valid_568063
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568087: Call_CancelRepairTask_567889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568087.validator(path, query, header, formData, body)
  let scheme = call_568087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568087.url(scheme.get, call_568087.host, call_568087.base,
                         call_568087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568087, url, valid)

proc call*(call_568158: Call_CancelRepairTask_567889;
          RepairTaskCancelDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## cancelRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  var query_568159 = newJObject()
  var body_568161 = newJObject()
  add(query_568159, "api-version", newJString(apiVersion))
  if RepairTaskCancelDescription != nil:
    body_568161 = RepairTaskCancelDescription
  result = call_568158.call(nil, query_568159, nil, nil, body_568161)

var cancelRepairTask* = Call_CancelRepairTask_567889(name: "cancelRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CancelRepairTask", validator: validate_CancelRepairTask_567890,
    base: "", url: url_CancelRepairTask_567891, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRepairTask_568200 = ref object of OpenApiRestCall_567667
proc url_CreateRepairTask_568202(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateRepairTask_568201(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568203 = query.getOrDefault("api-version")
  valid_568203 = validateParameter(valid_568203, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568203 != nil:
    section.add "api-version", valid_568203
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568205: Call_CreateRepairTask_568200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568205.validator(path, query, header, formData, body)
  let scheme = call_568205.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568205.url(scheme.get, call_568205.host, call_568205.base,
                         call_568205.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568205, url, valid)

proc call*(call_568206: Call_CreateRepairTask_568200; RepairTask: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## createRepairTask
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568207 = newJObject()
  var body_568208 = newJObject()
  if RepairTask != nil:
    body_568208 = RepairTask
  add(query_568207, "api-version", newJString(apiVersion))
  result = call_568206.call(nil, query_568207, nil, nil, body_568208)

var createRepairTask* = Call_CreateRepairTask_568200(name: "createRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CreateRepairTask", validator: validate_CreateRepairTask_568201,
    base: "", url: url_CreateRepairTask_568202, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRepairTask_568209 = ref object of OpenApiRestCall_567667
proc url_DeleteRepairTask_568211(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteRepairTask_568210(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568212 = query.getOrDefault("api-version")
  valid_568212 = validateParameter(valid_568212, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568212 != nil:
    section.add "api-version", valid_568212
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568214: Call_DeleteRepairTask_568209; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568214.validator(path, query, header, formData, body)
  let scheme = call_568214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568214.url(scheme.get, call_568214.host, call_568214.base,
                         call_568214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568214, url, valid)

proc call*(call_568215: Call_DeleteRepairTask_568209;
          RepairTaskDeleteDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## deleteRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  var query_568216 = newJObject()
  var body_568217 = newJObject()
  add(query_568216, "api-version", newJString(apiVersion))
  if RepairTaskDeleteDescription != nil:
    body_568217 = RepairTaskDeleteDescription
  result = call_568215.call(nil, query_568216, nil, nil, body_568217)

var deleteRepairTask* = Call_DeleteRepairTask_568209(name: "deleteRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/DeleteRepairTask", validator: validate_DeleteRepairTask_568210,
    base: "", url: url_DeleteRepairTask_568211, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ForceApproveRepairTask_568218 = ref object of OpenApiRestCall_567667
proc url_ForceApproveRepairTask_568220(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ForceApproveRepairTask_568219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568221 = query.getOrDefault("api-version")
  valid_568221 = validateParameter(valid_568221, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568221 != nil:
    section.add "api-version", valid_568221
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568223: Call_ForceApproveRepairTask_568218; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568223.validator(path, query, header, formData, body)
  let scheme = call_568223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568223.url(scheme.get, call_568223.host, call_568223.base,
                         call_568223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568223, url, valid)

proc call*(call_568224: Call_ForceApproveRepairTask_568218;
          RepairTaskApproveDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## forceApproveRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  var query_568225 = newJObject()
  var body_568226 = newJObject()
  add(query_568225, "api-version", newJString(apiVersion))
  if RepairTaskApproveDescription != nil:
    body_568226 = RepairTaskApproveDescription
  result = call_568224.call(nil, query_568225, nil, nil, body_568226)

var forceApproveRepairTask* = Call_ForceApproveRepairTask_568218(
    name: "forceApproveRepairTask", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ForceApproveRepairTask",
    validator: validate_ForceApproveRepairTask_568219, base: "",
    url: url_ForceApproveRepairTask_568220, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAadMetadata_568227 = ref object of OpenApiRestCall_567667
proc url_GetAadMetadata_568229(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAadMetadata_568228(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568231 = query.getOrDefault("timeout")
  valid_568231 = validateParameter(valid_568231, JInt, required = false,
                                 default = newJInt(60))
  if valid_568231 != nil:
    section.add "timeout", valid_568231
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568232 = query.getOrDefault("api-version")
  valid_568232 = validateParameter(valid_568232, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568232 != nil:
    section.add "api-version", valid_568232
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568233: Call_GetAadMetadata_568227; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  let valid = call_568233.validator(path, query, header, formData, body)
  let scheme = call_568233.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568233.url(scheme.get, call_568233.host, call_568233.base,
                         call_568233.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568233, url, valid)

proc call*(call_568234: Call_GetAadMetadata_568227; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getAadMetadata
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568235 = newJObject()
  add(query_568235, "timeout", newJInt(timeout))
  add(query_568235, "api-version", newJString(apiVersion))
  result = call_568234.call(nil, query_568235, nil, nil, nil)

var getAadMetadata* = Call_GetAadMetadata_568227(name: "getAadMetadata",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/$/GetAadMetadata",
    validator: validate_GetAadMetadata_568228, base: "", url: url_GetAadMetadata_568229,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfiguration_568236 = ref object of OpenApiRestCall_567667
proc url_GetClusterConfiguration_568238(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfiguration_568237(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ConfigurationApiVersion: JString (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568239 = query.getOrDefault("timeout")
  valid_568239 = validateParameter(valid_568239, JInt, required = false,
                                 default = newJInt(60))
  if valid_568239 != nil:
    section.add "timeout", valid_568239
  assert query != nil, "query argument is necessary due to required `ConfigurationApiVersion` field"
  var valid_568240 = query.getOrDefault("ConfigurationApiVersion")
  valid_568240 = validateParameter(valid_568240, JString, required = true,
                                 default = nil)
  if valid_568240 != nil:
    section.add "ConfigurationApiVersion", valid_568240
  var valid_568241 = query.getOrDefault("api-version")
  valid_568241 = validateParameter(valid_568241, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568241 != nil:
    section.add "api-version", valid_568241
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568242: Call_GetClusterConfiguration_568236; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  let valid = call_568242.validator(path, query, header, formData, body)
  let scheme = call_568242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568242.url(scheme.get, call_568242.host, call_568242.base,
                         call_568242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568242, url, valid)

proc call*(call_568243: Call_GetClusterConfiguration_568236;
          ConfigurationApiVersion: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterConfiguration
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ConfigurationApiVersion: string (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568244 = newJObject()
  add(query_568244, "timeout", newJInt(timeout))
  add(query_568244, "ConfigurationApiVersion", newJString(ConfigurationApiVersion))
  add(query_568244, "api-version", newJString(apiVersion))
  result = call_568243.call(nil, query_568244, nil, nil, nil)

var getClusterConfiguration* = Call_GetClusterConfiguration_568236(
    name: "getClusterConfiguration", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfiguration",
    validator: validate_GetClusterConfiguration_568237, base: "",
    url: url_GetClusterConfiguration_568238, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfigurationUpgradeStatus_568245 = ref object of OpenApiRestCall_567667
proc url_GetClusterConfigurationUpgradeStatus_568247(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfigurationUpgradeStatus_568246(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568248 = query.getOrDefault("timeout")
  valid_568248 = validateParameter(valid_568248, JInt, required = false,
                                 default = newJInt(60))
  if valid_568248 != nil:
    section.add "timeout", valid_568248
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568249 = query.getOrDefault("api-version")
  valid_568249 = validateParameter(valid_568249, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568249 != nil:
    section.add "api-version", valid_568249
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568250: Call_GetClusterConfigurationUpgradeStatus_568245;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  let valid = call_568250.validator(path, query, header, formData, body)
  let scheme = call_568250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568250.url(scheme.get, call_568250.host, call_568250.base,
                         call_568250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568250, url, valid)

proc call*(call_568251: Call_GetClusterConfigurationUpgradeStatus_568245;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getClusterConfigurationUpgradeStatus
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568252 = newJObject()
  add(query_568252, "timeout", newJInt(timeout))
  add(query_568252, "api-version", newJString(apiVersion))
  result = call_568251.call(nil, query_568252, nil, nil, nil)

var getClusterConfigurationUpgradeStatus* = Call_GetClusterConfigurationUpgradeStatus_568245(
    name: "getClusterConfigurationUpgradeStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfigurationUpgradeStatus",
    validator: validate_GetClusterConfigurationUpgradeStatus_568246, base: "",
    url: url_GetClusterConfigurationUpgradeStatus_568247,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthUsingPolicy_568266 = ref object of OpenApiRestCall_567667
proc url_GetClusterHealthUsingPolicy_568268(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthUsingPolicy_568267(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_568286 = query.getOrDefault("timeout")
  valid_568286 = validateParameter(valid_568286, JInt, required = false,
                                 default = newJInt(60))
  if valid_568286 != nil:
    section.add "timeout", valid_568286
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568287 = query.getOrDefault("api-version")
  valid_568287 = validateParameter(valid_568287, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568287 != nil:
    section.add "api-version", valid_568287
  var valid_568288 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_568288 = validateParameter(valid_568288, JInt, required = false,
                                 default = newJInt(0))
  if valid_568288 != nil:
    section.add "ApplicationsHealthStateFilter", valid_568288
  var valid_568289 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_568289 = validateParameter(valid_568289, JBool, required = false,
                                 default = newJBool(false))
  if valid_568289 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_568289
  var valid_568290 = query.getOrDefault("ExcludeHealthStatistics")
  valid_568290 = validateParameter(valid_568290, JBool, required = false,
                                 default = newJBool(false))
  if valid_568290 != nil:
    section.add "ExcludeHealthStatistics", valid_568290
  var valid_568291 = query.getOrDefault("EventsHealthStateFilter")
  valid_568291 = validateParameter(valid_568291, JInt, required = false,
                                 default = newJInt(0))
  if valid_568291 != nil:
    section.add "EventsHealthStateFilter", valid_568291
  var valid_568292 = query.getOrDefault("NodesHealthStateFilter")
  valid_568292 = validateParameter(valid_568292, JInt, required = false,
                                 default = newJInt(0))
  if valid_568292 != nil:
    section.add "NodesHealthStateFilter", valid_568292
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568294: Call_GetClusterHealthUsingPolicy_568266; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  let valid = call_568294.validator(path, query, header, formData, body)
  let scheme = call_568294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568294.url(scheme.get, call_568294.host, call_568294.base,
                         call_568294.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568294, url, valid)

proc call*(call_568295: Call_GetClusterHealthUsingPolicy_568266; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          IncludeSystemApplicationHealthStatistics: bool = false;
          ClusterHealthPolicies: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealthUsingPolicy
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_568296 = newJObject()
  var body_568297 = newJObject()
  add(query_568296, "timeout", newJInt(timeout))
  add(query_568296, "api-version", newJString(apiVersion))
  add(query_568296, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_568296, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  if ClusterHealthPolicies != nil:
    body_568297 = ClusterHealthPolicies
  add(query_568296, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_568296, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_568296, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_568295.call(nil, query_568296, nil, nil, body_568297)

var getClusterHealthUsingPolicy* = Call_GetClusterHealthUsingPolicy_568266(
    name: "getClusterHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/GetClusterHealth",
    validator: validate_GetClusterHealthUsingPolicy_568267, base: "",
    url: url_GetClusterHealthUsingPolicy_568268,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealth_568253 = ref object of OpenApiRestCall_567667
proc url_GetClusterHealth_568255(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealth_568254(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_568256 = query.getOrDefault("timeout")
  valid_568256 = validateParameter(valid_568256, JInt, required = false,
                                 default = newJInt(60))
  if valid_568256 != nil:
    section.add "timeout", valid_568256
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568257 = query.getOrDefault("api-version")
  valid_568257 = validateParameter(valid_568257, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568257 != nil:
    section.add "api-version", valid_568257
  var valid_568258 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_568258 = validateParameter(valid_568258, JInt, required = false,
                                 default = newJInt(0))
  if valid_568258 != nil:
    section.add "ApplicationsHealthStateFilter", valid_568258
  var valid_568259 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_568259 = validateParameter(valid_568259, JBool, required = false,
                                 default = newJBool(false))
  if valid_568259 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_568259
  var valid_568260 = query.getOrDefault("ExcludeHealthStatistics")
  valid_568260 = validateParameter(valid_568260, JBool, required = false,
                                 default = newJBool(false))
  if valid_568260 != nil:
    section.add "ExcludeHealthStatistics", valid_568260
  var valid_568261 = query.getOrDefault("EventsHealthStateFilter")
  valid_568261 = validateParameter(valid_568261, JInt, required = false,
                                 default = newJInt(0))
  if valid_568261 != nil:
    section.add "EventsHealthStateFilter", valid_568261
  var valid_568262 = query.getOrDefault("NodesHealthStateFilter")
  valid_568262 = validateParameter(valid_568262, JInt, required = false,
                                 default = newJInt(0))
  if valid_568262 != nil:
    section.add "NodesHealthStateFilter", valid_568262
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568263: Call_GetClusterHealth_568253; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  let valid = call_568263.validator(path, query, header, formData, body)
  let scheme = call_568263.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568263.url(scheme.get, call_568263.host, call_568263.base,
                         call_568263.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568263, url, valid)

proc call*(call_568264: Call_GetClusterHealth_568253; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          IncludeSystemApplicationHealthStatistics: bool = false;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealth
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_568265 = newJObject()
  add(query_568265, "timeout", newJInt(timeout))
  add(query_568265, "api-version", newJString(apiVersion))
  add(query_568265, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_568265, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  add(query_568265, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_568265, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_568265, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_568264.call(nil, query_568265, nil, nil, nil)

var getClusterHealth* = Call_GetClusterHealth_568253(name: "getClusterHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterHealth", validator: validate_GetClusterHealth_568254,
    base: "", url: url_GetClusterHealth_568255, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568306 = ref object of OpenApiRestCall_567667
proc url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568308(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568307(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568309 = query.getOrDefault("timeout")
  valid_568309 = validateParameter(valid_568309, JInt, required = false,
                                 default = newJInt(60))
  if valid_568309 != nil:
    section.add "timeout", valid_568309
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568310 = query.getOrDefault("api-version")
  valid_568310 = validateParameter(valid_568310, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568310 != nil:
    section.add "api-version", valid_568310
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568312: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568306;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  let valid = call_568312.validator(path, query, header, formData, body)
  let scheme = call_568312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568312.url(scheme.get, call_568312.host, call_568312.base,
                         call_568312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568312, url, valid)

proc call*(call_568313: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568306;
          timeout: int = 60; apiVersion: string = "6.0";
          ClusterHealthChunkQueryDescription: JsonNode = nil): Recallable =
  ## getClusterHealthChunkUsingPolicyAndAdvancedFilters
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  var query_568314 = newJObject()
  var body_568315 = newJObject()
  add(query_568314, "timeout", newJInt(timeout))
  add(query_568314, "api-version", newJString(apiVersion))
  if ClusterHealthChunkQueryDescription != nil:
    body_568315 = ClusterHealthChunkQueryDescription
  result = call_568313.call(nil, query_568314, nil, nil, body_568315)

var getClusterHealthChunkUsingPolicyAndAdvancedFilters* = Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568306(
    name: "getClusterHealthChunkUsingPolicyAndAdvancedFilters",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568307,
    base: "", url: url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_568308,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunk_568298 = ref object of OpenApiRestCall_567667
proc url_GetClusterHealthChunk_568300(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunk_568299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568301 = query.getOrDefault("timeout")
  valid_568301 = validateParameter(valid_568301, JInt, required = false,
                                 default = newJInt(60))
  if valid_568301 != nil:
    section.add "timeout", valid_568301
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568302 = query.getOrDefault("api-version")
  valid_568302 = validateParameter(valid_568302, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568302 != nil:
    section.add "api-version", valid_568302
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568303: Call_GetClusterHealthChunk_568298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  let valid = call_568303.validator(path, query, header, formData, body)
  let scheme = call_568303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568303.url(scheme.get, call_568303.host, call_568303.base,
                         call_568303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568303, url, valid)

proc call*(call_568304: Call_GetClusterHealthChunk_568298; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterHealthChunk
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568305 = newJObject()
  add(query_568305, "timeout", newJInt(timeout))
  add(query_568305, "api-version", newJString(apiVersion))
  result = call_568304.call(nil, query_568305, nil, nil, nil)

var getClusterHealthChunk* = Call_GetClusterHealthChunk_568298(
    name: "getClusterHealthChunk", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunk_568299, base: "",
    url: url_GetClusterHealthChunk_568300, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterManifest_568316 = ref object of OpenApiRestCall_567667
proc url_GetClusterManifest_568318(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterManifest_568317(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568319 = query.getOrDefault("timeout")
  valid_568319 = validateParameter(valid_568319, JInt, required = false,
                                 default = newJInt(60))
  if valid_568319 != nil:
    section.add "timeout", valid_568319
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568320 = query.getOrDefault("api-version")
  valid_568320 = validateParameter(valid_568320, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568320 != nil:
    section.add "api-version", valid_568320
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568321: Call_GetClusterManifest_568316; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  let valid = call_568321.validator(path, query, header, formData, body)
  let scheme = call_568321.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568321.url(scheme.get, call_568321.host, call_568321.base,
                         call_568321.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568321, url, valid)

proc call*(call_568322: Call_GetClusterManifest_568316; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterManifest
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568323 = newJObject()
  add(query_568323, "timeout", newJInt(timeout))
  add(query_568323, "api-version", newJString(apiVersion))
  result = call_568322.call(nil, query_568323, nil, nil, nil)

var getClusterManifest* = Call_GetClusterManifest_568316(
    name: "getClusterManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterManifest", validator: validate_GetClusterManifest_568317,
    base: "", url: url_GetClusterManifest_568318,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricCodeVersionInfoList_568324 = ref object of OpenApiRestCall_567667
proc url_GetProvisionedFabricCodeVersionInfoList_568326(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricCodeVersionInfoList_568325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: JString
  ##              : The product version of Service Fabric.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568327 = query.getOrDefault("timeout")
  valid_568327 = validateParameter(valid_568327, JInt, required = false,
                                 default = newJInt(60))
  if valid_568327 != nil:
    section.add "timeout", valid_568327
  var valid_568328 = query.getOrDefault("CodeVersion")
  valid_568328 = validateParameter(valid_568328, JString, required = false,
                                 default = nil)
  if valid_568328 != nil:
    section.add "CodeVersion", valid_568328
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568329 = query.getOrDefault("api-version")
  valid_568329 = validateParameter(valid_568329, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568329 != nil:
    section.add "api-version", valid_568329
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568330: Call_GetProvisionedFabricCodeVersionInfoList_568324;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_568330.validator(path, query, header, formData, body)
  let scheme = call_568330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568330.url(scheme.get, call_568330.host, call_568330.base,
                         call_568330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568330, url, valid)

proc call*(call_568331: Call_GetProvisionedFabricCodeVersionInfoList_568324;
          timeout: int = 60; CodeVersion: string = ""; apiVersion: string = "6.0"): Recallable =
  ## getProvisionedFabricCodeVersionInfoList
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: string
  ##              : The product version of Service Fabric.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568332 = newJObject()
  add(query_568332, "timeout", newJInt(timeout))
  add(query_568332, "CodeVersion", newJString(CodeVersion))
  add(query_568332, "api-version", newJString(apiVersion))
  result = call_568331.call(nil, query_568332, nil, nil, nil)

var getProvisionedFabricCodeVersionInfoList* = Call_GetProvisionedFabricCodeVersionInfoList_568324(
    name: "getProvisionedFabricCodeVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedCodeVersions",
    validator: validate_GetProvisionedFabricCodeVersionInfoList_568325, base: "",
    url: url_GetProvisionedFabricCodeVersionInfoList_568326,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricConfigVersionInfoList_568333 = ref object of OpenApiRestCall_567667
proc url_GetProvisionedFabricConfigVersionInfoList_568335(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricConfigVersionInfoList_568334(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: JString
  ##                : The config version of Service Fabric.
  section = newJObject()
  var valid_568336 = query.getOrDefault("timeout")
  valid_568336 = validateParameter(valid_568336, JInt, required = false,
                                 default = newJInt(60))
  if valid_568336 != nil:
    section.add "timeout", valid_568336
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568337 = query.getOrDefault("api-version")
  valid_568337 = validateParameter(valid_568337, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568337 != nil:
    section.add "api-version", valid_568337
  var valid_568338 = query.getOrDefault("ConfigVersion")
  valid_568338 = validateParameter(valid_568338, JString, required = false,
                                 default = nil)
  if valid_568338 != nil:
    section.add "ConfigVersion", valid_568338
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568339: Call_GetProvisionedFabricConfigVersionInfoList_568333;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_568339.validator(path, query, header, formData, body)
  let scheme = call_568339.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568339.url(scheme.get, call_568339.host, call_568339.base,
                         call_568339.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568339, url, valid)

proc call*(call_568340: Call_GetProvisionedFabricConfigVersionInfoList_568333;
          timeout: int = 60; apiVersion: string = "6.0"; ConfigVersion: string = ""): Recallable =
  ## getProvisionedFabricConfigVersionInfoList
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: string
  ##                : The config version of Service Fabric.
  var query_568341 = newJObject()
  add(query_568341, "timeout", newJInt(timeout))
  add(query_568341, "api-version", newJString(apiVersion))
  add(query_568341, "ConfigVersion", newJString(ConfigVersion))
  result = call_568340.call(nil, query_568341, nil, nil, nil)

var getProvisionedFabricConfigVersionInfoList* = Call_GetProvisionedFabricConfigVersionInfoList_568333(
    name: "getProvisionedFabricConfigVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedConfigVersions",
    validator: validate_GetProvisionedFabricConfigVersionInfoList_568334,
    base: "", url: url_GetProvisionedFabricConfigVersionInfoList_568335,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRepairTaskList_568342 = ref object of OpenApiRestCall_567667
proc url_GetRepairTaskList_568344(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRepairTaskList_568343(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TaskIdFilter: JString
  ##               : The repair task ID prefix to be matched.
  ##   ExecutorFilter: JString
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   StateFilter: JInt
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568345 = query.getOrDefault("api-version")
  valid_568345 = validateParameter(valid_568345, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568345 != nil:
    section.add "api-version", valid_568345
  var valid_568346 = query.getOrDefault("TaskIdFilter")
  valid_568346 = validateParameter(valid_568346, JString, required = false,
                                 default = nil)
  if valid_568346 != nil:
    section.add "TaskIdFilter", valid_568346
  var valid_568347 = query.getOrDefault("ExecutorFilter")
  valid_568347 = validateParameter(valid_568347, JString, required = false,
                                 default = nil)
  if valid_568347 != nil:
    section.add "ExecutorFilter", valid_568347
  var valid_568348 = query.getOrDefault("StateFilter")
  valid_568348 = validateParameter(valid_568348, JInt, required = false, default = nil)
  if valid_568348 != nil:
    section.add "StateFilter", valid_568348
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568349: Call_GetRepairTaskList_568342; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568349.validator(path, query, header, formData, body)
  let scheme = call_568349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568349.url(scheme.get, call_568349.host, call_568349.base,
                         call_568349.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568349, url, valid)

proc call*(call_568350: Call_GetRepairTaskList_568342; apiVersion: string = "6.0";
          TaskIdFilter: string = ""; ExecutorFilter: string = ""; StateFilter: int = 0): Recallable =
  ## getRepairTaskList
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TaskIdFilter: string
  ##               : The repair task ID prefix to be matched.
  ##   ExecutorFilter: string
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   StateFilter: int
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  var query_568351 = newJObject()
  add(query_568351, "api-version", newJString(apiVersion))
  add(query_568351, "TaskIdFilter", newJString(TaskIdFilter))
  add(query_568351, "ExecutorFilter", newJString(ExecutorFilter))
  add(query_568351, "StateFilter", newJInt(StateFilter))
  result = call_568350.call(nil, query_568351, nil, nil, nil)

var getRepairTaskList* = Call_GetRepairTaskList_568342(name: "getRepairTaskList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetRepairTaskList", validator: validate_GetRepairTaskList_568343,
    base: "", url: url_GetRepairTaskList_568344,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterUpgradeProgress_568352 = ref object of OpenApiRestCall_567667
proc url_GetClusterUpgradeProgress_568354(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterUpgradeProgress_568353(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568355 = query.getOrDefault("timeout")
  valid_568355 = validateParameter(valid_568355, JInt, required = false,
                                 default = newJInt(60))
  if valid_568355 != nil:
    section.add "timeout", valid_568355
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568356 = query.getOrDefault("api-version")
  valid_568356 = validateParameter(valid_568356, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568356 != nil:
    section.add "api-version", valid_568356
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568357: Call_GetClusterUpgradeProgress_568352; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  let valid = call_568357.validator(path, query, header, formData, body)
  let scheme = call_568357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568357.url(scheme.get, call_568357.host, call_568357.base,
                         call_568357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568357, url, valid)

proc call*(call_568358: Call_GetClusterUpgradeProgress_568352; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterUpgradeProgress
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568359 = newJObject()
  add(query_568359, "timeout", newJInt(timeout))
  add(query_568359, "api-version", newJString(apiVersion))
  result = call_568358.call(nil, query_568359, nil, nil, nil)

var getClusterUpgradeProgress* = Call_GetClusterUpgradeProgress_568352(
    name: "getClusterUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetUpgradeProgress",
    validator: validate_GetClusterUpgradeProgress_568353, base: "",
    url: url_GetClusterUpgradeProgress_568354,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureCommand_568360 = ref object of OpenApiRestCall_567667
proc url_InvokeInfrastructureCommand_568362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureCommand_568361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  var valid_568363 = query.getOrDefault("timeout")
  valid_568363 = validateParameter(valid_568363, JInt, required = false,
                                 default = newJInt(60))
  if valid_568363 != nil:
    section.add "timeout", valid_568363
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568364 = query.getOrDefault("api-version")
  valid_568364 = validateParameter(valid_568364, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568364 != nil:
    section.add "api-version", valid_568364
  var valid_568365 = query.getOrDefault("ServiceId")
  valid_568365 = validateParameter(valid_568365, JString, required = false,
                                 default = nil)
  if valid_568365 != nil:
    section.add "ServiceId", valid_568365
  var valid_568366 = query.getOrDefault("Command")
  valid_568366 = validateParameter(valid_568366, JString, required = true,
                                 default = nil)
  if valid_568366 != nil:
    section.add "Command", valid_568366
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568367: Call_InvokeInfrastructureCommand_568360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568367.validator(path, query, header, formData, body)
  let scheme = call_568367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568367.url(scheme.get, call_568367.host, call_568367.base,
                         call_568367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568367, url, valid)

proc call*(call_568368: Call_InvokeInfrastructureCommand_568360; Command: string;
          timeout: int = 60; apiVersion: string = "6.0"; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureCommand
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_568369 = newJObject()
  add(query_568369, "timeout", newJInt(timeout))
  add(query_568369, "api-version", newJString(apiVersion))
  add(query_568369, "ServiceId", newJString(ServiceId))
  add(query_568369, "Command", newJString(Command))
  result = call_568368.call(nil, query_568369, nil, nil, nil)

var invokeInfrastructureCommand* = Call_InvokeInfrastructureCommand_568360(
    name: "invokeInfrastructureCommand", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureCommand",
    validator: validate_InvokeInfrastructureCommand_568361, base: "",
    url: url_InvokeInfrastructureCommand_568362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureQuery_568370 = ref object of OpenApiRestCall_567667
proc url_InvokeInfrastructureQuery_568372(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureQuery_568371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  var valid_568373 = query.getOrDefault("timeout")
  valid_568373 = validateParameter(valid_568373, JInt, required = false,
                                 default = newJInt(60))
  if valid_568373 != nil:
    section.add "timeout", valid_568373
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568374 = query.getOrDefault("api-version")
  valid_568374 = validateParameter(valid_568374, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568374 != nil:
    section.add "api-version", valid_568374
  var valid_568375 = query.getOrDefault("ServiceId")
  valid_568375 = validateParameter(valid_568375, JString, required = false,
                                 default = nil)
  if valid_568375 != nil:
    section.add "ServiceId", valid_568375
  var valid_568376 = query.getOrDefault("Command")
  valid_568376 = validateParameter(valid_568376, JString, required = true,
                                 default = nil)
  if valid_568376 != nil:
    section.add "Command", valid_568376
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568377: Call_InvokeInfrastructureQuery_568370; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568377.validator(path, query, header, formData, body)
  let scheme = call_568377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568377.url(scheme.get, call_568377.host, call_568377.base,
                         call_568377.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568377, url, valid)

proc call*(call_568378: Call_InvokeInfrastructureQuery_568370; Command: string;
          timeout: int = 60; apiVersion: string = "6.0"; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureQuery
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_568379 = newJObject()
  add(query_568379, "timeout", newJInt(timeout))
  add(query_568379, "api-version", newJString(apiVersion))
  add(query_568379, "ServiceId", newJString(ServiceId))
  add(query_568379, "Command", newJString(Command))
  result = call_568378.call(nil, query_568379, nil, nil, nil)

var invokeInfrastructureQuery* = Call_InvokeInfrastructureQuery_568370(
    name: "invokeInfrastructureQuery", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureQuery",
    validator: validate_InvokeInfrastructureQuery_568371, base: "",
    url: url_InvokeInfrastructureQuery_568372,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeClusterUpgrade_568380 = ref object of OpenApiRestCall_567667
proc url_ResumeClusterUpgrade_568382(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ResumeClusterUpgrade_568381(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568383 = query.getOrDefault("timeout")
  valid_568383 = validateParameter(valid_568383, JInt, required = false,
                                 default = newJInt(60))
  if valid_568383 != nil:
    section.add "timeout", valid_568383
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568384 = query.getOrDefault("api-version")
  valid_568384 = validateParameter(valid_568384, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568384 != nil:
    section.add "api-version", valid_568384
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568386: Call_ResumeClusterUpgrade_568380; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  let valid = call_568386.validator(path, query, header, formData, body)
  let scheme = call_568386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568386.url(scheme.get, call_568386.host, call_568386.base,
                         call_568386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568386, url, valid)

proc call*(call_568387: Call_ResumeClusterUpgrade_568380;
          ResumeClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## resumeClusterUpgrade
  ## Make the cluster upgrade move on to the next upgrade domain.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  var query_568388 = newJObject()
  var body_568389 = newJObject()
  add(query_568388, "timeout", newJInt(timeout))
  add(query_568388, "api-version", newJString(apiVersion))
  if ResumeClusterUpgradeDescription != nil:
    body_568389 = ResumeClusterUpgradeDescription
  result = call_568387.call(nil, query_568388, nil, nil, body_568389)

var resumeClusterUpgrade* = Call_ResumeClusterUpgrade_568380(
    name: "resumeClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeClusterUpgrade_568381, base: "",
    url: url_ResumeClusterUpgrade_568382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionCluster_568390 = ref object of OpenApiRestCall_567667
proc url_ProvisionCluster_568392(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionCluster_568391(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568393 = query.getOrDefault("timeout")
  valid_568393 = validateParameter(valid_568393, JInt, required = false,
                                 default = newJInt(60))
  if valid_568393 != nil:
    section.add "timeout", valid_568393
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568394 = query.getOrDefault("api-version")
  valid_568394 = validateParameter(valid_568394, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568394 != nil:
    section.add "api-version", valid_568394
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568396: Call_ProvisionCluster_568390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_568396.validator(path, query, header, formData, body)
  let scheme = call_568396.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568396.url(scheme.get, call_568396.host, call_568396.base,
                         call_568396.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568396, url, valid)

proc call*(call_568397: Call_ProvisionCluster_568390;
          ProvisionFabricDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## provisionCluster
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  var query_568398 = newJObject()
  var body_568399 = newJObject()
  add(query_568398, "timeout", newJInt(timeout))
  add(query_568398, "api-version", newJString(apiVersion))
  if ProvisionFabricDescription != nil:
    body_568399 = ProvisionFabricDescription
  result = call_568397.call(nil, query_568398, nil, nil, body_568399)

var provisionCluster* = Call_ProvisionCluster_568390(name: "provisionCluster",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/$/Provision",
    validator: validate_ProvisionCluster_568391, base: "",
    url: url_ProvisionCluster_568392, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverAllPartitions_568400 = ref object of OpenApiRestCall_567667
proc url_RecoverAllPartitions_568402(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverAllPartitions_568401(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568403 = query.getOrDefault("timeout")
  valid_568403 = validateParameter(valid_568403, JInt, required = false,
                                 default = newJInt(60))
  if valid_568403 != nil:
    section.add "timeout", valid_568403
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568404 = query.getOrDefault("api-version")
  valid_568404 = validateParameter(valid_568404, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568404 != nil:
    section.add "api-version", valid_568404
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568405: Call_RecoverAllPartitions_568400; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_568405.validator(path, query, header, formData, body)
  let scheme = call_568405.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568405.url(scheme.get, call_568405.host, call_568405.base,
                         call_568405.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568405, url, valid)

proc call*(call_568406: Call_RecoverAllPartitions_568400; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## recoverAllPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568407 = newJObject()
  add(query_568407, "timeout", newJInt(timeout))
  add(query_568407, "api-version", newJString(apiVersion))
  result = call_568406.call(nil, query_568407, nil, nil, nil)

var recoverAllPartitions* = Call_RecoverAllPartitions_568400(
    name: "recoverAllPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverAllPartitions",
    validator: validate_RecoverAllPartitions_568401, base: "",
    url: url_RecoverAllPartitions_568402, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverSystemPartitions_568408 = ref object of OpenApiRestCall_567667
proc url_RecoverSystemPartitions_568410(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverSystemPartitions_568409(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568411 = query.getOrDefault("timeout")
  valid_568411 = validateParameter(valid_568411, JInt, required = false,
                                 default = newJInt(60))
  if valid_568411 != nil:
    section.add "timeout", valid_568411
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568412 = query.getOrDefault("api-version")
  valid_568412 = validateParameter(valid_568412, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568412 != nil:
    section.add "api-version", valid_568412
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568413: Call_RecoverSystemPartitions_568408; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_568413.validator(path, query, header, formData, body)
  let scheme = call_568413.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568413.url(scheme.get, call_568413.host, call_568413.base,
                         call_568413.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568413, url, valid)

proc call*(call_568414: Call_RecoverSystemPartitions_568408; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## recoverSystemPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568415 = newJObject()
  add(query_568415, "timeout", newJInt(timeout))
  add(query_568415, "api-version", newJString(apiVersion))
  result = call_568414.call(nil, query_568415, nil, nil, nil)

var recoverSystemPartitions* = Call_RecoverSystemPartitions_568408(
    name: "recoverSystemPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverSystemPartitions",
    validator: validate_RecoverSystemPartitions_568409, base: "",
    url: url_RecoverSystemPartitions_568410, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportClusterHealth_568416 = ref object of OpenApiRestCall_567667
proc url_ReportClusterHealth_568418(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ReportClusterHealth_568417(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568419 = query.getOrDefault("Immediate")
  valid_568419 = validateParameter(valid_568419, JBool, required = false,
                                 default = newJBool(false))
  if valid_568419 != nil:
    section.add "Immediate", valid_568419
  var valid_568420 = query.getOrDefault("timeout")
  valid_568420 = validateParameter(valid_568420, JInt, required = false,
                                 default = newJInt(60))
  if valid_568420 != nil:
    section.add "timeout", valid_568420
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568421 = query.getOrDefault("api-version")
  valid_568421 = validateParameter(valid_568421, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568421 != nil:
    section.add "api-version", valid_568421
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568423: Call_ReportClusterHealth_568416; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_568423.validator(path, query, header, formData, body)
  let scheme = call_568423.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568423.url(scheme.get, call_568423.host, call_568423.base,
                         call_568423.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568423, url, valid)

proc call*(call_568424: Call_ReportClusterHealth_568416;
          HealthInformation: JsonNode; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportClusterHealth
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  var query_568425 = newJObject()
  var body_568426 = newJObject()
  add(query_568425, "Immediate", newJBool(Immediate))
  add(query_568425, "timeout", newJInt(timeout))
  add(query_568425, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_568426 = HealthInformation
  result = call_568424.call(nil, query_568425, nil, nil, body_568426)

var reportClusterHealth* = Call_ReportClusterHealth_568416(
    name: "reportClusterHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ReportClusterHealth",
    validator: validate_ReportClusterHealth_568417, base: "",
    url: url_ReportClusterHealth_568418, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackClusterUpgrade_568427 = ref object of OpenApiRestCall_567667
proc url_RollbackClusterUpgrade_568429(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RollbackClusterUpgrade_568428(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568430 = query.getOrDefault("timeout")
  valid_568430 = validateParameter(valid_568430, JInt, required = false,
                                 default = newJInt(60))
  if valid_568430 != nil:
    section.add "timeout", valid_568430
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568431 = query.getOrDefault("api-version")
  valid_568431 = validateParameter(valid_568431, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568431 != nil:
    section.add "api-version", valid_568431
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568432: Call_RollbackClusterUpgrade_568427; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  let valid = call_568432.validator(path, query, header, formData, body)
  let scheme = call_568432.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568432.url(scheme.get, call_568432.host, call_568432.base,
                         call_568432.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568432, url, valid)

proc call*(call_568433: Call_RollbackClusterUpgrade_568427; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## rollbackClusterUpgrade
  ## Rollback the upgrade of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568434 = newJObject()
  add(query_568434, "timeout", newJInt(timeout))
  add(query_568434, "api-version", newJString(apiVersion))
  result = call_568433.call(nil, query_568434, nil, nil, nil)

var rollbackClusterUpgrade* = Call_RollbackClusterUpgrade_568427(
    name: "rollbackClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RollbackUpgrade",
    validator: validate_RollbackClusterUpgrade_568428, base: "",
    url: url_RollbackClusterUpgrade_568429, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterConfigurationUpgrade_568435 = ref object of OpenApiRestCall_567667
proc url_StartClusterConfigurationUpgrade_568437(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterConfigurationUpgrade_568436(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568438 = query.getOrDefault("timeout")
  valid_568438 = validateParameter(valid_568438, JInt, required = false,
                                 default = newJInt(60))
  if valid_568438 != nil:
    section.add "timeout", valid_568438
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568439 = query.getOrDefault("api-version")
  valid_568439 = validateParameter(valid_568439, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568439 != nil:
    section.add "api-version", valid_568439
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568441: Call_StartClusterConfigurationUpgrade_568435;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  let valid = call_568441.validator(path, query, header, formData, body)
  let scheme = call_568441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568441.url(scheme.get, call_568441.host, call_568441.base,
                         call_568441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568441, url, valid)

proc call*(call_568442: Call_StartClusterConfigurationUpgrade_568435;
          ClusterConfigurationUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startClusterConfigurationUpgrade
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  var query_568443 = newJObject()
  var body_568444 = newJObject()
  add(query_568443, "timeout", newJInt(timeout))
  add(query_568443, "api-version", newJString(apiVersion))
  if ClusterConfigurationUpgradeDescription != nil:
    body_568444 = ClusterConfigurationUpgradeDescription
  result = call_568442.call(nil, query_568443, nil, nil, body_568444)

var startClusterConfigurationUpgrade* = Call_StartClusterConfigurationUpgrade_568435(
    name: "startClusterConfigurationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/StartClusterConfigurationUpgrade",
    validator: validate_StartClusterConfigurationUpgrade_568436, base: "",
    url: url_StartClusterConfigurationUpgrade_568437,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionCluster_568445 = ref object of OpenApiRestCall_567667
proc url_UnprovisionCluster_568447(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UnprovisionCluster_568446(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568448 = query.getOrDefault("timeout")
  valid_568448 = validateParameter(valid_568448, JInt, required = false,
                                 default = newJInt(60))
  if valid_568448 != nil:
    section.add "timeout", valid_568448
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568449 = query.getOrDefault("api-version")
  valid_568449 = validateParameter(valid_568449, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568449 != nil:
    section.add "api-version", valid_568449
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568451: Call_UnprovisionCluster_568445; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_568451.validator(path, query, header, formData, body)
  let scheme = call_568451.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568451.url(scheme.get, call_568451.host, call_568451.base,
                         call_568451.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568451, url, valid)

proc call*(call_568452: Call_UnprovisionCluster_568445;
          UnprovisionFabricDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## unprovisionCluster
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  var query_568453 = newJObject()
  var body_568454 = newJObject()
  add(query_568453, "timeout", newJInt(timeout))
  add(query_568453, "api-version", newJString(apiVersion))
  if UnprovisionFabricDescription != nil:
    body_568454 = UnprovisionFabricDescription
  result = call_568452.call(nil, query_568453, nil, nil, body_568454)

var unprovisionCluster* = Call_UnprovisionCluster_568445(
    name: "unprovisionCluster", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Unprovision",
    validator: validate_UnprovisionCluster_568446, base: "",
    url: url_UnprovisionCluster_568447, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairExecutionState_568455 = ref object of OpenApiRestCall_567667
proc url_UpdateRepairExecutionState_568457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairExecutionState_568456(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568458 = query.getOrDefault("api-version")
  valid_568458 = validateParameter(valid_568458, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568458 != nil:
    section.add "api-version", valid_568458
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568460: Call_UpdateRepairExecutionState_568455; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568460.validator(path, query, header, formData, body)
  let scheme = call_568460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568460.url(scheme.get, call_568460.host, call_568460.base,
                         call_568460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568460, url, valid)

proc call*(call_568461: Call_UpdateRepairExecutionState_568455;
          RepairTask: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## updateRepairExecutionState
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568462 = newJObject()
  var body_568463 = newJObject()
  if RepairTask != nil:
    body_568463 = RepairTask
  add(query_568462, "api-version", newJString(apiVersion))
  result = call_568461.call(nil, query_568462, nil, nil, body_568463)

var updateRepairExecutionState* = Call_UpdateRepairExecutionState_568455(
    name: "updateRepairExecutionState", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairExecutionState",
    validator: validate_UpdateRepairExecutionState_568456, base: "",
    url: url_UpdateRepairExecutionState_568457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairTaskHealthPolicy_568464 = ref object of OpenApiRestCall_567667
proc url_UpdateRepairTaskHealthPolicy_568466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairTaskHealthPolicy_568465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568467 = query.getOrDefault("api-version")
  valid_568467 = validateParameter(valid_568467, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568467 != nil:
    section.add "api-version", valid_568467
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568469: Call_UpdateRepairTaskHealthPolicy_568464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_568469.validator(path, query, header, formData, body)
  let scheme = call_568469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568469.url(scheme.get, call_568469.host, call_568469.base,
                         call_568469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568469, url, valid)

proc call*(call_568470: Call_UpdateRepairTaskHealthPolicy_568464;
          RepairTaskUpdateHealthPolicyDescription: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## updateRepairTaskHealthPolicy
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  var query_568471 = newJObject()
  var body_568472 = newJObject()
  add(query_568471, "api-version", newJString(apiVersion))
  if RepairTaskUpdateHealthPolicyDescription != nil:
    body_568472 = RepairTaskUpdateHealthPolicyDescription
  result = call_568470.call(nil, query_568471, nil, nil, body_568472)

var updateRepairTaskHealthPolicy* = Call_UpdateRepairTaskHealthPolicy_568464(
    name: "updateRepairTaskHealthPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairTaskHealthPolicy",
    validator: validate_UpdateRepairTaskHealthPolicy_568465, base: "",
    url: url_UpdateRepairTaskHealthPolicy_568466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateClusterUpgrade_568473 = ref object of OpenApiRestCall_567667
proc url_UpdateClusterUpgrade_568475(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateClusterUpgrade_568474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568476 = query.getOrDefault("timeout")
  valid_568476 = validateParameter(valid_568476, JInt, required = false,
                                 default = newJInt(60))
  if valid_568476 != nil:
    section.add "timeout", valid_568476
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568477 = query.getOrDefault("api-version")
  valid_568477 = validateParameter(valid_568477, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568477 != nil:
    section.add "api-version", valid_568477
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568479: Call_UpdateClusterUpgrade_568473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  let valid = call_568479.validator(path, query, header, formData, body)
  let scheme = call_568479.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568479.url(scheme.get, call_568479.host, call_568479.base,
                         call_568479.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568479, url, valid)

proc call*(call_568480: Call_UpdateClusterUpgrade_568473;
          UpdateClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## updateClusterUpgrade
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  var query_568481 = newJObject()
  var body_568482 = newJObject()
  add(query_568481, "timeout", newJInt(timeout))
  add(query_568481, "api-version", newJString(apiVersion))
  if UpdateClusterUpgradeDescription != nil:
    body_568482 = UpdateClusterUpgradeDescription
  result = call_568480.call(nil, query_568481, nil, nil, body_568482)

var updateClusterUpgrade* = Call_UpdateClusterUpgrade_568473(
    name: "updateClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateUpgrade",
    validator: validate_UpdateClusterUpgrade_568474, base: "",
    url: url_UpdateClusterUpgrade_568475, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterUpgrade_568483 = ref object of OpenApiRestCall_567667
proc url_StartClusterUpgrade_568485(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterUpgrade_568484(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568486 = query.getOrDefault("timeout")
  valid_568486 = validateParameter(valid_568486, JInt, required = false,
                                 default = newJInt(60))
  if valid_568486 != nil:
    section.add "timeout", valid_568486
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568487 = query.getOrDefault("api-version")
  valid_568487 = validateParameter(valid_568487, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568487 != nil:
    section.add "api-version", valid_568487
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568489: Call_StartClusterUpgrade_568483; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  let valid = call_568489.validator(path, query, header, formData, body)
  let scheme = call_568489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568489.url(scheme.get, call_568489.host, call_568489.base,
                         call_568489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568489, url, valid)

proc call*(call_568490: Call_StartClusterUpgrade_568483;
          StartClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startClusterUpgrade
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  var query_568491 = newJObject()
  var body_568492 = newJObject()
  add(query_568491, "timeout", newJInt(timeout))
  add(query_568491, "api-version", newJString(apiVersion))
  if StartClusterUpgradeDescription != nil:
    body_568492 = StartClusterUpgradeDescription
  result = call_568490.call(nil, query_568491, nil, nil, body_568492)

var startClusterUpgrade* = Call_StartClusterUpgrade_568483(
    name: "startClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Upgrade",
    validator: validate_StartClusterUpgrade_568484, base: "",
    url: url_StartClusterUpgrade_568485, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoList_568493 = ref object of OpenApiRestCall_567667
proc url_GetApplicationTypeInfoList_568495(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationTypeInfoList_568494(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeDefinitionKindFilter: JInt
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_568496 = query.getOrDefault("timeout")
  valid_568496 = validateParameter(valid_568496, JInt, required = false,
                                 default = newJInt(60))
  if valid_568496 != nil:
    section.add "timeout", valid_568496
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568497 = query.getOrDefault("api-version")
  valid_568497 = validateParameter(valid_568497, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568497 != nil:
    section.add "api-version", valid_568497
  var valid_568498 = query.getOrDefault("ApplicationTypeDefinitionKindFilter")
  valid_568498 = validateParameter(valid_568498, JInt, required = false,
                                 default = newJInt(0))
  if valid_568498 != nil:
    section.add "ApplicationTypeDefinitionKindFilter", valid_568498
  var valid_568499 = query.getOrDefault("ContinuationToken")
  valid_568499 = validateParameter(valid_568499, JString, required = false,
                                 default = nil)
  if valid_568499 != nil:
    section.add "ContinuationToken", valid_568499
  var valid_568500 = query.getOrDefault("MaxResults")
  valid_568500 = validateParameter(valid_568500, JInt, required = false,
                                 default = newJInt(0))
  if valid_568500 != nil:
    section.add "MaxResults", valid_568500
  var valid_568501 = query.getOrDefault("ExcludeApplicationParameters")
  valid_568501 = validateParameter(valid_568501, JBool, required = false,
                                 default = newJBool(false))
  if valid_568501 != nil:
    section.add "ExcludeApplicationParameters", valid_568501
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568502: Call_GetApplicationTypeInfoList_568493; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_568502.validator(path, query, header, formData, body)
  let scheme = call_568502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568502.url(scheme.get, call_568502.host, call_568502.base,
                         call_568502.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568502, url, valid)

proc call*(call_568503: Call_GetApplicationTypeInfoList_568493; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationTypeDefinitionKindFilter: int = 0;
          ContinuationToken: string = ""; MaxResults: int = 0;
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoList
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeDefinitionKindFilter: int
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_568504 = newJObject()
  add(query_568504, "timeout", newJInt(timeout))
  add(query_568504, "api-version", newJString(apiVersion))
  add(query_568504, "ApplicationTypeDefinitionKindFilter",
      newJInt(ApplicationTypeDefinitionKindFilter))
  add(query_568504, "ContinuationToken", newJString(ContinuationToken))
  add(query_568504, "MaxResults", newJInt(MaxResults))
  add(query_568504, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_568503.call(nil, query_568504, nil, nil, nil)

var getApplicationTypeInfoList* = Call_GetApplicationTypeInfoList_568493(
    name: "getApplicationTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes",
    validator: validate_GetApplicationTypeInfoList_568494, base: "",
    url: url_GetApplicationTypeInfoList_568495,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionApplicationType_568505 = ref object of OpenApiRestCall_567667
proc url_ProvisionApplicationType_568507(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionApplicationType_568506(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568508 = query.getOrDefault("timeout")
  valid_568508 = validateParameter(valid_568508, JInt, required = false,
                                 default = newJInt(60))
  if valid_568508 != nil:
    section.add "timeout", valid_568508
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568509 = query.getOrDefault("api-version")
  valid_568509 = validateParameter(valid_568509, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568509 != nil:
    section.add "api-version", valid_568509
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568511: Call_ProvisionApplicationType_568505; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  let valid = call_568511.validator(path, query, header, formData, body)
  let scheme = call_568511.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568511.url(scheme.get, call_568511.host, call_568511.base,
                         call_568511.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568511, url, valid)

proc call*(call_568512: Call_ProvisionApplicationType_568505;
          ApplicationTypeImageStorePath: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## provisionApplicationType
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  var query_568513 = newJObject()
  var body_568514 = newJObject()
  add(query_568513, "timeout", newJInt(timeout))
  add(query_568513, "api-version", newJString(apiVersion))
  if ApplicationTypeImageStorePath != nil:
    body_568514 = ApplicationTypeImageStorePath
  result = call_568512.call(nil, query_568513, nil, nil, body_568514)

var provisionApplicationType* = Call_ProvisionApplicationType_568505(
    name: "provisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ApplicationTypes/$/Provision",
    validator: validate_ProvisionApplicationType_568506, base: "",
    url: url_ProvisionApplicationType_568507, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoListByName_568515 = ref object of OpenApiRestCall_567667
proc url_GetApplicationTypeInfoListByName_568517(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationTypeInfoListByName_568516(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_568532 = path.getOrDefault("applicationTypeName")
  valid_568532 = validateParameter(valid_568532, JString, required = true,
                                 default = nil)
  if valid_568532 != nil:
    section.add "applicationTypeName", valid_568532
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString
  ##                         : The version of the application type.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_568533 = query.getOrDefault("timeout")
  valid_568533 = validateParameter(valid_568533, JInt, required = false,
                                 default = newJInt(60))
  if valid_568533 != nil:
    section.add "timeout", valid_568533
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568534 = query.getOrDefault("api-version")
  valid_568534 = validateParameter(valid_568534, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568534 != nil:
    section.add "api-version", valid_568534
  var valid_568535 = query.getOrDefault("ApplicationTypeVersion")
  valid_568535 = validateParameter(valid_568535, JString, required = false,
                                 default = nil)
  if valid_568535 != nil:
    section.add "ApplicationTypeVersion", valid_568535
  var valid_568536 = query.getOrDefault("ContinuationToken")
  valid_568536 = validateParameter(valid_568536, JString, required = false,
                                 default = nil)
  if valid_568536 != nil:
    section.add "ContinuationToken", valid_568536
  var valid_568537 = query.getOrDefault("MaxResults")
  valid_568537 = validateParameter(valid_568537, JInt, required = false,
                                 default = newJInt(0))
  if valid_568537 != nil:
    section.add "MaxResults", valid_568537
  var valid_568538 = query.getOrDefault("ExcludeApplicationParameters")
  valid_568538 = validateParameter(valid_568538, JBool, required = false,
                                 default = newJBool(false))
  if valid_568538 != nil:
    section.add "ExcludeApplicationParameters", valid_568538
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568539: Call_GetApplicationTypeInfoListByName_568515;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_568539.validator(path, query, header, formData, body)
  let scheme = call_568539.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568539.url(scheme.get, call_568539.host, call_568539.base,
                         call_568539.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568539, url, valid)

proc call*(call_568540: Call_GetApplicationTypeInfoListByName_568515;
          applicationTypeName: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationTypeVersion: string = ""; ContinuationToken: string = "";
          MaxResults: int = 0; ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoListByName
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string
  ##                         : The version of the application type.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var path_568541 = newJObject()
  var query_568542 = newJObject()
  add(query_568542, "timeout", newJInt(timeout))
  add(query_568542, "api-version", newJString(apiVersion))
  add(path_568541, "applicationTypeName", newJString(applicationTypeName))
  add(query_568542, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_568542, "ContinuationToken", newJString(ContinuationToken))
  add(query_568542, "MaxResults", newJInt(MaxResults))
  add(query_568542, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_568540.call(path_568541, query_568542, nil, nil, nil)

var getApplicationTypeInfoListByName* = Call_GetApplicationTypeInfoListByName_568515(
    name: "getApplicationTypeInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes/{applicationTypeName}",
    validator: validate_GetApplicationTypeInfoListByName_568516, base: "",
    url: url_GetApplicationTypeInfoListByName_568517,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationManifest_568543 = ref object of OpenApiRestCall_567667
proc url_GetApplicationManifest_568545(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetApplicationManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationManifest_568544(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_568546 = path.getOrDefault("applicationTypeName")
  valid_568546 = validateParameter(valid_568546, JString, required = true,
                                 default = nil)
  if valid_568546 != nil:
    section.add "applicationTypeName", valid_568546
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  section = newJObject()
  var valid_568547 = query.getOrDefault("timeout")
  valid_568547 = validateParameter(valid_568547, JInt, required = false,
                                 default = newJInt(60))
  if valid_568547 != nil:
    section.add "timeout", valid_568547
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568548 = query.getOrDefault("api-version")
  valid_568548 = validateParameter(valid_568548, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568548 != nil:
    section.add "api-version", valid_568548
  var valid_568549 = query.getOrDefault("ApplicationTypeVersion")
  valid_568549 = validateParameter(valid_568549, JString, required = true,
                                 default = nil)
  if valid_568549 != nil:
    section.add "ApplicationTypeVersion", valid_568549
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568550: Call_GetApplicationManifest_568543; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  let valid = call_568550.validator(path, query, header, formData, body)
  let scheme = call_568550.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568550.url(scheme.get, call_568550.host, call_568550.base,
                         call_568550.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568550, url, valid)

proc call*(call_568551: Call_GetApplicationManifest_568543;
          applicationTypeName: string; ApplicationTypeVersion: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationManifest
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  var path_568552 = newJObject()
  var query_568553 = newJObject()
  add(query_568553, "timeout", newJInt(timeout))
  add(query_568553, "api-version", newJString(apiVersion))
  add(path_568552, "applicationTypeName", newJString(applicationTypeName))
  add(query_568553, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  result = call_568551.call(path_568552, query_568553, nil, nil, nil)

var getApplicationManifest* = Call_GetApplicationManifest_568543(
    name: "getApplicationManifest", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest",
    validator: validate_GetApplicationManifest_568544, base: "",
    url: url_GetApplicationManifest_568545, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceManifest_568554 = ref object of OpenApiRestCall_567667
proc url_GetServiceManifest_568556(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceManifest_568555(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_568557 = path.getOrDefault("applicationTypeName")
  valid_568557 = validateParameter(valid_568557, JString, required = true,
                                 default = nil)
  if valid_568557 != nil:
    section.add "applicationTypeName", valid_568557
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  ##   ServiceManifestName: JString (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  var valid_568558 = query.getOrDefault("timeout")
  valid_568558 = validateParameter(valid_568558, JInt, required = false,
                                 default = newJInt(60))
  if valid_568558 != nil:
    section.add "timeout", valid_568558
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568559 = query.getOrDefault("api-version")
  valid_568559 = validateParameter(valid_568559, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568559 != nil:
    section.add "api-version", valid_568559
  var valid_568560 = query.getOrDefault("ApplicationTypeVersion")
  valid_568560 = validateParameter(valid_568560, JString, required = true,
                                 default = nil)
  if valid_568560 != nil:
    section.add "ApplicationTypeVersion", valid_568560
  var valid_568561 = query.getOrDefault("ServiceManifestName")
  valid_568561 = validateParameter(valid_568561, JString, required = true,
                                 default = nil)
  if valid_568561 != nil:
    section.add "ServiceManifestName", valid_568561
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568562: Call_GetServiceManifest_568554; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  let valid = call_568562.validator(path, query, header, formData, body)
  let scheme = call_568562.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568562.url(scheme.get, call_568562.host, call_568562.base,
                         call_568562.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568562, url, valid)

proc call*(call_568563: Call_GetServiceManifest_568554;
          applicationTypeName: string; ApplicationTypeVersion: string;
          ServiceManifestName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceManifest
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  ##   ServiceManifestName: string (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  var path_568564 = newJObject()
  var query_568565 = newJObject()
  add(query_568565, "timeout", newJInt(timeout))
  add(query_568565, "api-version", newJString(apiVersion))
  add(path_568564, "applicationTypeName", newJString(applicationTypeName))
  add(query_568565, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_568565, "ServiceManifestName", newJString(ServiceManifestName))
  result = call_568563.call(path_568564, query_568565, nil, nil, nil)

var getServiceManifest* = Call_GetServiceManifest_568554(
    name: "getServiceManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceManifest",
    validator: validate_GetServiceManifest_568555, base: "",
    url: url_GetServiceManifest_568556, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceTypeInfoList_568566 = ref object of OpenApiRestCall_567667
proc url_GetServiceTypeInfoList_568568(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceTypeInfoList_568567(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_568569 = path.getOrDefault("applicationTypeName")
  valid_568569 = validateParameter(valid_568569, JString, required = true,
                                 default = nil)
  if valid_568569 != nil:
    section.add "applicationTypeName", valid_568569
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  section = newJObject()
  var valid_568570 = query.getOrDefault("timeout")
  valid_568570 = validateParameter(valid_568570, JInt, required = false,
                                 default = newJInt(60))
  if valid_568570 != nil:
    section.add "timeout", valid_568570
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568571 = query.getOrDefault("api-version")
  valid_568571 = validateParameter(valid_568571, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568571 != nil:
    section.add "api-version", valid_568571
  var valid_568572 = query.getOrDefault("ApplicationTypeVersion")
  valid_568572 = validateParameter(valid_568572, JString, required = true,
                                 default = nil)
  if valid_568572 != nil:
    section.add "ApplicationTypeVersion", valid_568572
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568573: Call_GetServiceTypeInfoList_568566; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  let valid = call_568573.validator(path, query, header, formData, body)
  let scheme = call_568573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568573.url(scheme.get, call_568573.host, call_568573.base,
                         call_568573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568573, url, valid)

proc call*(call_568574: Call_GetServiceTypeInfoList_568566;
          applicationTypeName: string; ApplicationTypeVersion: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceTypeInfoList
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  var path_568575 = newJObject()
  var query_568576 = newJObject()
  add(query_568576, "timeout", newJInt(timeout))
  add(query_568576, "api-version", newJString(apiVersion))
  add(path_568575, "applicationTypeName", newJString(applicationTypeName))
  add(query_568576, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  result = call_568574.call(path_568575, query_568576, nil, nil, nil)

var getServiceTypeInfoList* = Call_GetServiceTypeInfoList_568566(
    name: "getServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceTypes",
    validator: validate_GetServiceTypeInfoList_568567, base: "",
    url: url_GetServiceTypeInfoList_568568, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionApplicationType_568577 = ref object of OpenApiRestCall_567667
proc url_UnprovisionApplicationType_568579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/Unprovision")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UnprovisionApplicationType_568578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_568580 = path.getOrDefault("applicationTypeName")
  valid_568580 = validateParameter(valid_568580, JString, required = true,
                                 default = nil)
  if valid_568580 != nil:
    section.add "applicationTypeName", valid_568580
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568581 = query.getOrDefault("timeout")
  valid_568581 = validateParameter(valid_568581, JInt, required = false,
                                 default = newJInt(60))
  if valid_568581 != nil:
    section.add "timeout", valid_568581
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568582 = query.getOrDefault("api-version")
  valid_568582 = validateParameter(valid_568582, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568582 != nil:
    section.add "api-version", valid_568582
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568584: Call_UnprovisionApplicationType_568577; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  let valid = call_568584.validator(path, query, header, formData, body)
  let scheme = call_568584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568584.url(scheme.get, call_568584.host, call_568584.base,
                         call_568584.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568584, url, valid)

proc call*(call_568585: Call_UnprovisionApplicationType_568577;
          ApplicationTypeImageStoreVersion: JsonNode; applicationTypeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## unprovisionApplicationType
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  var path_568586 = newJObject()
  var query_568587 = newJObject()
  var body_568588 = newJObject()
  if ApplicationTypeImageStoreVersion != nil:
    body_568588 = ApplicationTypeImageStoreVersion
  add(query_568587, "timeout", newJInt(timeout))
  add(query_568587, "api-version", newJString(apiVersion))
  add(path_568586, "applicationTypeName", newJString(applicationTypeName))
  result = call_568585.call(path_568586, query_568587, nil, nil, body_568588)

var unprovisionApplicationType* = Call_UnprovisionApplicationType_568577(
    name: "unprovisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/Unprovision",
    validator: validate_UnprovisionApplicationType_568578, base: "",
    url: url_UnprovisionApplicationType_568579,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfoList_568589 = ref object of OpenApiRestCall_567667
proc url_GetApplicationInfoList_568591(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationInfoList_568590(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationDefinitionKindFilter: JInt
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeName: JString
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_568592 = query.getOrDefault("timeout")
  valid_568592 = validateParameter(valid_568592, JInt, required = false,
                                 default = newJInt(60))
  if valid_568592 != nil:
    section.add "timeout", valid_568592
  var valid_568593 = query.getOrDefault("ApplicationDefinitionKindFilter")
  valid_568593 = validateParameter(valid_568593, JInt, required = false,
                                 default = newJInt(0))
  if valid_568593 != nil:
    section.add "ApplicationDefinitionKindFilter", valid_568593
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568594 = query.getOrDefault("api-version")
  valid_568594 = validateParameter(valid_568594, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568594 != nil:
    section.add "api-version", valid_568594
  var valid_568595 = query.getOrDefault("ApplicationTypeName")
  valid_568595 = validateParameter(valid_568595, JString, required = false,
                                 default = nil)
  if valid_568595 != nil:
    section.add "ApplicationTypeName", valid_568595
  var valid_568596 = query.getOrDefault("ContinuationToken")
  valid_568596 = validateParameter(valid_568596, JString, required = false,
                                 default = nil)
  if valid_568596 != nil:
    section.add "ContinuationToken", valid_568596
  var valid_568597 = query.getOrDefault("ExcludeApplicationParameters")
  valid_568597 = validateParameter(valid_568597, JBool, required = false,
                                 default = newJBool(false))
  if valid_568597 != nil:
    section.add "ExcludeApplicationParameters", valid_568597
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568598: Call_GetApplicationInfoList_568589; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  let valid = call_568598.validator(path, query, header, formData, body)
  let scheme = call_568598.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568598.url(scheme.get, call_568598.host, call_568598.base,
                         call_568598.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568598, url, valid)

proc call*(call_568599: Call_GetApplicationInfoList_568589; timeout: int = 60;
          ApplicationDefinitionKindFilter: int = 0; apiVersion: string = "6.0";
          ApplicationTypeName: string = ""; ContinuationToken: string = "";
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfoList
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationDefinitionKindFilter: int
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeName: string
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_568600 = newJObject()
  add(query_568600, "timeout", newJInt(timeout))
  add(query_568600, "ApplicationDefinitionKindFilter",
      newJInt(ApplicationDefinitionKindFilter))
  add(query_568600, "api-version", newJString(apiVersion))
  add(query_568600, "ApplicationTypeName", newJString(ApplicationTypeName))
  add(query_568600, "ContinuationToken", newJString(ContinuationToken))
  add(query_568600, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_568599.call(nil, query_568600, nil, nil, nil)

var getApplicationInfoList* = Call_GetApplicationInfoList_568589(
    name: "getApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications",
    validator: validate_GetApplicationInfoList_568590, base: "",
    url: url_GetApplicationInfoList_568591, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateApplication_568601 = ref object of OpenApiRestCall_567667
proc url_CreateApplication_568603(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateApplication_568602(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Creates a Service Fabric application using the specified description.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568604 = query.getOrDefault("timeout")
  valid_568604 = validateParameter(valid_568604, JInt, required = false,
                                 default = newJInt(60))
  if valid_568604 != nil:
    section.add "timeout", valid_568604
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568605 = query.getOrDefault("api-version")
  valid_568605 = validateParameter(valid_568605, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568605 != nil:
    section.add "api-version", valid_568605
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568607: Call_CreateApplication_568601; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric application using the specified description.
  ## 
  let valid = call_568607.validator(path, query, header, formData, body)
  let scheme = call_568607.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568607.url(scheme.get, call_568607.host, call_568607.base,
                         call_568607.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568607, url, valid)

proc call*(call_568608: Call_CreateApplication_568601;
          ApplicationDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## createApplication
  ## Creates a Service Fabric application using the specified description.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  var query_568609 = newJObject()
  var body_568610 = newJObject()
  add(query_568609, "timeout", newJInt(timeout))
  add(query_568609, "api-version", newJString(apiVersion))
  if ApplicationDescription != nil:
    body_568610 = ApplicationDescription
  result = call_568608.call(nil, query_568609, nil, nil, body_568610)

var createApplication* = Call_CreateApplication_568601(name: "createApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/$/Create", validator: validate_CreateApplication_568602,
    base: "", url: url_CreateApplication_568603,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfo_568611 = ref object of OpenApiRestCall_567667
proc url_GetApplicationInfo_568613(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationInfo_568612(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568614 = path.getOrDefault("applicationId")
  valid_568614 = validateParameter(valid_568614, JString, required = true,
                                 default = nil)
  if valid_568614 != nil:
    section.add "applicationId", valid_568614
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_568615 = query.getOrDefault("timeout")
  valid_568615 = validateParameter(valid_568615, JInt, required = false,
                                 default = newJInt(60))
  if valid_568615 != nil:
    section.add "timeout", valid_568615
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568616 = query.getOrDefault("api-version")
  valid_568616 = validateParameter(valid_568616, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568616 != nil:
    section.add "api-version", valid_568616
  var valid_568617 = query.getOrDefault("ExcludeApplicationParameters")
  valid_568617 = validateParameter(valid_568617, JBool, required = false,
                                 default = newJBool(false))
  if valid_568617 != nil:
    section.add "ExcludeApplicationParameters", valid_568617
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568618: Call_GetApplicationInfo_568611; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  let valid = call_568618.validator(path, query, header, formData, body)
  let scheme = call_568618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568618.url(scheme.get, call_568618.host, call_568618.base,
                         call_568618.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568618, url, valid)

proc call*(call_568619: Call_GetApplicationInfo_568611; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfo
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var path_568620 = newJObject()
  var query_568621 = newJObject()
  add(query_568621, "timeout", newJInt(timeout))
  add(query_568621, "api-version", newJString(apiVersion))
  add(path_568620, "applicationId", newJString(applicationId))
  add(query_568621, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_568619.call(path_568620, query_568621, nil, nil, nil)

var getApplicationInfo* = Call_GetApplicationInfo_568611(
    name: "getApplicationInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}",
    validator: validate_GetApplicationInfo_568612, base: "",
    url: url_GetApplicationInfo_568613, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteApplication_568622 = ref object of OpenApiRestCall_567667
proc url_DeleteApplication_568624(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteApplication_568623(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568625 = path.getOrDefault("applicationId")
  valid_568625 = validateParameter(valid_568625, JString, required = true,
                                 default = nil)
  if valid_568625 != nil:
    section.add "applicationId", valid_568625
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_568626 = query.getOrDefault("timeout")
  valid_568626 = validateParameter(valid_568626, JInt, required = false,
                                 default = newJInt(60))
  if valid_568626 != nil:
    section.add "timeout", valid_568626
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568627 = query.getOrDefault("api-version")
  valid_568627 = validateParameter(valid_568627, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568627 != nil:
    section.add "api-version", valid_568627
  var valid_568628 = query.getOrDefault("ForceRemove")
  valid_568628 = validateParameter(valid_568628, JBool, required = false, default = nil)
  if valid_568628 != nil:
    section.add "ForceRemove", valid_568628
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568629: Call_DeleteApplication_568622; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  let valid = call_568629.validator(path, query, header, formData, body)
  let scheme = call_568629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568629.url(scheme.get, call_568629.host, call_568629.base,
                         call_568629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568629, url, valid)

proc call*(call_568630: Call_DeleteApplication_568622; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## deleteApplication
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568631 = newJObject()
  var query_568632 = newJObject()
  add(query_568632, "timeout", newJInt(timeout))
  add(query_568632, "api-version", newJString(apiVersion))
  add(query_568632, "ForceRemove", newJBool(ForceRemove))
  add(path_568631, "applicationId", newJString(applicationId))
  result = call_568630.call(path_568631, query_568632, nil, nil, nil)

var deleteApplication* = Call_DeleteApplication_568622(name: "deleteApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/Delete",
    validator: validate_DeleteApplication_568623, base: "",
    url: url_DeleteApplication_568624, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealthUsingPolicy_568647 = ref object of OpenApiRestCall_567667
proc url_GetApplicationHealthUsingPolicy_568649(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealthUsingPolicy_568648(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568650 = path.getOrDefault("applicationId")
  valid_568650 = validateParameter(valid_568650, JString, required = true,
                                 default = nil)
  if valid_568650 != nil:
    section.add "applicationId", valid_568650
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_568651 = query.getOrDefault("timeout")
  valid_568651 = validateParameter(valid_568651, JInt, required = false,
                                 default = newJInt(60))
  if valid_568651 != nil:
    section.add "timeout", valid_568651
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568652 = query.getOrDefault("api-version")
  valid_568652 = validateParameter(valid_568652, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568652 != nil:
    section.add "api-version", valid_568652
  var valid_568653 = query.getOrDefault("ExcludeHealthStatistics")
  valid_568653 = validateParameter(valid_568653, JBool, required = false,
                                 default = newJBool(false))
  if valid_568653 != nil:
    section.add "ExcludeHealthStatistics", valid_568653
  var valid_568654 = query.getOrDefault("EventsHealthStateFilter")
  valid_568654 = validateParameter(valid_568654, JInt, required = false,
                                 default = newJInt(0))
  if valid_568654 != nil:
    section.add "EventsHealthStateFilter", valid_568654
  var valid_568655 = query.getOrDefault("ServicesHealthStateFilter")
  valid_568655 = validateParameter(valid_568655, JInt, required = false,
                                 default = newJInt(0))
  if valid_568655 != nil:
    section.add "ServicesHealthStateFilter", valid_568655
  var valid_568656 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_568656 = validateParameter(valid_568656, JInt, required = false,
                                 default = newJInt(0))
  if valid_568656 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_568656
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568658: Call_GetApplicationHealthUsingPolicy_568647;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  let valid = call_568658.validator(path, query, header, formData, body)
  let scheme = call_568658.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568658.url(scheme.get, call_568658.host, call_568658.base,
                         call_568658.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568658, url, valid)

proc call*(call_568659: Call_GetApplicationHealthUsingPolicy_568647;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          ServicesHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealthUsingPolicy
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_568660 = newJObject()
  var query_568661 = newJObject()
  var body_568662 = newJObject()
  add(query_568661, "timeout", newJInt(timeout))
  add(query_568661, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_568662 = ApplicationHealthPolicy
  add(query_568661, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_568661, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_568660, "applicationId", newJString(applicationId))
  add(query_568661, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_568661, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_568659.call(path_568660, query_568661, nil, nil, body_568662)

var getApplicationHealthUsingPolicy* = Call_GetApplicationHealthUsingPolicy_568647(
    name: "getApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealthUsingPolicy_568648, base: "",
    url: url_GetApplicationHealthUsingPolicy_568649,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealth_568633 = ref object of OpenApiRestCall_567667
proc url_GetApplicationHealth_568635(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealth_568634(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568636 = path.getOrDefault("applicationId")
  valid_568636 = validateParameter(valid_568636, JString, required = true,
                                 default = nil)
  if valid_568636 != nil:
    section.add "applicationId", valid_568636
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_568637 = query.getOrDefault("timeout")
  valid_568637 = validateParameter(valid_568637, JInt, required = false,
                                 default = newJInt(60))
  if valid_568637 != nil:
    section.add "timeout", valid_568637
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568638 = query.getOrDefault("api-version")
  valid_568638 = validateParameter(valid_568638, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568638 != nil:
    section.add "api-version", valid_568638
  var valid_568639 = query.getOrDefault("ExcludeHealthStatistics")
  valid_568639 = validateParameter(valid_568639, JBool, required = false,
                                 default = newJBool(false))
  if valid_568639 != nil:
    section.add "ExcludeHealthStatistics", valid_568639
  var valid_568640 = query.getOrDefault("EventsHealthStateFilter")
  valid_568640 = validateParameter(valid_568640, JInt, required = false,
                                 default = newJInt(0))
  if valid_568640 != nil:
    section.add "EventsHealthStateFilter", valid_568640
  var valid_568641 = query.getOrDefault("ServicesHealthStateFilter")
  valid_568641 = validateParameter(valid_568641, JInt, required = false,
                                 default = newJInt(0))
  if valid_568641 != nil:
    section.add "ServicesHealthStateFilter", valid_568641
  var valid_568642 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_568642 = validateParameter(valid_568642, JInt, required = false,
                                 default = newJInt(0))
  if valid_568642 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_568642
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568643: Call_GetApplicationHealth_568633; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  let valid = call_568643.validator(path, query, header, formData, body)
  let scheme = call_568643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568643.url(scheme.get, call_568643.host, call_568643.base,
                         call_568643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568643, url, valid)

proc call*(call_568644: Call_GetApplicationHealth_568633; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          ServicesHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealth
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_568645 = newJObject()
  var query_568646 = newJObject()
  add(query_568646, "timeout", newJInt(timeout))
  add(query_568646, "api-version", newJString(apiVersion))
  add(query_568646, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_568646, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_568645, "applicationId", newJString(applicationId))
  add(query_568646, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_568646, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_568644.call(path_568645, query_568646, nil, nil, nil)

var getApplicationHealth* = Call_GetApplicationHealth_568633(
    name: "getApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealth_568634, base: "",
    url: url_GetApplicationHealth_568635, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationLoadInfo_568663 = ref object of OpenApiRestCall_567667
proc url_GetApplicationLoadInfo_568665(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationLoadInfo_568664(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568666 = path.getOrDefault("applicationId")
  valid_568666 = validateParameter(valid_568666, JString, required = true,
                                 default = nil)
  if valid_568666 != nil:
    section.add "applicationId", valid_568666
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568667 = query.getOrDefault("timeout")
  valid_568667 = validateParameter(valid_568667, JInt, required = false,
                                 default = newJInt(60))
  if valid_568667 != nil:
    section.add "timeout", valid_568667
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568668 = query.getOrDefault("api-version")
  valid_568668 = validateParameter(valid_568668, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568668 != nil:
    section.add "api-version", valid_568668
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568669: Call_GetApplicationLoadInfo_568663; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  let valid = call_568669.validator(path, query, header, formData, body)
  let scheme = call_568669.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568669.url(scheme.get, call_568669.host, call_568669.base,
                         call_568669.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568669, url, valid)

proc call*(call_568670: Call_GetApplicationLoadInfo_568663; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationLoadInfo
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568671 = newJObject()
  var query_568672 = newJObject()
  add(query_568672, "timeout", newJInt(timeout))
  add(query_568672, "api-version", newJString(apiVersion))
  add(path_568671, "applicationId", newJString(applicationId))
  result = call_568670.call(path_568671, query_568672, nil, nil, nil)

var getApplicationLoadInfo* = Call_GetApplicationLoadInfo_568663(
    name: "getApplicationLoadInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetLoadInformation",
    validator: validate_GetApplicationLoadInfo_568664, base: "",
    url: url_GetApplicationLoadInfo_568665, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfoList_568673 = ref object of OpenApiRestCall_567667
proc url_GetServiceInfoList_568675(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfoList_568674(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568676 = path.getOrDefault("applicationId")
  valid_568676 = validateParameter(valid_568676, JString, required = true,
                                 default = nil)
  if valid_568676 != nil:
    section.add "applicationId", valid_568676
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: JString
  ##                  : The service type name used to filter the services to query for.
  section = newJObject()
  var valid_568677 = query.getOrDefault("timeout")
  valid_568677 = validateParameter(valid_568677, JInt, required = false,
                                 default = newJInt(60))
  if valid_568677 != nil:
    section.add "timeout", valid_568677
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568678 = query.getOrDefault("api-version")
  valid_568678 = validateParameter(valid_568678, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568678 != nil:
    section.add "api-version", valid_568678
  var valid_568679 = query.getOrDefault("ContinuationToken")
  valid_568679 = validateParameter(valid_568679, JString, required = false,
                                 default = nil)
  if valid_568679 != nil:
    section.add "ContinuationToken", valid_568679
  var valid_568680 = query.getOrDefault("ServiceTypeName")
  valid_568680 = validateParameter(valid_568680, JString, required = false,
                                 default = nil)
  if valid_568680 != nil:
    section.add "ServiceTypeName", valid_568680
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568681: Call_GetServiceInfoList_568673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  let valid = call_568681.validator(path, query, header, formData, body)
  let scheme = call_568681.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568681.url(scheme.get, call_568681.host, call_568681.base,
                         call_568681.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568681, url, valid)

proc call*(call_568682: Call_GetServiceInfoList_568673; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = "";
          ServiceTypeName: string = ""): Recallable =
  ## getServiceInfoList
  ## Returns the information about all services belonging to the application specified by the application id.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: string
  ##                  : The service type name used to filter the services to query for.
  var path_568683 = newJObject()
  var query_568684 = newJObject()
  add(query_568684, "timeout", newJInt(timeout))
  add(query_568684, "api-version", newJString(apiVersion))
  add(path_568683, "applicationId", newJString(applicationId))
  add(query_568684, "ContinuationToken", newJString(ContinuationToken))
  add(query_568684, "ServiceTypeName", newJString(ServiceTypeName))
  result = call_568682.call(path_568683, query_568684, nil, nil, nil)

var getServiceInfoList* = Call_GetServiceInfoList_568673(
    name: "getServiceInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices",
    validator: validate_GetServiceInfoList_568674, base: "",
    url: url_GetServiceInfoList_568675, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateService_568685 = ref object of OpenApiRestCall_567667
proc url_CreateService_568687(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/$/Create")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateService_568686(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568688 = path.getOrDefault("applicationId")
  valid_568688 = validateParameter(valid_568688, JString, required = true,
                                 default = nil)
  if valid_568688 != nil:
    section.add "applicationId", valid_568688
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568689 = query.getOrDefault("timeout")
  valid_568689 = validateParameter(valid_568689, JInt, required = false,
                                 default = newJInt(60))
  if valid_568689 != nil:
    section.add "timeout", valid_568689
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568690 = query.getOrDefault("api-version")
  valid_568690 = validateParameter(valid_568690, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568690 != nil:
    section.add "api-version", valid_568690
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568692: Call_CreateService_568685; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified service.
  ## 
  let valid = call_568692.validator(path, query, header, formData, body)
  let scheme = call_568692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568692.url(scheme.get, call_568692.host, call_568692.base,
                         call_568692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568692, url, valid)

proc call*(call_568693: Call_CreateService_568685; applicationId: string;
          ServiceDescription: JsonNode; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createService
  ## Creates the specified service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  var path_568694 = newJObject()
  var query_568695 = newJObject()
  var body_568696 = newJObject()
  add(query_568695, "timeout", newJInt(timeout))
  add(query_568695, "api-version", newJString(apiVersion))
  add(path_568694, "applicationId", newJString(applicationId))
  if ServiceDescription != nil:
    body_568696 = ServiceDescription
  result = call_568693.call(path_568694, query_568695, nil, nil, body_568696)

var createService* = Call_CreateService_568685(name: "createService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/Create",
    validator: validate_CreateService_568686, base: "", url: url_CreateService_568687,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateServiceFromTemplate_568697 = ref object of OpenApiRestCall_567667
proc url_CreateServiceFromTemplate_568699(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"), (
        kind: ConstantSegment, value: "/$/GetServices/$/CreateFromTemplate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateServiceFromTemplate_568698(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568700 = path.getOrDefault("applicationId")
  valid_568700 = validateParameter(valid_568700, JString, required = true,
                                 default = nil)
  if valid_568700 != nil:
    section.add "applicationId", valid_568700
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568701 = query.getOrDefault("timeout")
  valid_568701 = validateParameter(valid_568701, JInt, required = false,
                                 default = newJInt(60))
  if valid_568701 != nil:
    section.add "timeout", valid_568701
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568702 = query.getOrDefault("api-version")
  valid_568702 = validateParameter(valid_568702, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568702 != nil:
    section.add "api-version", valid_568702
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568704: Call_CreateServiceFromTemplate_568697; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  let valid = call_568704.validator(path, query, header, formData, body)
  let scheme = call_568704.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568704.url(scheme.get, call_568704.host, call_568704.base,
                         call_568704.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568704, url, valid)

proc call*(call_568705: Call_CreateServiceFromTemplate_568697;
          ServiceFromTemplateDescription: JsonNode; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createServiceFromTemplate
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568706 = newJObject()
  var query_568707 = newJObject()
  var body_568708 = newJObject()
  add(query_568707, "timeout", newJInt(timeout))
  add(query_568707, "api-version", newJString(apiVersion))
  if ServiceFromTemplateDescription != nil:
    body_568708 = ServiceFromTemplateDescription
  add(path_568706, "applicationId", newJString(applicationId))
  result = call_568705.call(path_568706, query_568707, nil, nil, body_568708)

var createServiceFromTemplate* = Call_CreateServiceFromTemplate_568697(
    name: "createServiceFromTemplate", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/CreateFromTemplate",
    validator: validate_CreateServiceFromTemplate_568698, base: "",
    url: url_CreateServiceFromTemplate_568699,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfo_568709 = ref object of OpenApiRestCall_567667
proc url_GetServiceInfo_568711(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/"),
               (kind: VariableSegment, value: "serviceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfo_568710(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568712 = path.getOrDefault("applicationId")
  valid_568712 = validateParameter(valid_568712, JString, required = true,
                                 default = nil)
  if valid_568712 != nil:
    section.add "applicationId", valid_568712
  var valid_568713 = path.getOrDefault("serviceId")
  valid_568713 = validateParameter(valid_568713, JString, required = true,
                                 default = nil)
  if valid_568713 != nil:
    section.add "serviceId", valid_568713
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568714 = query.getOrDefault("timeout")
  valid_568714 = validateParameter(valid_568714, JInt, required = false,
                                 default = newJInt(60))
  if valid_568714 != nil:
    section.add "timeout", valid_568714
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568715 = query.getOrDefault("api-version")
  valid_568715 = validateParameter(valid_568715, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568715 != nil:
    section.add "api-version", valid_568715
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568716: Call_GetServiceInfo_568709; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  let valid = call_568716.validator(path, query, header, formData, body)
  let scheme = call_568716.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568716.url(scheme.get, call_568716.host, call_568716.base,
                         call_568716.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568716, url, valid)

proc call*(call_568717: Call_GetServiceInfo_568709; applicationId: string;
          serviceId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceInfo
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_568718 = newJObject()
  var query_568719 = newJObject()
  add(query_568719, "timeout", newJInt(timeout))
  add(query_568719, "api-version", newJString(apiVersion))
  add(path_568718, "applicationId", newJString(applicationId))
  add(path_568718, "serviceId", newJString(serviceId))
  result = call_568717.call(path_568718, query_568719, nil, nil, nil)

var getServiceInfo* = Call_GetServiceInfo_568709(name: "getServiceInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/{serviceId}",
    validator: validate_GetServiceInfo_568710, base: "", url: url_GetServiceInfo_568711,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationUpgrade_568720 = ref object of OpenApiRestCall_567667
proc url_GetApplicationUpgrade_568722(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationUpgrade_568721(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568723 = path.getOrDefault("applicationId")
  valid_568723 = validateParameter(valid_568723, JString, required = true,
                                 default = nil)
  if valid_568723 != nil:
    section.add "applicationId", valid_568723
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568724 = query.getOrDefault("timeout")
  valid_568724 = validateParameter(valid_568724, JInt, required = false,
                                 default = newJInt(60))
  if valid_568724 != nil:
    section.add "timeout", valid_568724
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568725 = query.getOrDefault("api-version")
  valid_568725 = validateParameter(valid_568725, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568725 != nil:
    section.add "api-version", valid_568725
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568726: Call_GetApplicationUpgrade_568720; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_568726.validator(path, query, header, formData, body)
  let scheme = call_568726.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568726.url(scheme.get, call_568726.host, call_568726.base,
                         call_568726.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568726, url, valid)

proc call*(call_568727: Call_GetApplicationUpgrade_568720; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationUpgrade
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568728 = newJObject()
  var query_568729 = newJObject()
  add(query_568729, "timeout", newJInt(timeout))
  add(query_568729, "api-version", newJString(apiVersion))
  add(path_568728, "applicationId", newJString(applicationId))
  result = call_568727.call(path_568728, query_568729, nil, nil, nil)

var getApplicationUpgrade* = Call_GetApplicationUpgrade_568720(
    name: "getApplicationUpgrade", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetUpgradeProgress",
    validator: validate_GetApplicationUpgrade_568721, base: "",
    url: url_GetApplicationUpgrade_568722, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeApplicationUpgrade_568730 = ref object of OpenApiRestCall_567667
proc url_ResumeApplicationUpgrade_568732(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/MoveToNextUpgradeDomain")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResumeApplicationUpgrade_568731(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568733 = path.getOrDefault("applicationId")
  valid_568733 = validateParameter(valid_568733, JString, required = true,
                                 default = nil)
  if valid_568733 != nil:
    section.add "applicationId", valid_568733
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568734 = query.getOrDefault("timeout")
  valid_568734 = validateParameter(valid_568734, JInt, required = false,
                                 default = newJInt(60))
  if valid_568734 != nil:
    section.add "timeout", valid_568734
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568735 = query.getOrDefault("api-version")
  valid_568735 = validateParameter(valid_568735, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568735 != nil:
    section.add "api-version", valid_568735
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568737: Call_ResumeApplicationUpgrade_568730; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  let valid = call_568737.validator(path, query, header, formData, body)
  let scheme = call_568737.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568737.url(scheme.get, call_568737.host, call_568737.base,
                         call_568737.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568737, url, valid)

proc call*(call_568738: Call_ResumeApplicationUpgrade_568730;
          ResumeApplicationUpgradeDescription: JsonNode; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## resumeApplicationUpgrade
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568739 = newJObject()
  var query_568740 = newJObject()
  var body_568741 = newJObject()
  add(query_568740, "timeout", newJInt(timeout))
  if ResumeApplicationUpgradeDescription != nil:
    body_568741 = ResumeApplicationUpgradeDescription
  add(query_568740, "api-version", newJString(apiVersion))
  add(path_568739, "applicationId", newJString(applicationId))
  result = call_568738.call(path_568739, query_568740, nil, nil, body_568741)

var resumeApplicationUpgrade* = Call_ResumeApplicationUpgrade_568730(
    name: "resumeApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeApplicationUpgrade_568731, base: "",
    url: url_ResumeApplicationUpgrade_568732, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportApplicationHealth_568742 = ref object of OpenApiRestCall_567667
proc url_ReportApplicationHealth_568744(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportApplicationHealth_568743(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568745 = path.getOrDefault("applicationId")
  valid_568745 = validateParameter(valid_568745, JString, required = true,
                                 default = nil)
  if valid_568745 != nil:
    section.add "applicationId", valid_568745
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568746 = query.getOrDefault("Immediate")
  valid_568746 = validateParameter(valid_568746, JBool, required = false,
                                 default = newJBool(false))
  if valid_568746 != nil:
    section.add "Immediate", valid_568746
  var valid_568747 = query.getOrDefault("timeout")
  valid_568747 = validateParameter(valid_568747, JInt, required = false,
                                 default = newJInt(60))
  if valid_568747 != nil:
    section.add "timeout", valid_568747
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568748 = query.getOrDefault("api-version")
  valid_568748 = validateParameter(valid_568748, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568748 != nil:
    section.add "api-version", valid_568748
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568750: Call_ReportApplicationHealth_568742; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_568750.validator(path, query, header, formData, body)
  let scheme = call_568750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568750.url(scheme.get, call_568750.host, call_568750.base,
                         call_568750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568750, url, valid)

proc call*(call_568751: Call_ReportApplicationHealth_568742;
          HealthInformation: JsonNode; applicationId: string;
          Immediate: bool = false; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportApplicationHealth
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568752 = newJObject()
  var query_568753 = newJObject()
  var body_568754 = newJObject()
  add(query_568753, "Immediate", newJBool(Immediate))
  add(query_568753, "timeout", newJInt(timeout))
  add(query_568753, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_568754 = HealthInformation
  add(path_568752, "applicationId", newJString(applicationId))
  result = call_568751.call(path_568752, query_568753, nil, nil, body_568754)

var reportApplicationHealth* = Call_ReportApplicationHealth_568742(
    name: "reportApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/ReportHealth",
    validator: validate_ReportApplicationHealth_568743, base: "",
    url: url_ReportApplicationHealth_568744, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackApplicationUpgrade_568755 = ref object of OpenApiRestCall_567667
proc url_RollbackApplicationUpgrade_568757(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/RollbackUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RollbackApplicationUpgrade_568756(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568758 = path.getOrDefault("applicationId")
  valid_568758 = validateParameter(valid_568758, JString, required = true,
                                 default = nil)
  if valid_568758 != nil:
    section.add "applicationId", valid_568758
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568759 = query.getOrDefault("timeout")
  valid_568759 = validateParameter(valid_568759, JInt, required = false,
                                 default = newJInt(60))
  if valid_568759 != nil:
    section.add "timeout", valid_568759
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568760 = query.getOrDefault("api-version")
  valid_568760 = validateParameter(valid_568760, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568760 != nil:
    section.add "api-version", valid_568760
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568761: Call_RollbackApplicationUpgrade_568755; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  let valid = call_568761.validator(path, query, header, formData, body)
  let scheme = call_568761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568761.url(scheme.get, call_568761.host, call_568761.base,
                         call_568761.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568761, url, valid)

proc call*(call_568762: Call_RollbackApplicationUpgrade_568755;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## rollbackApplicationUpgrade
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_568763 = newJObject()
  var query_568764 = newJObject()
  add(query_568764, "timeout", newJInt(timeout))
  add(query_568764, "api-version", newJString(apiVersion))
  add(path_568763, "applicationId", newJString(applicationId))
  result = call_568762.call(path_568763, query_568764, nil, nil, nil)

var rollbackApplicationUpgrade* = Call_RollbackApplicationUpgrade_568755(
    name: "rollbackApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/RollbackUpgrade",
    validator: validate_RollbackApplicationUpgrade_568756, base: "",
    url: url_RollbackApplicationUpgrade_568757,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateApplicationUpgrade_568765 = ref object of OpenApiRestCall_567667
proc url_UpdateApplicationUpgrade_568767(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/UpdateUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateApplicationUpgrade_568766(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568768 = path.getOrDefault("applicationId")
  valid_568768 = validateParameter(valid_568768, JString, required = true,
                                 default = nil)
  if valid_568768 != nil:
    section.add "applicationId", valid_568768
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568769 = query.getOrDefault("timeout")
  valid_568769 = validateParameter(valid_568769, JInt, required = false,
                                 default = newJInt(60))
  if valid_568769 != nil:
    section.add "timeout", valid_568769
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568770 = query.getOrDefault("api-version")
  valid_568770 = validateParameter(valid_568770, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568770 != nil:
    section.add "api-version", valid_568770
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568772: Call_UpdateApplicationUpgrade_568765; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  let valid = call_568772.validator(path, query, header, formData, body)
  let scheme = call_568772.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568772.url(scheme.get, call_568772.host, call_568772.base,
                         call_568772.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568772, url, valid)

proc call*(call_568773: Call_UpdateApplicationUpgrade_568765;
          applicationId: string; ApplicationUpgradeUpdateDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## updateApplicationUpgrade
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  var path_568774 = newJObject()
  var query_568775 = newJObject()
  var body_568776 = newJObject()
  add(query_568775, "timeout", newJInt(timeout))
  add(query_568775, "api-version", newJString(apiVersion))
  add(path_568774, "applicationId", newJString(applicationId))
  if ApplicationUpgradeUpdateDescription != nil:
    body_568776 = ApplicationUpgradeUpdateDescription
  result = call_568773.call(path_568774, query_568775, nil, nil, body_568776)

var updateApplicationUpgrade* = Call_UpdateApplicationUpgrade_568765(
    name: "updateApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/UpdateUpgrade",
    validator: validate_UpdateApplicationUpgrade_568766, base: "",
    url: url_UpdateApplicationUpgrade_568767, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartApplicationUpgrade_568777 = ref object of OpenApiRestCall_567667
proc url_StartApplicationUpgrade_568779(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartApplicationUpgrade_568778(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_568780 = path.getOrDefault("applicationId")
  valid_568780 = validateParameter(valid_568780, JString, required = true,
                                 default = nil)
  if valid_568780 != nil:
    section.add "applicationId", valid_568780
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568781 = query.getOrDefault("timeout")
  valid_568781 = validateParameter(valid_568781, JInt, required = false,
                                 default = newJInt(60))
  if valid_568781 != nil:
    section.add "timeout", valid_568781
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568782 = query.getOrDefault("api-version")
  valid_568782 = validateParameter(valid_568782, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568782 != nil:
    section.add "api-version", valid_568782
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568784: Call_StartApplicationUpgrade_568777; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  let valid = call_568784.validator(path, query, header, formData, body)
  let scheme = call_568784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568784.url(scheme.get, call_568784.host, call_568784.base,
                         call_568784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568784, url, valid)

proc call*(call_568785: Call_StartApplicationUpgrade_568777; applicationId: string;
          ApplicationUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startApplicationUpgrade
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  var path_568786 = newJObject()
  var query_568787 = newJObject()
  var body_568788 = newJObject()
  add(query_568787, "timeout", newJInt(timeout))
  add(query_568787, "api-version", newJString(apiVersion))
  add(path_568786, "applicationId", newJString(applicationId))
  if ApplicationUpgradeDescription != nil:
    body_568788 = ApplicationUpgradeDescription
  result = call_568785.call(path_568786, query_568787, nil, nil, body_568788)

var startApplicationUpgrade* = Call_StartApplicationUpgrade_568777(
    name: "startApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/Upgrade",
    validator: validate_StartApplicationUpgrade_568778, base: "",
    url: url_StartApplicationUpgrade_568779, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatusList_568789 = ref object of OpenApiRestCall_567667
proc url_GetComposeDeploymentStatusList_568791(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetComposeDeploymentStatusList_568790(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  section = newJObject()
  var valid_568792 = query.getOrDefault("timeout")
  valid_568792 = validateParameter(valid_568792, JInt, required = false,
                                 default = newJInt(60))
  if valid_568792 != nil:
    section.add "timeout", valid_568792
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568793 = query.getOrDefault("api-version")
  valid_568793 = validateParameter(valid_568793, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568793 != nil:
    section.add "api-version", valid_568793
  var valid_568794 = query.getOrDefault("ContinuationToken")
  valid_568794 = validateParameter(valid_568794, JString, required = false,
                                 default = nil)
  if valid_568794 != nil:
    section.add "ContinuationToken", valid_568794
  var valid_568795 = query.getOrDefault("MaxResults")
  valid_568795 = validateParameter(valid_568795, JInt, required = false,
                                 default = newJInt(0))
  if valid_568795 != nil:
    section.add "MaxResults", valid_568795
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568796: Call_GetComposeDeploymentStatusList_568789; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  let valid = call_568796.validator(path, query, header, formData, body)
  let scheme = call_568796.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568796.url(scheme.get, call_568796.host, call_568796.base,
                         call_568796.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568796, url, valid)

proc call*(call_568797: Call_GetComposeDeploymentStatusList_568789;
          timeout: int = 60; apiVersion: string = "6.0-preview";
          ContinuationToken: string = ""; MaxResults: int = 0): Recallable =
  ## getComposeDeploymentStatusList
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  var query_568798 = newJObject()
  add(query_568798, "timeout", newJInt(timeout))
  add(query_568798, "api-version", newJString(apiVersion))
  add(query_568798, "ContinuationToken", newJString(ContinuationToken))
  add(query_568798, "MaxResults", newJInt(MaxResults))
  result = call_568797.call(nil, query_568798, nil, nil, nil)

var getComposeDeploymentStatusList* = Call_GetComposeDeploymentStatusList_568789(
    name: "getComposeDeploymentStatusList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments",
    validator: validate_GetComposeDeploymentStatusList_568790, base: "",
    url: url_GetComposeDeploymentStatusList_568791,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateComposeDeployment_568799 = ref object of OpenApiRestCall_567667
proc url_CreateComposeDeployment_568801(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateComposeDeployment_568800(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_568802 = query.getOrDefault("timeout")
  valid_568802 = validateParameter(valid_568802, JInt, required = false,
                                 default = newJInt(60))
  if valid_568802 != nil:
    section.add "timeout", valid_568802
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568803 = query.getOrDefault("api-version")
  valid_568803 = validateParameter(valid_568803, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568803 != nil:
    section.add "api-version", valid_568803
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568805: Call_CreateComposeDeployment_568799; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric compose deployment.
  ## 
  let valid = call_568805.validator(path, query, header, formData, body)
  let scheme = call_568805.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568805.url(scheme.get, call_568805.host, call_568805.base,
                         call_568805.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568805, url, valid)

proc call*(call_568806: Call_CreateComposeDeployment_568799;
          CreateComposeDeploymentDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## createComposeDeployment
  ## Creates a Service Fabric compose deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  var query_568807 = newJObject()
  var body_568808 = newJObject()
  add(query_568807, "timeout", newJInt(timeout))
  add(query_568807, "api-version", newJString(apiVersion))
  if CreateComposeDeploymentDescription != nil:
    body_568808 = CreateComposeDeploymentDescription
  result = call_568806.call(nil, query_568807, nil, nil, body_568808)

var createComposeDeployment* = Call_CreateComposeDeployment_568799(
    name: "createComposeDeployment", meth: HttpMethod.HttpPut,
    host: "azure.local:19080", route: "/ComposeDeployments/$/Create",
    validator: validate_CreateComposeDeployment_568800, base: "",
    url: url_CreateComposeDeployment_568801, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatus_568809 = ref object of OpenApiRestCall_567667
proc url_GetComposeDeploymentStatus_568811(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentStatus_568810(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_568812 = path.getOrDefault("deploymentName")
  valid_568812 = validateParameter(valid_568812, JString, required = true,
                                 default = nil)
  if valid_568812 != nil:
    section.add "deploymentName", valid_568812
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_568813 = query.getOrDefault("timeout")
  valid_568813 = validateParameter(valid_568813, JInt, required = false,
                                 default = newJInt(60))
  if valid_568813 != nil:
    section.add "timeout", valid_568813
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568814 = query.getOrDefault("api-version")
  valid_568814 = validateParameter(valid_568814, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568814 != nil:
    section.add "api-version", valid_568814
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568815: Call_GetComposeDeploymentStatus_568809; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  let valid = call_568815.validator(path, query, header, formData, body)
  let scheme = call_568815.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568815.url(scheme.get, call_568815.host, call_568815.base,
                         call_568815.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568815, url, valid)

proc call*(call_568816: Call_GetComposeDeploymentStatus_568809;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## getComposeDeploymentStatus
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_568817 = newJObject()
  var query_568818 = newJObject()
  add(query_568818, "timeout", newJInt(timeout))
  add(query_568818, "api-version", newJString(apiVersion))
  add(path_568817, "deploymentName", newJString(deploymentName))
  result = call_568816.call(path_568817, query_568818, nil, nil, nil)

var getComposeDeploymentStatus* = Call_GetComposeDeploymentStatus_568809(
    name: "getComposeDeploymentStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments/{deploymentName}",
    validator: validate_GetComposeDeploymentStatus_568810, base: "",
    url: url_GetComposeDeploymentStatus_568811,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveComposeDeployment_568819 = ref object of OpenApiRestCall_567667
proc url_RemoveComposeDeployment_568821(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveComposeDeployment_568820(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_568822 = path.getOrDefault("deploymentName")
  valid_568822 = validateParameter(valid_568822, JString, required = true,
                                 default = nil)
  if valid_568822 != nil:
    section.add "deploymentName", valid_568822
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_568823 = query.getOrDefault("timeout")
  valid_568823 = validateParameter(valid_568823, JInt, required = false,
                                 default = newJInt(60))
  if valid_568823 != nil:
    section.add "timeout", valid_568823
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568824 = query.getOrDefault("api-version")
  valid_568824 = validateParameter(valid_568824, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568824 != nil:
    section.add "api-version", valid_568824
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568825: Call_RemoveComposeDeployment_568819; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  let valid = call_568825.validator(path, query, header, formData, body)
  let scheme = call_568825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568825.url(scheme.get, call_568825.host, call_568825.base,
                         call_568825.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568825, url, valid)

proc call*(call_568826: Call_RemoveComposeDeployment_568819;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## removeComposeDeployment
  ## Deletes an existing Service Fabric compose deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_568827 = newJObject()
  var query_568828 = newJObject()
  add(query_568828, "timeout", newJInt(timeout))
  add(query_568828, "api-version", newJString(apiVersion))
  add(path_568827, "deploymentName", newJString(deploymentName))
  result = call_568826.call(path_568827, query_568828, nil, nil, nil)

var removeComposeDeployment* = Call_RemoveComposeDeployment_568819(
    name: "removeComposeDeployment", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Delete",
    validator: validate_RemoveComposeDeployment_568820, base: "",
    url: url_RemoveComposeDeployment_568821, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentUpgradeProgress_568829 = ref object of OpenApiRestCall_567667
proc url_GetComposeDeploymentUpgradeProgress_568831(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentUpgradeProgress_568830(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_568832 = path.getOrDefault("deploymentName")
  valid_568832 = validateParameter(valid_568832, JString, required = true,
                                 default = nil)
  if valid_568832 != nil:
    section.add "deploymentName", valid_568832
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_568833 = query.getOrDefault("timeout")
  valid_568833 = validateParameter(valid_568833, JInt, required = false,
                                 default = newJInt(60))
  if valid_568833 != nil:
    section.add "timeout", valid_568833
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568834 = query.getOrDefault("api-version")
  valid_568834 = validateParameter(valid_568834, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568834 != nil:
    section.add "api-version", valid_568834
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568835: Call_GetComposeDeploymentUpgradeProgress_568829;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_568835.validator(path, query, header, formData, body)
  let scheme = call_568835.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568835.url(scheme.get, call_568835.host, call_568835.base,
                         call_568835.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568835, url, valid)

proc call*(call_568836: Call_GetComposeDeploymentUpgradeProgress_568829;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## getComposeDeploymentUpgradeProgress
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_568837 = newJObject()
  var query_568838 = newJObject()
  add(query_568838, "timeout", newJInt(timeout))
  add(query_568838, "api-version", newJString(apiVersion))
  add(path_568837, "deploymentName", newJString(deploymentName))
  result = call_568836.call(path_568837, query_568838, nil, nil, nil)

var getComposeDeploymentUpgradeProgress* = Call_GetComposeDeploymentUpgradeProgress_568829(
    name: "getComposeDeploymentUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/GetUpgradeProgress",
    validator: validate_GetComposeDeploymentUpgradeProgress_568830, base: "",
    url: url_GetComposeDeploymentUpgradeProgress_568831,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartComposeDeploymentUpgrade_568839 = ref object of OpenApiRestCall_567667
proc url_StartComposeDeploymentUpgrade_568841(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartComposeDeploymentUpgrade_568840(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_568842 = path.getOrDefault("deploymentName")
  valid_568842 = validateParameter(valid_568842, JString, required = true,
                                 default = nil)
  if valid_568842 != nil:
    section.add "deploymentName", valid_568842
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_568843 = query.getOrDefault("timeout")
  valid_568843 = validateParameter(valid_568843, JInt, required = false,
                                 default = newJInt(60))
  if valid_568843 != nil:
    section.add "timeout", valid_568843
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568844 = query.getOrDefault("api-version")
  valid_568844 = validateParameter(valid_568844, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_568844 != nil:
    section.add "api-version", valid_568844
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568846: Call_StartComposeDeploymentUpgrade_568839; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  let valid = call_568846.validator(path, query, header, formData, body)
  let scheme = call_568846.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568846.url(scheme.get, call_568846.host, call_568846.base,
                         call_568846.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568846, url, valid)

proc call*(call_568847: Call_StartComposeDeploymentUpgrade_568839;
          deploymentName: string; ComposeDeploymentUpgradeDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0-preview"): Recallable =
  ## startComposeDeploymentUpgrade
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  var path_568848 = newJObject()
  var query_568849 = newJObject()
  var body_568850 = newJObject()
  add(query_568849, "timeout", newJInt(timeout))
  add(query_568849, "api-version", newJString(apiVersion))
  add(path_568848, "deploymentName", newJString(deploymentName))
  if ComposeDeploymentUpgradeDescription != nil:
    body_568850 = ComposeDeploymentUpgradeDescription
  result = call_568847.call(path_568848, query_568849, nil, nil, body_568850)

var startComposeDeploymentUpgrade* = Call_StartComposeDeploymentUpgrade_568839(
    name: "startComposeDeploymentUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Upgrade",
    validator: validate_StartComposeDeploymentUpgrade_568840, base: "",
    url: url_StartComposeDeploymentUpgrade_568841,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetFaultOperationList_568851 = ref object of OpenApiRestCall_567667
proc url_GetFaultOperationList_568853(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetFaultOperationList_568852(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TypeFilter: JInt (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: JInt (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  section = newJObject()
  var valid_568854 = query.getOrDefault("timeout")
  valid_568854 = validateParameter(valid_568854, JInt, required = false,
                                 default = newJInt(60))
  if valid_568854 != nil:
    section.add "timeout", valid_568854
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568855 = query.getOrDefault("api-version")
  valid_568855 = validateParameter(valid_568855, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568855 != nil:
    section.add "api-version", valid_568855
  var valid_568856 = query.getOrDefault("TypeFilter")
  valid_568856 = validateParameter(valid_568856, JInt, required = true,
                                 default = newJInt(65535))
  if valid_568856 != nil:
    section.add "TypeFilter", valid_568856
  var valid_568857 = query.getOrDefault("StateFilter")
  valid_568857 = validateParameter(valid_568857, JInt, required = true,
                                 default = newJInt(65535))
  if valid_568857 != nil:
    section.add "StateFilter", valid_568857
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568858: Call_GetFaultOperationList_568851; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  let valid = call_568858.validator(path, query, header, formData, body)
  let scheme = call_568858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568858.url(scheme.get, call_568858.host, call_568858.base,
                         call_568858.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568858, url, valid)

proc call*(call_568859: Call_GetFaultOperationList_568851; timeout: int = 60;
          apiVersion: string = "6.0"; TypeFilter: int = 65535; StateFilter: int = 65535): Recallable =
  ## getFaultOperationList
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TypeFilter: int (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: int (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  var query_568860 = newJObject()
  add(query_568860, "timeout", newJInt(timeout))
  add(query_568860, "api-version", newJString(apiVersion))
  add(query_568860, "TypeFilter", newJInt(TypeFilter))
  add(query_568860, "StateFilter", newJInt(StateFilter))
  result = call_568859.call(nil, query_568860, nil, nil, nil)

var getFaultOperationList* = Call_GetFaultOperationList_568851(
    name: "getFaultOperationList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/",
    validator: validate_GetFaultOperationList_568852, base: "",
    url: url_GetFaultOperationList_568853, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelOperation_568861 = ref object of OpenApiRestCall_567667
proc url_CancelOperation_568863(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelOperation_568862(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   Force: JBool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  section = newJObject()
  var valid_568864 = query.getOrDefault("timeout")
  valid_568864 = validateParameter(valid_568864, JInt, required = false,
                                 default = newJInt(60))
  if valid_568864 != nil:
    section.add "timeout", valid_568864
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568865 = query.getOrDefault("api-version")
  valid_568865 = validateParameter(valid_568865, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568865 != nil:
    section.add "api-version", valid_568865
  var valid_568866 = query.getOrDefault("OperationId")
  valid_568866 = validateParameter(valid_568866, JString, required = true,
                                 default = nil)
  if valid_568866 != nil:
    section.add "OperationId", valid_568866
  var valid_568867 = query.getOrDefault("Force")
  valid_568867 = validateParameter(valid_568867, JBool, required = true,
                                 default = newJBool(false))
  if valid_568867 != nil:
    section.add "Force", valid_568867
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568868: Call_CancelOperation_568861; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  let valid = call_568868.validator(path, query, header, formData, body)
  let scheme = call_568868.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568868.url(scheme.get, call_568868.host, call_568868.base,
                         call_568868.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568868, url, valid)

proc call*(call_568869: Call_CancelOperation_568861; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; Force: bool = false): Recallable =
  ## cancelOperation
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   Force: bool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  var query_568870 = newJObject()
  add(query_568870, "timeout", newJInt(timeout))
  add(query_568870, "api-version", newJString(apiVersion))
  add(query_568870, "OperationId", newJString(OperationId))
  add(query_568870, "Force", newJBool(Force))
  result = call_568869.call(nil, query_568870, nil, nil, nil)

var cancelOperation* = Call_CancelOperation_568861(name: "cancelOperation",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/$/Cancel",
    validator: validate_CancelOperation_568862, base: "", url: url_CancelOperation_568863,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeTransitionProgress_568871 = ref object of OpenApiRestCall_567667
proc url_GetNodeTransitionProgress_568873(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetTransitionProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeTransitionProgress_568872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_568874 = path.getOrDefault("nodeName")
  valid_568874 = validateParameter(valid_568874, JString, required = true,
                                 default = nil)
  if valid_568874 != nil:
    section.add "nodeName", valid_568874
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568875 = query.getOrDefault("timeout")
  valid_568875 = validateParameter(valid_568875, JInt, required = false,
                                 default = newJInt(60))
  if valid_568875 != nil:
    section.add "timeout", valid_568875
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568876 = query.getOrDefault("api-version")
  valid_568876 = validateParameter(valid_568876, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568876 != nil:
    section.add "api-version", valid_568876
  var valid_568877 = query.getOrDefault("OperationId")
  valid_568877 = validateParameter(valid_568877, JString, required = true,
                                 default = nil)
  if valid_568877 != nil:
    section.add "OperationId", valid_568877
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568878: Call_GetNodeTransitionProgress_568871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  let valid = call_568878.validator(path, query, header, formData, body)
  let scheme = call_568878.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568878.url(scheme.get, call_568878.host, call_568878.base,
                         call_568878.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568878, url, valid)

proc call*(call_568879: Call_GetNodeTransitionProgress_568871; nodeName: string;
          OperationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNodeTransitionProgress
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568880 = newJObject()
  var query_568881 = newJObject()
  add(query_568881, "timeout", newJInt(timeout))
  add(query_568881, "api-version", newJString(apiVersion))
  add(path_568880, "nodeName", newJString(nodeName))
  add(query_568881, "OperationId", newJString(OperationId))
  result = call_568879.call(path_568880, query_568881, nil, nil, nil)

var getNodeTransitionProgress* = Call_GetNodeTransitionProgress_568871(
    name: "getNodeTransitionProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/GetTransitionProgress",
    validator: validate_GetNodeTransitionProgress_568872, base: "",
    url: url_GetNodeTransitionProgress_568873,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartNodeTransition_568882 = ref object of OpenApiRestCall_567667
proc url_StartNodeTransition_568884(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/StartTransition/")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartNodeTransition_568883(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_568885 = path.getOrDefault("nodeName")
  valid_568885 = validateParameter(valid_568885, JString, required = true,
                                 default = nil)
  if valid_568885 != nil:
    section.add "nodeName", valid_568885
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeInstanceId: JString (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   StopDurationInSeconds: JInt (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   NodeTransitionType: JString (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568886 = query.getOrDefault("timeout")
  valid_568886 = validateParameter(valid_568886, JInt, required = false,
                                 default = newJInt(60))
  if valid_568886 != nil:
    section.add "timeout", valid_568886
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568887 = query.getOrDefault("api-version")
  valid_568887 = validateParameter(valid_568887, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568887 != nil:
    section.add "api-version", valid_568887
  var valid_568888 = query.getOrDefault("NodeInstanceId")
  valid_568888 = validateParameter(valid_568888, JString, required = true,
                                 default = nil)
  if valid_568888 != nil:
    section.add "NodeInstanceId", valid_568888
  var valid_568889 = query.getOrDefault("StopDurationInSeconds")
  valid_568889 = validateParameter(valid_568889, JInt, required = true, default = nil)
  if valid_568889 != nil:
    section.add "StopDurationInSeconds", valid_568889
  var valid_568890 = query.getOrDefault("NodeTransitionType")
  valid_568890 = validateParameter(valid_568890, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_568890 != nil:
    section.add "NodeTransitionType", valid_568890
  var valid_568891 = query.getOrDefault("OperationId")
  valid_568891 = validateParameter(valid_568891, JString, required = true,
                                 default = nil)
  if valid_568891 != nil:
    section.add "OperationId", valid_568891
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568892: Call_StartNodeTransition_568882; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  let valid = call_568892.validator(path, query, header, formData, body)
  let scheme = call_568892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568892.url(scheme.get, call_568892.host, call_568892.base,
                         call_568892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568892, url, valid)

proc call*(call_568893: Call_StartNodeTransition_568882; nodeName: string;
          NodeInstanceId: string; StopDurationInSeconds: int; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          NodeTransitionType: string = "Invalid"): Recallable =
  ## startNodeTransition
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   NodeInstanceId: string (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   StopDurationInSeconds: int (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   NodeTransitionType: string (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568894 = newJObject()
  var query_568895 = newJObject()
  add(query_568895, "timeout", newJInt(timeout))
  add(query_568895, "api-version", newJString(apiVersion))
  add(path_568894, "nodeName", newJString(nodeName))
  add(query_568895, "NodeInstanceId", newJString(NodeInstanceId))
  add(query_568895, "StopDurationInSeconds", newJInt(StopDurationInSeconds))
  add(query_568895, "NodeTransitionType", newJString(NodeTransitionType))
  add(query_568895, "OperationId", newJString(OperationId))
  result = call_568893.call(path_568894, query_568895, nil, nil, nil)

var startNodeTransition* = Call_StartNodeTransition_568882(
    name: "startNodeTransition", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/StartTransition/",
    validator: validate_StartNodeTransition_568883, base: "",
    url: url_StartNodeTransition_568884, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDataLossProgress_568896 = ref object of OpenApiRestCall_567667
proc url_GetDataLossProgress_568898(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetDataLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDataLossProgress_568897(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568899 = path.getOrDefault("partitionId")
  valid_568899 = validateParameter(valid_568899, JString, required = true,
                                 default = nil)
  if valid_568899 != nil:
    section.add "partitionId", valid_568899
  var valid_568900 = path.getOrDefault("serviceId")
  valid_568900 = validateParameter(valid_568900, JString, required = true,
                                 default = nil)
  if valid_568900 != nil:
    section.add "serviceId", valid_568900
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568901 = query.getOrDefault("timeout")
  valid_568901 = validateParameter(valid_568901, JInt, required = false,
                                 default = newJInt(60))
  if valid_568901 != nil:
    section.add "timeout", valid_568901
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568902 = query.getOrDefault("api-version")
  valid_568902 = validateParameter(valid_568902, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568902 != nil:
    section.add "api-version", valid_568902
  var valid_568903 = query.getOrDefault("OperationId")
  valid_568903 = validateParameter(valid_568903, JString, required = true,
                                 default = nil)
  if valid_568903 != nil:
    section.add "OperationId", valid_568903
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568904: Call_GetDataLossProgress_568896; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  let valid = call_568904.validator(path, query, header, formData, body)
  let scheme = call_568904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568904.url(scheme.get, call_568904.host, call_568904.base,
                         call_568904.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568904, url, valid)

proc call*(call_568905: Call_GetDataLossProgress_568896; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDataLossProgress
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568906 = newJObject()
  var query_568907 = newJObject()
  add(query_568907, "timeout", newJInt(timeout))
  add(query_568907, "api-version", newJString(apiVersion))
  add(path_568906, "partitionId", newJString(partitionId))
  add(path_568906, "serviceId", newJString(serviceId))
  add(query_568907, "OperationId", newJString(OperationId))
  result = call_568905.call(path_568906, query_568907, nil, nil, nil)

var getDataLossProgress* = Call_GetDataLossProgress_568896(
    name: "getDataLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress",
    validator: validate_GetDataLossProgress_568897, base: "",
    url: url_GetDataLossProgress_568898, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetQuorumLossProgress_568908 = ref object of OpenApiRestCall_567667
proc url_GetQuorumLossProgress_568910(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetQuorumLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetQuorumLossProgress_568909(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568911 = path.getOrDefault("partitionId")
  valid_568911 = validateParameter(valid_568911, JString, required = true,
                                 default = nil)
  if valid_568911 != nil:
    section.add "partitionId", valid_568911
  var valid_568912 = path.getOrDefault("serviceId")
  valid_568912 = validateParameter(valid_568912, JString, required = true,
                                 default = nil)
  if valid_568912 != nil:
    section.add "serviceId", valid_568912
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568913 = query.getOrDefault("timeout")
  valid_568913 = validateParameter(valid_568913, JInt, required = false,
                                 default = newJInt(60))
  if valid_568913 != nil:
    section.add "timeout", valid_568913
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568914 = query.getOrDefault("api-version")
  valid_568914 = validateParameter(valid_568914, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568914 != nil:
    section.add "api-version", valid_568914
  var valid_568915 = query.getOrDefault("OperationId")
  valid_568915 = validateParameter(valid_568915, JString, required = true,
                                 default = nil)
  if valid_568915 != nil:
    section.add "OperationId", valid_568915
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568916: Call_GetQuorumLossProgress_568908; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  let valid = call_568916.validator(path, query, header, formData, body)
  let scheme = call_568916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568916.url(scheme.get, call_568916.host, call_568916.base,
                         call_568916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568916, url, valid)

proc call*(call_568917: Call_GetQuorumLossProgress_568908; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getQuorumLossProgress
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568918 = newJObject()
  var query_568919 = newJObject()
  add(query_568919, "timeout", newJInt(timeout))
  add(query_568919, "api-version", newJString(apiVersion))
  add(path_568918, "partitionId", newJString(partitionId))
  add(path_568918, "serviceId", newJString(serviceId))
  add(query_568919, "OperationId", newJString(OperationId))
  result = call_568917.call(path_568918, query_568919, nil, nil, nil)

var getQuorumLossProgress* = Call_GetQuorumLossProgress_568908(
    name: "getQuorumLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress",
    validator: validate_GetQuorumLossProgress_568909, base: "",
    url: url_GetQuorumLossProgress_568910, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionRestartProgress_568920 = ref object of OpenApiRestCall_567667
proc url_GetPartitionRestartProgress_568922(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetRestartProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionRestartProgress_568921(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568923 = path.getOrDefault("partitionId")
  valid_568923 = validateParameter(valid_568923, JString, required = true,
                                 default = nil)
  if valid_568923 != nil:
    section.add "partitionId", valid_568923
  var valid_568924 = path.getOrDefault("serviceId")
  valid_568924 = validateParameter(valid_568924, JString, required = true,
                                 default = nil)
  if valid_568924 != nil:
    section.add "serviceId", valid_568924
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568925 = query.getOrDefault("timeout")
  valid_568925 = validateParameter(valid_568925, JInt, required = false,
                                 default = newJInt(60))
  if valid_568925 != nil:
    section.add "timeout", valid_568925
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568926 = query.getOrDefault("api-version")
  valid_568926 = validateParameter(valid_568926, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568926 != nil:
    section.add "api-version", valid_568926
  var valid_568927 = query.getOrDefault("OperationId")
  valid_568927 = validateParameter(valid_568927, JString, required = true,
                                 default = nil)
  if valid_568927 != nil:
    section.add "OperationId", valid_568927
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568928: Call_GetPartitionRestartProgress_568920; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  let valid = call_568928.validator(path, query, header, formData, body)
  let scheme = call_568928.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568928.url(scheme.get, call_568928.host, call_568928.base,
                         call_568928.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568928, url, valid)

proc call*(call_568929: Call_GetPartitionRestartProgress_568920;
          partitionId: string; serviceId: string; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionRestartProgress
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568930 = newJObject()
  var query_568931 = newJObject()
  add(query_568931, "timeout", newJInt(timeout))
  add(query_568931, "api-version", newJString(apiVersion))
  add(path_568930, "partitionId", newJString(partitionId))
  add(path_568930, "serviceId", newJString(serviceId))
  add(query_568931, "OperationId", newJString(OperationId))
  result = call_568929.call(path_568930, query_568931, nil, nil, nil)

var getPartitionRestartProgress* = Call_GetPartitionRestartProgress_568920(
    name: "getPartitionRestartProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress",
    validator: validate_GetPartitionRestartProgress_568921, base: "",
    url: url_GetPartitionRestartProgress_568922,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartDataLoss_568932 = ref object of OpenApiRestCall_567667
proc url_StartDataLoss_568934(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartDataLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartDataLoss_568933(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568935 = path.getOrDefault("partitionId")
  valid_568935 = validateParameter(valid_568935, JString, required = true,
                                 default = nil)
  if valid_568935 != nil:
    section.add "partitionId", valid_568935
  var valid_568936 = path.getOrDefault("serviceId")
  valid_568936 = validateParameter(valid_568936, JString, required = true,
                                 default = nil)
  if valid_568936 != nil:
    section.add "serviceId", valid_568936
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DataLossMode: JString (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568937 = query.getOrDefault("timeout")
  valid_568937 = validateParameter(valid_568937, JInt, required = false,
                                 default = newJInt(60))
  if valid_568937 != nil:
    section.add "timeout", valid_568937
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568938 = query.getOrDefault("api-version")
  valid_568938 = validateParameter(valid_568938, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568938 != nil:
    section.add "api-version", valid_568938
  var valid_568939 = query.getOrDefault("DataLossMode")
  valid_568939 = validateParameter(valid_568939, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_568939 != nil:
    section.add "DataLossMode", valid_568939
  var valid_568940 = query.getOrDefault("OperationId")
  valid_568940 = validateParameter(valid_568940, JString, required = true,
                                 default = nil)
  if valid_568940 != nil:
    section.add "OperationId", valid_568940
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568941: Call_StartDataLoss_568932; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  let valid = call_568941.validator(path, query, header, formData, body)
  let scheme = call_568941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568941.url(scheme.get, call_568941.host, call_568941.base,
                         call_568941.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568941, url, valid)

proc call*(call_568942: Call_StartDataLoss_568932; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; DataLossMode: string = "Invalid"): Recallable =
  ## startDataLoss
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   DataLossMode: string (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568943 = newJObject()
  var query_568944 = newJObject()
  add(query_568944, "timeout", newJInt(timeout))
  add(query_568944, "api-version", newJString(apiVersion))
  add(path_568943, "partitionId", newJString(partitionId))
  add(query_568944, "DataLossMode", newJString(DataLossMode))
  add(path_568943, "serviceId", newJString(serviceId))
  add(query_568944, "OperationId", newJString(OperationId))
  result = call_568942.call(path_568943, query_568944, nil, nil, nil)

var startDataLoss* = Call_StartDataLoss_568932(name: "startDataLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss",
    validator: validate_StartDataLoss_568933, base: "", url: url_StartDataLoss_568934,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartQuorumLoss_568945 = ref object of OpenApiRestCall_567667
proc url_StartQuorumLoss_568947(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartQuorumLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartQuorumLoss_568946(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568948 = path.getOrDefault("partitionId")
  valid_568948 = validateParameter(valid_568948, JString, required = true,
                                 default = nil)
  if valid_568948 != nil:
    section.add "partitionId", valid_568948
  var valid_568949 = path.getOrDefault("serviceId")
  valid_568949 = validateParameter(valid_568949, JString, required = true,
                                 default = nil)
  if valid_568949 != nil:
    section.add "serviceId", valid_568949
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   QuorumLossMode: JString (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   QuorumLossDuration: JInt (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568950 = query.getOrDefault("timeout")
  valid_568950 = validateParameter(valid_568950, JInt, required = false,
                                 default = newJInt(60))
  if valid_568950 != nil:
    section.add "timeout", valid_568950
  assert query != nil,
        "query argument is necessary due to required `QuorumLossMode` field"
  var valid_568951 = query.getOrDefault("QuorumLossMode")
  valid_568951 = validateParameter(valid_568951, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_568951 != nil:
    section.add "QuorumLossMode", valid_568951
  var valid_568952 = query.getOrDefault("api-version")
  valid_568952 = validateParameter(valid_568952, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568952 != nil:
    section.add "api-version", valid_568952
  var valid_568953 = query.getOrDefault("QuorumLossDuration")
  valid_568953 = validateParameter(valid_568953, JInt, required = true, default = nil)
  if valid_568953 != nil:
    section.add "QuorumLossDuration", valid_568953
  var valid_568954 = query.getOrDefault("OperationId")
  valid_568954 = validateParameter(valid_568954, JString, required = true,
                                 default = nil)
  if valid_568954 != nil:
    section.add "OperationId", valid_568954
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568955: Call_StartQuorumLoss_568945; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  let valid = call_568955.validator(path, query, header, formData, body)
  let scheme = call_568955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568955.url(scheme.get, call_568955.host, call_568955.base,
                         call_568955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568955, url, valid)

proc call*(call_568956: Call_StartQuorumLoss_568945; partitionId: string;
          QuorumLossDuration: int; serviceId: string; OperationId: string;
          timeout: int = 60; QuorumLossMode: string = "Invalid";
          apiVersion: string = "6.0"): Recallable =
  ## startQuorumLoss
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   QuorumLossMode: string (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   QuorumLossDuration: int (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568957 = newJObject()
  var query_568958 = newJObject()
  add(query_568958, "timeout", newJInt(timeout))
  add(query_568958, "QuorumLossMode", newJString(QuorumLossMode))
  add(query_568958, "api-version", newJString(apiVersion))
  add(path_568957, "partitionId", newJString(partitionId))
  add(query_568958, "QuorumLossDuration", newJInt(QuorumLossDuration))
  add(path_568957, "serviceId", newJString(serviceId))
  add(query_568958, "OperationId", newJString(OperationId))
  result = call_568956.call(path_568957, query_568958, nil, nil, nil)

var startQuorumLoss* = Call_StartQuorumLoss_568945(name: "startQuorumLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss",
    validator: validate_StartQuorumLoss_568946, base: "", url: url_StartQuorumLoss_568947,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartPartitionRestart_568959 = ref object of OpenApiRestCall_567667
proc url_StartPartitionRestart_568961(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartRestart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartPartitionRestart_568960(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_568962 = path.getOrDefault("partitionId")
  valid_568962 = validateParameter(valid_568962, JString, required = true,
                                 default = nil)
  if valid_568962 != nil:
    section.add "partitionId", valid_568962
  var valid_568963 = path.getOrDefault("serviceId")
  valid_568963 = validateParameter(valid_568963, JString, required = true,
                                 default = nil)
  if valid_568963 != nil:
    section.add "serviceId", valid_568963
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: JString (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_568964 = query.getOrDefault("timeout")
  valid_568964 = validateParameter(valid_568964, JInt, required = false,
                                 default = newJInt(60))
  if valid_568964 != nil:
    section.add "timeout", valid_568964
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568965 = query.getOrDefault("api-version")
  valid_568965 = validateParameter(valid_568965, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568965 != nil:
    section.add "api-version", valid_568965
  var valid_568966 = query.getOrDefault("RestartPartitionMode")
  valid_568966 = validateParameter(valid_568966, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_568966 != nil:
    section.add "RestartPartitionMode", valid_568966
  var valid_568967 = query.getOrDefault("OperationId")
  valid_568967 = validateParameter(valid_568967, JString, required = true,
                                 default = nil)
  if valid_568967 != nil:
    section.add "OperationId", valid_568967
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568968: Call_StartPartitionRestart_568959; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  let valid = call_568968.validator(path, query, header, formData, body)
  let scheme = call_568968.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568968.url(scheme.get, call_568968.host, call_568968.base,
                         call_568968.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568968, url, valid)

proc call*(call_568969: Call_StartPartitionRestart_568959; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; RestartPartitionMode: string = "Invalid"): Recallable =
  ## startPartitionRestart
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: string (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_568970 = newJObject()
  var query_568971 = newJObject()
  add(query_568971, "timeout", newJInt(timeout))
  add(query_568971, "api-version", newJString(apiVersion))
  add(query_568971, "RestartPartitionMode", newJString(RestartPartitionMode))
  add(path_568970, "partitionId", newJString(partitionId))
  add(path_568970, "serviceId", newJString(serviceId))
  add(query_568971, "OperationId", newJString(OperationId))
  result = call_568969.call(path_568970, query_568971, nil, nil, nil)

var startPartitionRestart* = Call_StartPartitionRestart_568959(
    name: "startPartitionRestart", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart",
    validator: validate_StartPartitionRestart_568960, base: "",
    url: url_StartPartitionRestart_568961, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreRootContent_568972 = ref object of OpenApiRestCall_567667
proc url_GetImageStoreRootContent_568974(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetImageStoreRootContent_568973(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568975 = query.getOrDefault("timeout")
  valid_568975 = validateParameter(valid_568975, JInt, required = false,
                                 default = newJInt(60))
  if valid_568975 != nil:
    section.add "timeout", valid_568975
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568976 = query.getOrDefault("api-version")
  valid_568976 = validateParameter(valid_568976, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568976 != nil:
    section.add "api-version", valid_568976
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568977: Call_GetImageStoreRootContent_568972; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  let valid = call_568977.validator(path, query, header, formData, body)
  let scheme = call_568977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568977.url(scheme.get, call_568977.host, call_568977.base,
                         call_568977.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568977, url, valid)

proc call*(call_568978: Call_GetImageStoreRootContent_568972; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getImageStoreRootContent
  ## Returns the information about the image store content at the root of the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_568979 = newJObject()
  add(query_568979, "timeout", newJInt(timeout))
  add(query_568979, "api-version", newJString(apiVersion))
  result = call_568978.call(nil, query_568979, nil, nil, nil)

var getImageStoreRootContent* = Call_GetImageStoreRootContent_568972(
    name: "getImageStoreRootContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore",
    validator: validate_GetImageStoreRootContent_568973, base: "",
    url: url_GetImageStoreRootContent_568974, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CopyImageStoreContent_568980 = ref object of OpenApiRestCall_567667
proc url_CopyImageStoreContent_568982(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CopyImageStoreContent_568981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568983 = query.getOrDefault("timeout")
  valid_568983 = validateParameter(valid_568983, JInt, required = false,
                                 default = newJInt(60))
  if valid_568983 != nil:
    section.add "timeout", valid_568983
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568984 = query.getOrDefault("api-version")
  valid_568984 = validateParameter(valid_568984, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568984 != nil:
    section.add "api-version", valid_568984
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_568986: Call_CopyImageStoreContent_568980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  let valid = call_568986.validator(path, query, header, formData, body)
  let scheme = call_568986.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568986.url(scheme.get, call_568986.host, call_568986.base,
                         call_568986.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568986, url, valid)

proc call*(call_568987: Call_CopyImageStoreContent_568980;
          ImageStoreCopyDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## copyImageStoreContent
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  var query_568988 = newJObject()
  var body_568989 = newJObject()
  add(query_568988, "timeout", newJInt(timeout))
  add(query_568988, "api-version", newJString(apiVersion))
  if ImageStoreCopyDescription != nil:
    body_568989 = ImageStoreCopyDescription
  result = call_568987.call(nil, query_568988, nil, nil, body_568989)

var copyImageStoreContent* = Call_CopyImageStoreContent_568980(
    name: "copyImageStoreContent", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ImageStore/$/Copy",
    validator: validate_CopyImageStoreContent_568981, base: "",
    url: url_CopyImageStoreContent_568982, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UploadFile_569000 = ref object of OpenApiRestCall_567667
proc url_UploadFile_569002(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UploadFile_569001(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_569003 = path.getOrDefault("contentPath")
  valid_569003 = validateParameter(valid_569003, JString, required = true,
                                 default = nil)
  if valid_569003 != nil:
    section.add "contentPath", valid_569003
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569004 = query.getOrDefault("timeout")
  valid_569004 = validateParameter(valid_569004, JInt, required = false,
                                 default = newJInt(60))
  if valid_569004 != nil:
    section.add "timeout", valid_569004
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569005 = query.getOrDefault("api-version")
  valid_569005 = validateParameter(valid_569005, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569005 != nil:
    section.add "api-version", valid_569005
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569006: Call_UploadFile_569000; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  let valid = call_569006.validator(path, query, header, formData, body)
  let scheme = call_569006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569006.url(scheme.get, call_569006.host, call_569006.base,
                         call_569006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569006, url, valid)

proc call*(call_569007: Call_UploadFile_569000; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## uploadFile
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_569008 = newJObject()
  var query_569009 = newJObject()
  add(query_569009, "timeout", newJInt(timeout))
  add(query_569009, "api-version", newJString(apiVersion))
  add(path_569008, "contentPath", newJString(contentPath))
  result = call_569007.call(path_569008, query_569009, nil, nil, nil)

var uploadFile* = Call_UploadFile_569000(name: "uploadFile",
                                      meth: HttpMethod.HttpPut,
                                      host: "azure.local:19080",
                                      route: "/ImageStore/{contentPath}",
                                      validator: validate_UploadFile_569001,
                                      base: "", url: url_UploadFile_569002,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreContent_568990 = ref object of OpenApiRestCall_567667
proc url_GetImageStoreContent_568992(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetImageStoreContent_568991(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_568993 = path.getOrDefault("contentPath")
  valid_568993 = validateParameter(valid_568993, JString, required = true,
                                 default = nil)
  if valid_568993 != nil:
    section.add "contentPath", valid_568993
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_568994 = query.getOrDefault("timeout")
  valid_568994 = validateParameter(valid_568994, JInt, required = false,
                                 default = newJInt(60))
  if valid_568994 != nil:
    section.add "timeout", valid_568994
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_568995 = query.getOrDefault("api-version")
  valid_568995 = validateParameter(valid_568995, JString, required = true,
                                 default = newJString("6.0"))
  if valid_568995 != nil:
    section.add "api-version", valid_568995
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_568996: Call_GetImageStoreContent_568990; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  let valid = call_568996.validator(path, query, header, formData, body)
  let scheme = call_568996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_568996.url(scheme.get, call_568996.host, call_568996.base,
                         call_568996.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_568996, url, valid)

proc call*(call_568997: Call_GetImageStoreContent_568990; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getImageStoreContent
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_568998 = newJObject()
  var query_568999 = newJObject()
  add(query_568999, "timeout", newJInt(timeout))
  add(query_568999, "api-version", newJString(apiVersion))
  add(path_568998, "contentPath", newJString(contentPath))
  result = call_568997.call(path_568998, query_568999, nil, nil, nil)

var getImageStoreContent* = Call_GetImageStoreContent_568990(
    name: "getImageStoreContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_GetImageStoreContent_568991, base: "",
    url: url_GetImageStoreContent_568992, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteImageStoreContent_569010 = ref object of OpenApiRestCall_567667
proc url_DeleteImageStoreContent_569012(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteImageStoreContent_569011(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_569013 = path.getOrDefault("contentPath")
  valid_569013 = validateParameter(valid_569013, JString, required = true,
                                 default = nil)
  if valid_569013 != nil:
    section.add "contentPath", valid_569013
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569014 = query.getOrDefault("timeout")
  valid_569014 = validateParameter(valid_569014, JInt, required = false,
                                 default = newJInt(60))
  if valid_569014 != nil:
    section.add "timeout", valid_569014
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569015 = query.getOrDefault("api-version")
  valid_569015 = validateParameter(valid_569015, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569015 != nil:
    section.add "api-version", valid_569015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569016: Call_DeleteImageStoreContent_569010; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  let valid = call_569016.validator(path, query, header, formData, body)
  let scheme = call_569016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569016.url(scheme.get, call_569016.host, call_569016.base,
                         call_569016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569016, url, valid)

proc call*(call_569017: Call_DeleteImageStoreContent_569010; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## deleteImageStoreContent
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_569018 = newJObject()
  var query_569019 = newJObject()
  add(query_569019, "timeout", newJInt(timeout))
  add(query_569019, "api-version", newJString(apiVersion))
  add(path_569018, "contentPath", newJString(contentPath))
  result = call_569017.call(path_569018, query_569019, nil, nil, nil)

var deleteImageStoreContent* = Call_DeleteImageStoreContent_569010(
    name: "deleteImageStoreContent", meth: HttpMethod.HttpDelete,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_DeleteImageStoreContent_569011, base: "",
    url: url_DeleteImageStoreContent_569012, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateName_569020 = ref object of OpenApiRestCall_567667
proc url_CreateName_569022(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateName_569021(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified Service Fabric name.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569023 = query.getOrDefault("timeout")
  valid_569023 = validateParameter(valid_569023, JInt, required = false,
                                 default = newJInt(60))
  if valid_569023 != nil:
    section.add "timeout", valid_569023
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569024 = query.getOrDefault("api-version")
  valid_569024 = validateParameter(valid_569024, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569024 != nil:
    section.add "api-version", valid_569024
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569026: Call_CreateName_569020; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified Service Fabric name.
  ## 
  let valid = call_569026.validator(path, query, header, formData, body)
  let scheme = call_569026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569026.url(scheme.get, call_569026.host, call_569026.base,
                         call_569026.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569026, url, valid)

proc call*(call_569027: Call_CreateName_569020; NameDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createName
  ## Creates the specified Service Fabric name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  var query_569028 = newJObject()
  var body_569029 = newJObject()
  add(query_569028, "timeout", newJInt(timeout))
  add(query_569028, "api-version", newJString(apiVersion))
  if NameDescription != nil:
    body_569029 = NameDescription
  result = call_569027.call(nil, query_569028, nil, nil, body_569029)

var createName* = Call_CreateName_569020(name: "createName",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Names/$/Create",
                                      validator: validate_CreateName_569021,
                                      base: "", url: url_CreateName_569022,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNameExistsInfo_569030 = ref object of OpenApiRestCall_567667
proc url_GetNameExistsInfo_569032(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNameExistsInfo_569031(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569033 = path.getOrDefault("nameId")
  valid_569033 = validateParameter(valid_569033, JString, required = true,
                                 default = nil)
  if valid_569033 != nil:
    section.add "nameId", valid_569033
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569034 = query.getOrDefault("timeout")
  valid_569034 = validateParameter(valid_569034, JInt, required = false,
                                 default = newJInt(60))
  if valid_569034 != nil:
    section.add "timeout", valid_569034
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569035 = query.getOrDefault("api-version")
  valid_569035 = validateParameter(valid_569035, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569035 != nil:
    section.add "api-version", valid_569035
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569036: Call_GetNameExistsInfo_569030; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  let valid = call_569036.validator(path, query, header, formData, body)
  let scheme = call_569036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569036.url(scheme.get, call_569036.host, call_569036.base,
                         call_569036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569036, url, valid)

proc call*(call_569037: Call_GetNameExistsInfo_569030; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNameExistsInfo
  ## Returns whether the specified Service Fabric name exists.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_569038 = newJObject()
  var query_569039 = newJObject()
  add(query_569039, "timeout", newJInt(timeout))
  add(query_569039, "api-version", newJString(apiVersion))
  add(path_569038, "nameId", newJString(nameId))
  result = call_569037.call(path_569038, query_569039, nil, nil, nil)

var getNameExistsInfo* = Call_GetNameExistsInfo_569030(name: "getNameExistsInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Names/{nameId}",
    validator: validate_GetNameExistsInfo_569031, base: "",
    url: url_GetNameExistsInfo_569032, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteName_569040 = ref object of OpenApiRestCall_567667
proc url_DeleteName_569042(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteName_569041(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569043 = path.getOrDefault("nameId")
  valid_569043 = validateParameter(valid_569043, JString, required = true,
                                 default = nil)
  if valid_569043 != nil:
    section.add "nameId", valid_569043
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569044 = query.getOrDefault("timeout")
  valid_569044 = validateParameter(valid_569044, JInt, required = false,
                                 default = newJInt(60))
  if valid_569044 != nil:
    section.add "timeout", valid_569044
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569045 = query.getOrDefault("api-version")
  valid_569045 = validateParameter(valid_569045, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569045 != nil:
    section.add "api-version", valid_569045
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569046: Call_DeleteName_569040; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  let valid = call_569046.validator(path, query, header, formData, body)
  let scheme = call_569046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569046.url(scheme.get, call_569046.host, call_569046.base,
                         call_569046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569046, url, valid)

proc call*(call_569047: Call_DeleteName_569040; nameId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## deleteName
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_569048 = newJObject()
  var query_569049 = newJObject()
  add(query_569049, "timeout", newJInt(timeout))
  add(query_569049, "api-version", newJString(apiVersion))
  add(path_569048, "nameId", newJString(nameId))
  result = call_569047.call(path_569048, query_569049, nil, nil, nil)

var deleteName* = Call_DeleteName_569040(name: "deleteName",
                                      meth: HttpMethod.HttpDelete,
                                      host: "azure.local:19080",
                                      route: "/Names/{nameId}",
                                      validator: validate_DeleteName_569041,
                                      base: "", url: url_DeleteName_569042,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfoList_569050 = ref object of OpenApiRestCall_567667
proc url_GetPropertyInfoList_569052(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfoList_569051(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569053 = path.getOrDefault("nameId")
  valid_569053 = validateParameter(valid_569053, JString, required = true,
                                 default = nil)
  if valid_569053 != nil:
    section.add "nameId", valid_569053
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   IncludeValues: JBool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  section = newJObject()
  var valid_569054 = query.getOrDefault("timeout")
  valid_569054 = validateParameter(valid_569054, JInt, required = false,
                                 default = newJInt(60))
  if valid_569054 != nil:
    section.add "timeout", valid_569054
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569055 = query.getOrDefault("api-version")
  valid_569055 = validateParameter(valid_569055, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569055 != nil:
    section.add "api-version", valid_569055
  var valid_569056 = query.getOrDefault("ContinuationToken")
  valid_569056 = validateParameter(valid_569056, JString, required = false,
                                 default = nil)
  if valid_569056 != nil:
    section.add "ContinuationToken", valid_569056
  var valid_569057 = query.getOrDefault("IncludeValues")
  valid_569057 = validateParameter(valid_569057, JBool, required = false,
                                 default = newJBool(false))
  if valid_569057 != nil:
    section.add "IncludeValues", valid_569057
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569058: Call_GetPropertyInfoList_569050; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  let valid = call_569058.validator(path, query, header, formData, body)
  let scheme = call_569058.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569058.url(scheme.get, call_569058.host, call_569058.base,
                         call_569058.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569058, url, valid)

proc call*(call_569059: Call_GetPropertyInfoList_569050; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = "";
          IncludeValues: bool = false): Recallable =
  ## getPropertyInfoList
  ## Gets information on all Service Fabric properties under a given name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   IncludeValues: bool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  var path_569060 = newJObject()
  var query_569061 = newJObject()
  add(query_569061, "timeout", newJInt(timeout))
  add(query_569061, "api-version", newJString(apiVersion))
  add(path_569060, "nameId", newJString(nameId))
  add(query_569061, "ContinuationToken", newJString(ContinuationToken))
  add(query_569061, "IncludeValues", newJBool(IncludeValues))
  result = call_569059.call(path_569060, query_569061, nil, nil, nil)

var getPropertyInfoList* = Call_GetPropertyInfoList_569050(
    name: "getPropertyInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Names/{nameId}/$/GetProperties",
    validator: validate_GetPropertyInfoList_569051, base: "",
    url: url_GetPropertyInfoList_569052, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SubmitPropertyBatch_569062 = ref object of OpenApiRestCall_567667
proc url_SubmitPropertyBatch_569064(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties/$/SubmitBatch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_SubmitPropertyBatch_569063(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569065 = path.getOrDefault("nameId")
  valid_569065 = validateParameter(valid_569065, JString, required = true,
                                 default = nil)
  if valid_569065 != nil:
    section.add "nameId", valid_569065
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569066 = query.getOrDefault("timeout")
  valid_569066 = validateParameter(valid_569066, JInt, required = false,
                                 default = newJInt(60))
  if valid_569066 != nil:
    section.add "timeout", valid_569066
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569067 = query.getOrDefault("api-version")
  valid_569067 = validateParameter(valid_569067, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569067 != nil:
    section.add "api-version", valid_569067
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569069: Call_SubmitPropertyBatch_569062; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  let valid = call_569069.validator(path, query, header, formData, body)
  let scheme = call_569069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569069.url(scheme.get, call_569069.host, call_569069.base,
                         call_569069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569069, url, valid)

proc call*(call_569070: Call_SubmitPropertyBatch_569062; nameId: string;
          PropertyBatchDescriptionList: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## submitPropertyBatch
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  var path_569071 = newJObject()
  var query_569072 = newJObject()
  var body_569073 = newJObject()
  add(query_569072, "timeout", newJInt(timeout))
  add(query_569072, "api-version", newJString(apiVersion))
  add(path_569071, "nameId", newJString(nameId))
  if PropertyBatchDescriptionList != nil:
    body_569073 = PropertyBatchDescriptionList
  result = call_569070.call(path_569071, query_569072, nil, nil, body_569073)

var submitPropertyBatch* = Call_SubmitPropertyBatch_569062(
    name: "submitPropertyBatch", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperties/$/SubmitBatch",
    validator: validate_SubmitPropertyBatch_569063, base: "",
    url: url_SubmitPropertyBatch_569064, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PutProperty_569085 = ref object of OpenApiRestCall_567667
proc url_PutProperty_569087(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_PutProperty_569086(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569088 = path.getOrDefault("nameId")
  valid_569088 = validateParameter(valid_569088, JString, required = true,
                                 default = nil)
  if valid_569088 != nil:
    section.add "nameId", valid_569088
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569089 = query.getOrDefault("timeout")
  valid_569089 = validateParameter(valid_569089, JInt, required = false,
                                 default = newJInt(60))
  if valid_569089 != nil:
    section.add "timeout", valid_569089
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569090 = query.getOrDefault("api-version")
  valid_569090 = validateParameter(valid_569090, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569090 != nil:
    section.add "api-version", valid_569090
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569092: Call_PutProperty_569085; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  let valid = call_569092.validator(path, query, header, formData, body)
  let scheme = call_569092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569092.url(scheme.get, call_569092.host, call_569092.base,
                         call_569092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569092, url, valid)

proc call*(call_569093: Call_PutProperty_569085; nameId: string;
          PropertyDescription: JsonNode; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## putProperty
  ## Creates or updates the specified Service Fabric property under a given name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  var path_569094 = newJObject()
  var query_569095 = newJObject()
  var body_569096 = newJObject()
  add(query_569095, "timeout", newJInt(timeout))
  add(query_569095, "api-version", newJString(apiVersion))
  add(path_569094, "nameId", newJString(nameId))
  if PropertyDescription != nil:
    body_569096 = PropertyDescription
  result = call_569093.call(path_569094, query_569095, nil, nil, body_569096)

var putProperty* = Call_PutProperty_569085(name: "putProperty",
                                        meth: HttpMethod.HttpPut,
                                        host: "azure.local:19080",
                                        route: "/Names/{nameId}/$/GetProperty",
                                        validator: validate_PutProperty_569086,
                                        base: "", url: url_PutProperty_569087,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfo_569074 = ref object of OpenApiRestCall_567667
proc url_GetPropertyInfo_569076(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfo_569075(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569077 = path.getOrDefault("nameId")
  valid_569077 = validateParameter(valid_569077, JString, required = true,
                                 default = nil)
  if valid_569077 != nil:
    section.add "nameId", valid_569077
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  var valid_569078 = query.getOrDefault("timeout")
  valid_569078 = validateParameter(valid_569078, JInt, required = false,
                                 default = newJInt(60))
  if valid_569078 != nil:
    section.add "timeout", valid_569078
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569079 = query.getOrDefault("api-version")
  valid_569079 = validateParameter(valid_569079, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569079 != nil:
    section.add "api-version", valid_569079
  var valid_569080 = query.getOrDefault("PropertyName")
  valid_569080 = validateParameter(valid_569080, JString, required = true,
                                 default = nil)
  if valid_569080 != nil:
    section.add "PropertyName", valid_569080
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569081: Call_GetPropertyInfo_569074; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  let valid = call_569081.validator(path, query, header, formData, body)
  let scheme = call_569081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569081.url(scheme.get, call_569081.host, call_569081.base,
                         call_569081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569081, url, valid)

proc call*(call_569082: Call_GetPropertyInfo_569074; nameId: string;
          PropertyName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPropertyInfo
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  var path_569083 = newJObject()
  var query_569084 = newJObject()
  add(query_569084, "timeout", newJInt(timeout))
  add(query_569084, "api-version", newJString(apiVersion))
  add(path_569083, "nameId", newJString(nameId))
  add(query_569084, "PropertyName", newJString(PropertyName))
  result = call_569082.call(path_569083, query_569084, nil, nil, nil)

var getPropertyInfo* = Call_GetPropertyInfo_569074(name: "getPropertyInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_GetPropertyInfo_569075,
    base: "", url: url_GetPropertyInfo_569076, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProperty_569097 = ref object of OpenApiRestCall_567667
proc url_DeleteProperty_569099(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteProperty_569098(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569100 = path.getOrDefault("nameId")
  valid_569100 = validateParameter(valid_569100, JString, required = true,
                                 default = nil)
  if valid_569100 != nil:
    section.add "nameId", valid_569100
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  var valid_569101 = query.getOrDefault("timeout")
  valid_569101 = validateParameter(valid_569101, JInt, required = false,
                                 default = newJInt(60))
  if valid_569101 != nil:
    section.add "timeout", valid_569101
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569102 = query.getOrDefault("api-version")
  valid_569102 = validateParameter(valid_569102, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569102 != nil:
    section.add "api-version", valid_569102
  var valid_569103 = query.getOrDefault("PropertyName")
  valid_569103 = validateParameter(valid_569103, JString, required = true,
                                 default = nil)
  if valid_569103 != nil:
    section.add "PropertyName", valid_569103
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569104: Call_DeleteProperty_569097; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  let valid = call_569104.validator(path, query, header, formData, body)
  let scheme = call_569104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569104.url(scheme.get, call_569104.host, call_569104.base,
                         call_569104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569104, url, valid)

proc call*(call_569105: Call_DeleteProperty_569097; nameId: string;
          PropertyName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## deleteProperty
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  var path_569106 = newJObject()
  var query_569107 = newJObject()
  add(query_569107, "timeout", newJInt(timeout))
  add(query_569107, "api-version", newJString(apiVersion))
  add(path_569106, "nameId", newJString(nameId))
  add(query_569107, "PropertyName", newJString(PropertyName))
  result = call_569105.call(path_569106, query_569107, nil, nil, nil)

var deleteProperty* = Call_DeleteProperty_569097(name: "deleteProperty",
    meth: HttpMethod.HttpDelete, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_DeleteProperty_569098,
    base: "", url: url_DeleteProperty_569099, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetSubNameInfoList_569108 = ref object of OpenApiRestCall_567667
proc url_GetSubNameInfoList_569110(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetSubNames")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetSubNameInfoList_569109(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_569111 = path.getOrDefault("nameId")
  valid_569111 = validateParameter(valid_569111, JString, required = true,
                                 default = nil)
  if valid_569111 != nil:
    section.add "nameId", valid_569111
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Recursive: JBool
  ##            : Allows specifying that the search performed should be recursive.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_569112 = query.getOrDefault("timeout")
  valid_569112 = validateParameter(valid_569112, JInt, required = false,
                                 default = newJInt(60))
  if valid_569112 != nil:
    section.add "timeout", valid_569112
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569113 = query.getOrDefault("api-version")
  valid_569113 = validateParameter(valid_569113, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569113 != nil:
    section.add "api-version", valid_569113
  var valid_569114 = query.getOrDefault("Recursive")
  valid_569114 = validateParameter(valid_569114, JBool, required = false,
                                 default = newJBool(false))
  if valid_569114 != nil:
    section.add "Recursive", valid_569114
  var valid_569115 = query.getOrDefault("ContinuationToken")
  valid_569115 = validateParameter(valid_569115, JString, required = false,
                                 default = nil)
  if valid_569115 != nil:
    section.add "ContinuationToken", valid_569115
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569116: Call_GetSubNameInfoList_569108; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  let valid = call_569116.validator(path, query, header, formData, body)
  let scheme = call_569116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569116.url(scheme.get, call_569116.host, call_569116.base,
                         call_569116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569116, url, valid)

proc call*(call_569117: Call_GetSubNameInfoList_569108; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"; Recursive: bool = false;
          ContinuationToken: string = ""): Recallable =
  ## getSubNameInfoList
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Recursive: bool
  ##            : Allows specifying that the search performed should be recursive.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_569118 = newJObject()
  var query_569119 = newJObject()
  add(query_569119, "timeout", newJInt(timeout))
  add(query_569119, "api-version", newJString(apiVersion))
  add(query_569119, "Recursive", newJBool(Recursive))
  add(path_569118, "nameId", newJString(nameId))
  add(query_569119, "ContinuationToken", newJString(ContinuationToken))
  result = call_569117.call(path_569118, query_569119, nil, nil, nil)

var getSubNameInfoList* = Call_GetSubNameInfoList_569108(
    name: "getSubNameInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetSubNames",
    validator: validate_GetSubNameInfoList_569109, base: "",
    url: url_GetSubNameInfoList_569110, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfoList_569120 = ref object of OpenApiRestCall_567667
proc url_GetNodeInfoList_569122(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetNodeInfoList_569121(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: JString
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_569123 = query.getOrDefault("timeout")
  valid_569123 = validateParameter(valid_569123, JInt, required = false,
                                 default = newJInt(60))
  if valid_569123 != nil:
    section.add "timeout", valid_569123
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569124 = query.getOrDefault("api-version")
  valid_569124 = validateParameter(valid_569124, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569124 != nil:
    section.add "api-version", valid_569124
  var valid_569125 = query.getOrDefault("NodeStatusFilter")
  valid_569125 = validateParameter(valid_569125, JString, required = false,
                                 default = newJString("default"))
  if valid_569125 != nil:
    section.add "NodeStatusFilter", valid_569125
  var valid_569126 = query.getOrDefault("ContinuationToken")
  valid_569126 = validateParameter(valid_569126, JString, required = false,
                                 default = nil)
  if valid_569126 != nil:
    section.add "ContinuationToken", valid_569126
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569127: Call_GetNodeInfoList_569120; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_569127.validator(path, query, header, formData, body)
  let scheme = call_569127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569127.url(scheme.get, call_569127.host, call_569127.base,
                         call_569127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569127, url, valid)

proc call*(call_569128: Call_GetNodeInfoList_569120; timeout: int = 60;
          apiVersion: string = "6.0"; NodeStatusFilter: string = "default";
          ContinuationToken: string = ""): Recallable =
  ## getNodeInfoList
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: string
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var query_569129 = newJObject()
  add(query_569129, "timeout", newJInt(timeout))
  add(query_569129, "api-version", newJString(apiVersion))
  add(query_569129, "NodeStatusFilter", newJString(NodeStatusFilter))
  add(query_569129, "ContinuationToken", newJString(ContinuationToken))
  result = call_569128.call(nil, query_569129, nil, nil, nil)

var getNodeInfoList* = Call_GetNodeInfoList_569120(name: "getNodeInfoList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Nodes",
    validator: validate_GetNodeInfoList_569121, base: "", url: url_GetNodeInfoList_569122,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfo_569130 = ref object of OpenApiRestCall_567667
proc url_GetNodeInfo_569132(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeInfo_569131(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569133 = path.getOrDefault("nodeName")
  valid_569133 = validateParameter(valid_569133, JString, required = true,
                                 default = nil)
  if valid_569133 != nil:
    section.add "nodeName", valid_569133
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569134 = query.getOrDefault("timeout")
  valid_569134 = validateParameter(valid_569134, JInt, required = false,
                                 default = newJInt(60))
  if valid_569134 != nil:
    section.add "timeout", valid_569134
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569135 = query.getOrDefault("api-version")
  valid_569135 = validateParameter(valid_569135, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569135 != nil:
    section.add "api-version", valid_569135
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569136: Call_GetNodeInfo_569130; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_569136.validator(path, query, header, formData, body)
  let scheme = call_569136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569136.url(scheme.get, call_569136.host, call_569136.base,
                         call_569136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569136, url, valid)

proc call*(call_569137: Call_GetNodeInfo_569130; nodeName: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getNodeInfo
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_569138 = newJObject()
  var query_569139 = newJObject()
  add(query_569139, "timeout", newJInt(timeout))
  add(query_569139, "api-version", newJString(apiVersion))
  add(path_569138, "nodeName", newJString(nodeName))
  result = call_569137.call(path_569138, query_569139, nil, nil, nil)

var getNodeInfo* = Call_GetNodeInfo_569130(name: "getNodeInfo",
                                        meth: HttpMethod.HttpGet,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}",
                                        validator: validate_GetNodeInfo_569131,
                                        base: "", url: url_GetNodeInfo_569132,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableNode_569140 = ref object of OpenApiRestCall_567667
proc url_EnableNode_569142(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Activate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_EnableNode_569141(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569143 = path.getOrDefault("nodeName")
  valid_569143 = validateParameter(valid_569143, JString, required = true,
                                 default = nil)
  if valid_569143 != nil:
    section.add "nodeName", valid_569143
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569144 = query.getOrDefault("timeout")
  valid_569144 = validateParameter(valid_569144, JInt, required = false,
                                 default = newJInt(60))
  if valid_569144 != nil:
    section.add "timeout", valid_569144
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569145 = query.getOrDefault("api-version")
  valid_569145 = validateParameter(valid_569145, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569145 != nil:
    section.add "api-version", valid_569145
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569146: Call_EnableNode_569140; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  let valid = call_569146.validator(path, query, header, formData, body)
  let scheme = call_569146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569146.url(scheme.get, call_569146.host, call_569146.base,
                         call_569146.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569146, url, valid)

proc call*(call_569147: Call_EnableNode_569140; nodeName: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## enableNode
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_569148 = newJObject()
  var query_569149 = newJObject()
  add(query_569149, "timeout", newJInt(timeout))
  add(query_569149, "api-version", newJString(apiVersion))
  add(path_569148, "nodeName", newJString(nodeName))
  result = call_569147.call(path_569148, query_569149, nil, nil, nil)

var enableNode* = Call_EnableNode_569140(name: "enableNode",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Nodes/{nodeName}/$/Activate",
                                      validator: validate_EnableNode_569141,
                                      base: "", url: url_EnableNode_569142,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableNode_569150 = ref object of OpenApiRestCall_567667
proc url_DisableNode_569152(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Deactivate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DisableNode_569151(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569153 = path.getOrDefault("nodeName")
  valid_569153 = validateParameter(valid_569153, JString, required = true,
                                 default = nil)
  if valid_569153 != nil:
    section.add "nodeName", valid_569153
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569154 = query.getOrDefault("timeout")
  valid_569154 = validateParameter(valid_569154, JInt, required = false,
                                 default = newJInt(60))
  if valid_569154 != nil:
    section.add "timeout", valid_569154
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569155 = query.getOrDefault("api-version")
  valid_569155 = validateParameter(valid_569155, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569155 != nil:
    section.add "api-version", valid_569155
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569157: Call_DisableNode_569150; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  let valid = call_569157.validator(path, query, header, formData, body)
  let scheme = call_569157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569157.url(scheme.get, call_569157.host, call_569157.base,
                         call_569157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569157, url, valid)

proc call*(call_569158: Call_DisableNode_569150; nodeName: string;
          DeactivationIntentDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## disableNode
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  var path_569159 = newJObject()
  var query_569160 = newJObject()
  var body_569161 = newJObject()
  add(query_569160, "timeout", newJInt(timeout))
  add(query_569160, "api-version", newJString(apiVersion))
  add(path_569159, "nodeName", newJString(nodeName))
  if DeactivationIntentDescription != nil:
    body_569161 = DeactivationIntentDescription
  result = call_569158.call(path_569159, query_569160, nil, nil, body_569161)

var disableNode* = Call_DisableNode_569150(name: "disableNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080", route: "/Nodes/{nodeName}/$/Deactivate",
                                        validator: validate_DisableNode_569151,
                                        base: "", url: url_DisableNode_569152,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeployedServicePackageToNode_569162 = ref object of OpenApiRestCall_567667
proc url_DeployedServicePackageToNode_569164(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/DeployServicePackage")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeployedServicePackageToNode_569163(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569165 = path.getOrDefault("nodeName")
  valid_569165 = validateParameter(valid_569165, JString, required = true,
                                 default = nil)
  if valid_569165 != nil:
    section.add "nodeName", valid_569165
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569166 = query.getOrDefault("timeout")
  valid_569166 = validateParameter(valid_569166, JInt, required = false,
                                 default = newJInt(60))
  if valid_569166 != nil:
    section.add "timeout", valid_569166
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569167 = query.getOrDefault("api-version")
  valid_569167 = validateParameter(valid_569167, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569167 != nil:
    section.add "api-version", valid_569167
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569169: Call_DeployedServicePackageToNode_569162; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  let valid = call_569169.validator(path, query, header, formData, body)
  let scheme = call_569169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569169.url(scheme.get, call_569169.host, call_569169.base,
                         call_569169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569169, url, valid)

proc call*(call_569170: Call_DeployedServicePackageToNode_569162; nodeName: string;
          DeployServicePackageToNodeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## deployedServicePackageToNode
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  var path_569171 = newJObject()
  var query_569172 = newJObject()
  var body_569173 = newJObject()
  add(query_569172, "timeout", newJInt(timeout))
  add(query_569172, "api-version", newJString(apiVersion))
  add(path_569171, "nodeName", newJString(nodeName))
  if DeployServicePackageToNodeDescription != nil:
    body_569173 = DeployServicePackageToNodeDescription
  result = call_569170.call(path_569171, query_569172, nil, nil, body_569173)

var deployedServicePackageToNode* = Call_DeployedServicePackageToNode_569162(
    name: "deployedServicePackageToNode", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/DeployServicePackage",
    validator: validate_DeployedServicePackageToNode_569163, base: "",
    url: url_DeployedServicePackageToNode_569164,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfoList_569174 = ref object of OpenApiRestCall_567667
proc url_GetDeployedApplicationInfoList_569176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfoList_569175(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569177 = path.getOrDefault("nodeName")
  valid_569177 = validateParameter(valid_569177, JString, required = true,
                                 default = nil)
  if valid_569177 != nil:
    section.add "nodeName", valid_569177
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569178 = query.getOrDefault("timeout")
  valid_569178 = validateParameter(valid_569178, JInt, required = false,
                                 default = newJInt(60))
  if valid_569178 != nil:
    section.add "timeout", valid_569178
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569179 = query.getOrDefault("api-version")
  valid_569179 = validateParameter(valid_569179, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569179 != nil:
    section.add "api-version", valid_569179
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569180: Call_GetDeployedApplicationInfoList_569174; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  let valid = call_569180.validator(path, query, header, formData, body)
  let scheme = call_569180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569180.url(scheme.get, call_569180.host, call_569180.base,
                         call_569180.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569180, url, valid)

proc call*(call_569181: Call_GetDeployedApplicationInfoList_569174;
          nodeName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedApplicationInfoList
  ## Gets the list of applications deployed on a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_569182 = newJObject()
  var query_569183 = newJObject()
  add(query_569183, "timeout", newJInt(timeout))
  add(query_569183, "api-version", newJString(apiVersion))
  add(path_569182, "nodeName", newJString(nodeName))
  result = call_569181.call(path_569182, query_569183, nil, nil, nil)

var getDeployedApplicationInfoList* = Call_GetDeployedApplicationInfoList_569174(
    name: "getDeployedApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications",
    validator: validate_GetDeployedApplicationInfoList_569175, base: "",
    url: url_GetDeployedApplicationInfoList_569176,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfo_569184 = ref object of OpenApiRestCall_567667
proc url_GetDeployedApplicationInfo_569186(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfo_569185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569187 = path.getOrDefault("nodeName")
  valid_569187 = validateParameter(valid_569187, JString, required = true,
                                 default = nil)
  if valid_569187 != nil:
    section.add "nodeName", valid_569187
  var valid_569188 = path.getOrDefault("applicationId")
  valid_569188 = validateParameter(valid_569188, JString, required = true,
                                 default = nil)
  if valid_569188 != nil:
    section.add "applicationId", valid_569188
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569189 = query.getOrDefault("timeout")
  valid_569189 = validateParameter(valid_569189, JInt, required = false,
                                 default = newJInt(60))
  if valid_569189 != nil:
    section.add "timeout", valid_569189
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569190 = query.getOrDefault("api-version")
  valid_569190 = validateParameter(valid_569190, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569190 != nil:
    section.add "api-version", valid_569190
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569191: Call_GetDeployedApplicationInfo_569184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  let valid = call_569191.validator(path, query, header, formData, body)
  let scheme = call_569191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569191.url(scheme.get, call_569191.host, call_569191.base,
                         call_569191.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569191, url, valid)

proc call*(call_569192: Call_GetDeployedApplicationInfo_569184; nodeName: string;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedApplicationInfo
  ## Gets the information about an application deployed on a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569193 = newJObject()
  var query_569194 = newJObject()
  add(query_569194, "timeout", newJInt(timeout))
  add(query_569194, "api-version", newJString(apiVersion))
  add(path_569193, "nodeName", newJString(nodeName))
  add(path_569193, "applicationId", newJString(applicationId))
  result = call_569192.call(path_569193, query_569194, nil, nil, nil)

var getDeployedApplicationInfo* = Call_GetDeployedApplicationInfo_569184(
    name: "getDeployedApplicationInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}",
    validator: validate_GetDeployedApplicationInfo_569185, base: "",
    url: url_GetDeployedApplicationInfo_569186,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedCodePackageInfoList_569195 = ref object of OpenApiRestCall_567667
proc url_GetDeployedCodePackageInfoList_569197(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedCodePackageInfoList_569196(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569198 = path.getOrDefault("nodeName")
  valid_569198 = validateParameter(valid_569198, JString, required = true,
                                 default = nil)
  if valid_569198 != nil:
    section.add "nodeName", valid_569198
  var valid_569199 = path.getOrDefault("applicationId")
  valid_569199 = validateParameter(valid_569199, JString, required = true,
                                 default = nil)
  if valid_569199 != nil:
    section.add "applicationId", valid_569199
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   CodePackageName: JString
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  var valid_569200 = query.getOrDefault("timeout")
  valid_569200 = validateParameter(valid_569200, JInt, required = false,
                                 default = newJInt(60))
  if valid_569200 != nil:
    section.add "timeout", valid_569200
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569201 = query.getOrDefault("api-version")
  valid_569201 = validateParameter(valid_569201, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569201 != nil:
    section.add "api-version", valid_569201
  var valid_569202 = query.getOrDefault("ServiceManifestName")
  valid_569202 = validateParameter(valid_569202, JString, required = false,
                                 default = nil)
  if valid_569202 != nil:
    section.add "ServiceManifestName", valid_569202
  var valid_569203 = query.getOrDefault("CodePackageName")
  valid_569203 = validateParameter(valid_569203, JString, required = false,
                                 default = nil)
  if valid_569203 != nil:
    section.add "CodePackageName", valid_569203
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569204: Call_GetDeployedCodePackageInfoList_569195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_569204.validator(path, query, header, formData, body)
  let scheme = call_569204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569204.url(scheme.get, call_569204.host, call_569204.base,
                         call_569204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569204, url, valid)

proc call*(call_569205: Call_GetDeployedCodePackageInfoList_569195;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = "";
          CodePackageName: string = ""): Recallable =
  ## getDeployedCodePackageInfoList
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   CodePackageName: string
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  var path_569206 = newJObject()
  var query_569207 = newJObject()
  add(query_569207, "timeout", newJInt(timeout))
  add(query_569207, "api-version", newJString(apiVersion))
  add(path_569206, "nodeName", newJString(nodeName))
  add(query_569207, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_569206, "applicationId", newJString(applicationId))
  add(query_569207, "CodePackageName", newJString(CodePackageName))
  result = call_569205.call(path_569206, query_569207, nil, nil, nil)

var getDeployedCodePackageInfoList* = Call_GetDeployedCodePackageInfoList_569195(
    name: "getDeployedCodePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages",
    validator: validate_GetDeployedCodePackageInfoList_569196, base: "",
    url: url_GetDeployedCodePackageInfoList_569197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartDeployedCodePackage_569208 = ref object of OpenApiRestCall_567667
proc url_RestartDeployedCodePackage_569210(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartDeployedCodePackage_569209(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569211 = path.getOrDefault("nodeName")
  valid_569211 = validateParameter(valid_569211, JString, required = true,
                                 default = nil)
  if valid_569211 != nil:
    section.add "nodeName", valid_569211
  var valid_569212 = path.getOrDefault("applicationId")
  valid_569212 = validateParameter(valid_569212, JString, required = true,
                                 default = nil)
  if valid_569212 != nil:
    section.add "applicationId", valid_569212
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569213 = query.getOrDefault("timeout")
  valid_569213 = validateParameter(valid_569213, JInt, required = false,
                                 default = newJInt(60))
  if valid_569213 != nil:
    section.add "timeout", valid_569213
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569214 = query.getOrDefault("api-version")
  valid_569214 = validateParameter(valid_569214, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569214 != nil:
    section.add "api-version", valid_569214
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569216: Call_RestartDeployedCodePackage_569208; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  let valid = call_569216.validator(path, query, header, formData, body)
  let scheme = call_569216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569216.url(scheme.get, call_569216.host, call_569216.base,
                         call_569216.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569216, url, valid)

proc call*(call_569217: Call_RestartDeployedCodePackage_569208; nodeName: string;
          applicationId: string; RestartDeployedCodePackageDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## restartDeployedCodePackage
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  var path_569218 = newJObject()
  var query_569219 = newJObject()
  var body_569220 = newJObject()
  add(query_569219, "timeout", newJInt(timeout))
  add(query_569219, "api-version", newJString(apiVersion))
  add(path_569218, "nodeName", newJString(nodeName))
  add(path_569218, "applicationId", newJString(applicationId))
  if RestartDeployedCodePackageDescription != nil:
    body_569220 = RestartDeployedCodePackageDescription
  result = call_569217.call(path_569218, query_569219, nil, nil, body_569220)

var restartDeployedCodePackage* = Call_RestartDeployedCodePackage_569208(
    name: "restartDeployedCodePackage", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart",
    validator: validate_RestartDeployedCodePackage_569209, base: "",
    url: url_RestartDeployedCodePackage_569210,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealthUsingPolicy_569235 = ref object of OpenApiRestCall_567667
proc url_GetDeployedApplicationHealthUsingPolicy_569237(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealthUsingPolicy_569236(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569238 = path.getOrDefault("nodeName")
  valid_569238 = validateParameter(valid_569238, JString, required = true,
                                 default = nil)
  if valid_569238 != nil:
    section.add "nodeName", valid_569238
  var valid_569239 = path.getOrDefault("applicationId")
  valid_569239 = validateParameter(valid_569239, JString, required = true,
                                 default = nil)
  if valid_569239 != nil:
    section.add "applicationId", valid_569239
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569240 = query.getOrDefault("timeout")
  valid_569240 = validateParameter(valid_569240, JInt, required = false,
                                 default = newJInt(60))
  if valid_569240 != nil:
    section.add "timeout", valid_569240
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569241 = query.getOrDefault("api-version")
  valid_569241 = validateParameter(valid_569241, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569241 != nil:
    section.add "api-version", valid_569241
  var valid_569242 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_569242 = validateParameter(valid_569242, JInt, required = false,
                                 default = newJInt(0))
  if valid_569242 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_569242
  var valid_569243 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569243 = validateParameter(valid_569243, JBool, required = false,
                                 default = newJBool(false))
  if valid_569243 != nil:
    section.add "ExcludeHealthStatistics", valid_569243
  var valid_569244 = query.getOrDefault("EventsHealthStateFilter")
  valid_569244 = validateParameter(valid_569244, JInt, required = false,
                                 default = newJInt(0))
  if valid_569244 != nil:
    section.add "EventsHealthStateFilter", valid_569244
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569246: Call_GetDeployedApplicationHealthUsingPolicy_569235;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  let valid = call_569246.validator(path, query, header, formData, body)
  let scheme = call_569246.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569246.url(scheme.get, call_569246.host, call_569246.base,
                         call_569246.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569246, url, valid)

proc call*(call_569247: Call_GetDeployedApplicationHealthUsingPolicy_569235;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationHealthPolicy: JsonNode = nil;
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealthUsingPolicy
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569248 = newJObject()
  var query_569249 = newJObject()
  var body_569250 = newJObject()
  add(query_569249, "timeout", newJInt(timeout))
  add(query_569249, "api-version", newJString(apiVersion))
  add(path_569248, "nodeName", newJString(nodeName))
  if ApplicationHealthPolicy != nil:
    body_569250 = ApplicationHealthPolicy
  add(query_569249, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_569249, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569249, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569248, "applicationId", newJString(applicationId))
  result = call_569247.call(path_569248, query_569249, nil, nil, body_569250)

var getDeployedApplicationHealthUsingPolicy* = Call_GetDeployedApplicationHealthUsingPolicy_569235(
    name: "getDeployedApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealthUsingPolicy_569236, base: "",
    url: url_GetDeployedApplicationHealthUsingPolicy_569237,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealth_569221 = ref object of OpenApiRestCall_567667
proc url_GetDeployedApplicationHealth_569223(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealth_569222(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569224 = path.getOrDefault("nodeName")
  valid_569224 = validateParameter(valid_569224, JString, required = true,
                                 default = nil)
  if valid_569224 != nil:
    section.add "nodeName", valid_569224
  var valid_569225 = path.getOrDefault("applicationId")
  valid_569225 = validateParameter(valid_569225, JString, required = true,
                                 default = nil)
  if valid_569225 != nil:
    section.add "applicationId", valid_569225
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569226 = query.getOrDefault("timeout")
  valid_569226 = validateParameter(valid_569226, JInt, required = false,
                                 default = newJInt(60))
  if valid_569226 != nil:
    section.add "timeout", valid_569226
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569227 = query.getOrDefault("api-version")
  valid_569227 = validateParameter(valid_569227, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569227 != nil:
    section.add "api-version", valid_569227
  var valid_569228 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_569228 = validateParameter(valid_569228, JInt, required = false,
                                 default = newJInt(0))
  if valid_569228 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_569228
  var valid_569229 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569229 = validateParameter(valid_569229, JBool, required = false,
                                 default = newJBool(false))
  if valid_569229 != nil:
    section.add "ExcludeHealthStatistics", valid_569229
  var valid_569230 = query.getOrDefault("EventsHealthStateFilter")
  valid_569230 = validateParameter(valid_569230, JInt, required = false,
                                 default = newJInt(0))
  if valid_569230 != nil:
    section.add "EventsHealthStateFilter", valid_569230
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569231: Call_GetDeployedApplicationHealth_569221; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  let valid = call_569231.validator(path, query, header, formData, body)
  let scheme = call_569231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569231.url(scheme.get, call_569231.host, call_569231.base,
                         call_569231.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569231, url, valid)

proc call*(call_569232: Call_GetDeployedApplicationHealth_569221; nodeName: string;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0";
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealth
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569233 = newJObject()
  var query_569234 = newJObject()
  add(query_569234, "timeout", newJInt(timeout))
  add(query_569234, "api-version", newJString(apiVersion))
  add(path_569233, "nodeName", newJString(nodeName))
  add(query_569234, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_569234, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569234, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569233, "applicationId", newJString(applicationId))
  result = call_569232.call(path_569233, query_569234, nil, nil, nil)

var getDeployedApplicationHealth* = Call_GetDeployedApplicationHealth_569221(
    name: "getDeployedApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealth_569222, base: "",
    url: url_GetDeployedApplicationHealth_569223,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaInfoList_569251 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServiceReplicaInfoList_569253(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaInfoList_569252(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569254 = path.getOrDefault("nodeName")
  valid_569254 = validateParameter(valid_569254, JString, required = true,
                                 default = nil)
  if valid_569254 != nil:
    section.add "nodeName", valid_569254
  var valid_569255 = path.getOrDefault("applicationId")
  valid_569255 = validateParameter(valid_569255, JString, required = true,
                                 default = nil)
  if valid_569255 != nil:
    section.add "applicationId", valid_569255
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   PartitionId: JString
  ##              : The identity of the partition.
  section = newJObject()
  var valid_569256 = query.getOrDefault("timeout")
  valid_569256 = validateParameter(valid_569256, JInt, required = false,
                                 default = newJInt(60))
  if valid_569256 != nil:
    section.add "timeout", valid_569256
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569257 = query.getOrDefault("api-version")
  valid_569257 = validateParameter(valid_569257, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569257 != nil:
    section.add "api-version", valid_569257
  var valid_569258 = query.getOrDefault("ServiceManifestName")
  valid_569258 = validateParameter(valid_569258, JString, required = false,
                                 default = nil)
  if valid_569258 != nil:
    section.add "ServiceManifestName", valid_569258
  var valid_569259 = query.getOrDefault("PartitionId")
  valid_569259 = validateParameter(valid_569259, JString, required = false,
                                 default = nil)
  if valid_569259 != nil:
    section.add "PartitionId", valid_569259
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569260: Call_GetDeployedServiceReplicaInfoList_569251;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  let valid = call_569260.validator(path, query, header, formData, body)
  let scheme = call_569260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569260.url(scheme.get, call_569260.host, call_569260.base,
                         call_569260.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569260, url, valid)

proc call*(call_569261: Call_GetDeployedServiceReplicaInfoList_569251;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = "";
          PartitionId: string = ""): Recallable =
  ## getDeployedServiceReplicaInfoList
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   PartitionId: string
  ##              : The identity of the partition.
  var path_569262 = newJObject()
  var query_569263 = newJObject()
  add(query_569263, "timeout", newJInt(timeout))
  add(query_569263, "api-version", newJString(apiVersion))
  add(path_569262, "nodeName", newJString(nodeName))
  add(query_569263, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_569262, "applicationId", newJString(applicationId))
  add(query_569263, "PartitionId", newJString(PartitionId))
  result = call_569261.call(path_569262, query_569263, nil, nil, nil)

var getDeployedServiceReplicaInfoList* = Call_GetDeployedServiceReplicaInfoList_569251(
    name: "getDeployedServiceReplicaInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaInfoList_569252, base: "",
    url: url_GetDeployedServiceReplicaInfoList_569253,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoList_569264 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServicePackageInfoList_569266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoList_569265(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569267 = path.getOrDefault("nodeName")
  valid_569267 = validateParameter(valid_569267, JString, required = true,
                                 default = nil)
  if valid_569267 != nil:
    section.add "nodeName", valid_569267
  var valid_569268 = path.getOrDefault("applicationId")
  valid_569268 = validateParameter(valid_569268, JString, required = true,
                                 default = nil)
  if valid_569268 != nil:
    section.add "applicationId", valid_569268
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569269 = query.getOrDefault("timeout")
  valid_569269 = validateParameter(valid_569269, JInt, required = false,
                                 default = newJInt(60))
  if valid_569269 != nil:
    section.add "timeout", valid_569269
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569270 = query.getOrDefault("api-version")
  valid_569270 = validateParameter(valid_569270, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569270 != nil:
    section.add "api-version", valid_569270
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569271: Call_GetDeployedServicePackageInfoList_569264;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_569271.validator(path, query, header, formData, body)
  let scheme = call_569271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569271.url(scheme.get, call_569271.host, call_569271.base,
                         call_569271.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569271, url, valid)

proc call*(call_569272: Call_GetDeployedServicePackageInfoList_569264;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServicePackageInfoList
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569273 = newJObject()
  var query_569274 = newJObject()
  add(query_569274, "timeout", newJInt(timeout))
  add(query_569274, "api-version", newJString(apiVersion))
  add(path_569273, "nodeName", newJString(nodeName))
  add(path_569273, "applicationId", newJString(applicationId))
  result = call_569272.call(path_569273, query_569274, nil, nil, nil)

var getDeployedServicePackageInfoList* = Call_GetDeployedServicePackageInfoList_569264(
    name: "getDeployedServicePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages",
    validator: validate_GetDeployedServicePackageInfoList_569265, base: "",
    url: url_GetDeployedServicePackageInfoList_569266,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoListByName_569275 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServicePackageInfoListByName_569277(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoListByName_569276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569278 = path.getOrDefault("nodeName")
  valid_569278 = validateParameter(valid_569278, JString, required = true,
                                 default = nil)
  if valid_569278 != nil:
    section.add "nodeName", valid_569278
  var valid_569279 = path.getOrDefault("applicationId")
  valid_569279 = validateParameter(valid_569279, JString, required = true,
                                 default = nil)
  if valid_569279 != nil:
    section.add "applicationId", valid_569279
  var valid_569280 = path.getOrDefault("servicePackageName")
  valid_569280 = validateParameter(valid_569280, JString, required = true,
                                 default = nil)
  if valid_569280 != nil:
    section.add "servicePackageName", valid_569280
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569281 = query.getOrDefault("timeout")
  valid_569281 = validateParameter(valid_569281, JInt, required = false,
                                 default = newJInt(60))
  if valid_569281 != nil:
    section.add "timeout", valid_569281
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569282 = query.getOrDefault("api-version")
  valid_569282 = validateParameter(valid_569282, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569282 != nil:
    section.add "api-version", valid_569282
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569283: Call_GetDeployedServicePackageInfoListByName_569275;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  let valid = call_569283.validator(path, query, header, formData, body)
  let scheme = call_569283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569283.url(scheme.get, call_569283.host, call_569283.base,
                         call_569283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569283, url, valid)

proc call*(call_569284: Call_GetDeployedServicePackageInfoListByName_569275;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedServicePackageInfoListByName
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_569285 = newJObject()
  var query_569286 = newJObject()
  add(query_569286, "timeout", newJInt(timeout))
  add(query_569286, "api-version", newJString(apiVersion))
  add(path_569285, "nodeName", newJString(nodeName))
  add(path_569285, "applicationId", newJString(applicationId))
  add(path_569285, "servicePackageName", newJString(servicePackageName))
  result = call_569284.call(path_569285, query_569286, nil, nil, nil)

var getDeployedServicePackageInfoListByName* = Call_GetDeployedServicePackageInfoListByName_569275(
    name: "getDeployedServicePackageInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}",
    validator: validate_GetDeployedServicePackageInfoListByName_569276, base: "",
    url: url_GetDeployedServicePackageInfoListByName_569277,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealthUsingPolicy_569300 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServicePackageHealthUsingPolicy_569302(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealthUsingPolicy_569301(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569303 = path.getOrDefault("nodeName")
  valid_569303 = validateParameter(valid_569303, JString, required = true,
                                 default = nil)
  if valid_569303 != nil:
    section.add "nodeName", valid_569303
  var valid_569304 = path.getOrDefault("applicationId")
  valid_569304 = validateParameter(valid_569304, JString, required = true,
                                 default = nil)
  if valid_569304 != nil:
    section.add "applicationId", valid_569304
  var valid_569305 = path.getOrDefault("servicePackageName")
  valid_569305 = validateParameter(valid_569305, JString, required = true,
                                 default = nil)
  if valid_569305 != nil:
    section.add "servicePackageName", valid_569305
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569306 = query.getOrDefault("timeout")
  valid_569306 = validateParameter(valid_569306, JInt, required = false,
                                 default = newJInt(60))
  if valid_569306 != nil:
    section.add "timeout", valid_569306
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569307 = query.getOrDefault("api-version")
  valid_569307 = validateParameter(valid_569307, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569307 != nil:
    section.add "api-version", valid_569307
  var valid_569308 = query.getOrDefault("EventsHealthStateFilter")
  valid_569308 = validateParameter(valid_569308, JInt, required = false,
                                 default = newJInt(0))
  if valid_569308 != nil:
    section.add "EventsHealthStateFilter", valid_569308
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569310: Call_GetDeployedServicePackageHealthUsingPolicy_569300;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  let valid = call_569310.validator(path, query, header, formData, body)
  let scheme = call_569310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569310.url(scheme.get, call_569310.host, call_569310.base,
                         call_569310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569310, url, valid)

proc call*(call_569311: Call_GetDeployedServicePackageHealthUsingPolicy_569300;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealthUsingPolicy
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_569312 = newJObject()
  var query_569313 = newJObject()
  var body_569314 = newJObject()
  add(query_569313, "timeout", newJInt(timeout))
  add(query_569313, "api-version", newJString(apiVersion))
  add(path_569312, "nodeName", newJString(nodeName))
  if ApplicationHealthPolicy != nil:
    body_569314 = ApplicationHealthPolicy
  add(query_569313, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569312, "applicationId", newJString(applicationId))
  add(path_569312, "servicePackageName", newJString(servicePackageName))
  result = call_569311.call(path_569312, query_569313, nil, nil, body_569314)

var getDeployedServicePackageHealthUsingPolicy* = Call_GetDeployedServicePackageHealthUsingPolicy_569300(
    name: "getDeployedServicePackageHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealthUsingPolicy_569301,
    base: "", url: url_GetDeployedServicePackageHealthUsingPolicy_569302,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealth_569287 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServicePackageHealth_569289(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealth_569288(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569290 = path.getOrDefault("nodeName")
  valid_569290 = validateParameter(valid_569290, JString, required = true,
                                 default = nil)
  if valid_569290 != nil:
    section.add "nodeName", valid_569290
  var valid_569291 = path.getOrDefault("applicationId")
  valid_569291 = validateParameter(valid_569291, JString, required = true,
                                 default = nil)
  if valid_569291 != nil:
    section.add "applicationId", valid_569291
  var valid_569292 = path.getOrDefault("servicePackageName")
  valid_569292 = validateParameter(valid_569292, JString, required = true,
                                 default = nil)
  if valid_569292 != nil:
    section.add "servicePackageName", valid_569292
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569293 = query.getOrDefault("timeout")
  valid_569293 = validateParameter(valid_569293, JInt, required = false,
                                 default = newJInt(60))
  if valid_569293 != nil:
    section.add "timeout", valid_569293
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569294 = query.getOrDefault("api-version")
  valid_569294 = validateParameter(valid_569294, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569294 != nil:
    section.add "api-version", valid_569294
  var valid_569295 = query.getOrDefault("EventsHealthStateFilter")
  valid_569295 = validateParameter(valid_569295, JInt, required = false,
                                 default = newJInt(0))
  if valid_569295 != nil:
    section.add "EventsHealthStateFilter", valid_569295
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569296: Call_GetDeployedServicePackageHealth_569287;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  let valid = call_569296.validator(path, query, header, formData, body)
  let scheme = call_569296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569296.url(scheme.get, call_569296.host, call_569296.base,
                         call_569296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569296, url, valid)

proc call*(call_569297: Call_GetDeployedServicePackageHealth_569287;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealth
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_569298 = newJObject()
  var query_569299 = newJObject()
  add(query_569299, "timeout", newJInt(timeout))
  add(query_569299, "api-version", newJString(apiVersion))
  add(path_569298, "nodeName", newJString(nodeName))
  add(query_569299, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569298, "applicationId", newJString(applicationId))
  add(path_569298, "servicePackageName", newJString(servicePackageName))
  result = call_569297.call(path_569298, query_569299, nil, nil, nil)

var getDeployedServicePackageHealth* = Call_GetDeployedServicePackageHealth_569287(
    name: "getDeployedServicePackageHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealth_569288, base: "",
    url: url_GetDeployedServicePackageHealth_569289,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedServicePackageHealth_569315 = ref object of OpenApiRestCall_567667
proc url_ReportDeployedServicePackageHealth_569317(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedServicePackageHealth_569316(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569318 = path.getOrDefault("nodeName")
  valid_569318 = validateParameter(valid_569318, JString, required = true,
                                 default = nil)
  if valid_569318 != nil:
    section.add "nodeName", valid_569318
  var valid_569319 = path.getOrDefault("applicationId")
  valid_569319 = validateParameter(valid_569319, JString, required = true,
                                 default = nil)
  if valid_569319 != nil:
    section.add "applicationId", valid_569319
  var valid_569320 = path.getOrDefault("servicePackageName")
  valid_569320 = validateParameter(valid_569320, JString, required = true,
                                 default = nil)
  if valid_569320 != nil:
    section.add "servicePackageName", valid_569320
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569321 = query.getOrDefault("Immediate")
  valid_569321 = validateParameter(valid_569321, JBool, required = false,
                                 default = newJBool(false))
  if valid_569321 != nil:
    section.add "Immediate", valid_569321
  var valid_569322 = query.getOrDefault("timeout")
  valid_569322 = validateParameter(valid_569322, JInt, required = false,
                                 default = newJInt(60))
  if valid_569322 != nil:
    section.add "timeout", valid_569322
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569323 = query.getOrDefault("api-version")
  valid_569323 = validateParameter(valid_569323, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569323 != nil:
    section.add "api-version", valid_569323
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569325: Call_ReportDeployedServicePackageHealth_569315;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569325.validator(path, query, header, formData, body)
  let scheme = call_569325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569325.url(scheme.get, call_569325.host, call_569325.base,
                         call_569325.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569325, url, valid)

proc call*(call_569326: Call_ReportDeployedServicePackageHealth_569315;
          nodeName: string; HealthInformation: JsonNode; applicationId: string;
          servicePackageName: string; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportDeployedServicePackageHealth
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_569327 = newJObject()
  var query_569328 = newJObject()
  var body_569329 = newJObject()
  add(query_569328, "Immediate", newJBool(Immediate))
  add(query_569328, "timeout", newJInt(timeout))
  add(query_569328, "api-version", newJString(apiVersion))
  add(path_569327, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_569329 = HealthInformation
  add(path_569327, "applicationId", newJString(applicationId))
  add(path_569327, "servicePackageName", newJString(servicePackageName))
  result = call_569326.call(path_569327, query_569328, nil, nil, body_569329)

var reportDeployedServicePackageHealth* = Call_ReportDeployedServicePackageHealth_569315(
    name: "reportDeployedServicePackageHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth",
    validator: validate_ReportDeployedServicePackageHealth_569316, base: "",
    url: url_ReportDeployedServicePackageHealth_569317,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoList_569330 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServiceTypeInfoList_569332(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoList_569331(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569333 = path.getOrDefault("nodeName")
  valid_569333 = validateParameter(valid_569333, JString, required = true,
                                 default = nil)
  if valid_569333 != nil:
    section.add "nodeName", valid_569333
  var valid_569334 = path.getOrDefault("applicationId")
  valid_569334 = validateParameter(valid_569334, JString, required = true,
                                 default = nil)
  if valid_569334 != nil:
    section.add "applicationId", valid_569334
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  var valid_569335 = query.getOrDefault("timeout")
  valid_569335 = validateParameter(valid_569335, JInt, required = false,
                                 default = newJInt(60))
  if valid_569335 != nil:
    section.add "timeout", valid_569335
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569336 = query.getOrDefault("api-version")
  valid_569336 = validateParameter(valid_569336, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569336 != nil:
    section.add "api-version", valid_569336
  var valid_569337 = query.getOrDefault("ServiceManifestName")
  valid_569337 = validateParameter(valid_569337, JString, required = false,
                                 default = nil)
  if valid_569337 != nil:
    section.add "ServiceManifestName", valid_569337
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569338: Call_GetDeployedServiceTypeInfoList_569330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  let valid = call_569338.validator(path, query, header, formData, body)
  let scheme = call_569338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569338.url(scheme.get, call_569338.host, call_569338.base,
                         call_569338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569338, url, valid)

proc call*(call_569339: Call_GetDeployedServiceTypeInfoList_569330;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoList
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569340 = newJObject()
  var query_569341 = newJObject()
  add(query_569341, "timeout", newJInt(timeout))
  add(query_569341, "api-version", newJString(apiVersion))
  add(path_569340, "nodeName", newJString(nodeName))
  add(query_569341, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_569340, "applicationId", newJString(applicationId))
  result = call_569339.call(path_569340, query_569341, nil, nil, nil)

var getDeployedServiceTypeInfoList* = Call_GetDeployedServiceTypeInfoList_569330(
    name: "getDeployedServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes",
    validator: validate_GetDeployedServiceTypeInfoList_569331, base: "",
    url: url_GetDeployedServiceTypeInfoList_569332,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoByName_569342 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServiceTypeInfoByName_569344(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceTypeName" in path, "`serviceTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes/"),
               (kind: VariableSegment, value: "serviceTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoByName_569343(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceTypeName: JString (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `serviceTypeName` field"
  var valid_569345 = path.getOrDefault("serviceTypeName")
  valid_569345 = validateParameter(valid_569345, JString, required = true,
                                 default = nil)
  if valid_569345 != nil:
    section.add "serviceTypeName", valid_569345
  var valid_569346 = path.getOrDefault("nodeName")
  valid_569346 = validateParameter(valid_569346, JString, required = true,
                                 default = nil)
  if valid_569346 != nil:
    section.add "nodeName", valid_569346
  var valid_569347 = path.getOrDefault("applicationId")
  valid_569347 = validateParameter(valid_569347, JString, required = true,
                                 default = nil)
  if valid_569347 != nil:
    section.add "applicationId", valid_569347
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  var valid_569348 = query.getOrDefault("timeout")
  valid_569348 = validateParameter(valid_569348, JInt, required = false,
                                 default = newJInt(60))
  if valid_569348 != nil:
    section.add "timeout", valid_569348
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569349 = query.getOrDefault("api-version")
  valid_569349 = validateParameter(valid_569349, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569349 != nil:
    section.add "api-version", valid_569349
  var valid_569350 = query.getOrDefault("ServiceManifestName")
  valid_569350 = validateParameter(valid_569350, JString, required = false,
                                 default = nil)
  if valid_569350 != nil:
    section.add "ServiceManifestName", valid_569350
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569351: Call_GetDeployedServiceTypeInfoByName_569342;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  let valid = call_569351.validator(path, query, header, formData, body)
  let scheme = call_569351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569351.url(scheme.get, call_569351.host, call_569351.base,
                         call_569351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569351, url, valid)

proc call*(call_569352: Call_GetDeployedServiceTypeInfoByName_569342;
          serviceTypeName: string; nodeName: string; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoByName
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceTypeName: string (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569353 = newJObject()
  var query_569354 = newJObject()
  add(query_569354, "timeout", newJInt(timeout))
  add(path_569353, "serviceTypeName", newJString(serviceTypeName))
  add(query_569354, "api-version", newJString(apiVersion))
  add(path_569353, "nodeName", newJString(nodeName))
  add(query_569354, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_569353, "applicationId", newJString(applicationId))
  result = call_569352.call(path_569353, query_569354, nil, nil, nil)

var getDeployedServiceTypeInfoByName* = Call_GetDeployedServiceTypeInfoByName_569342(
    name: "getDeployedServiceTypeInfoByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}",
    validator: validate_GetDeployedServiceTypeInfoByName_569343, base: "",
    url: url_GetDeployedServiceTypeInfoByName_569344,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedApplicationHealth_569355 = ref object of OpenApiRestCall_567667
proc url_ReportDeployedApplicationHealth_569357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedApplicationHealth_569356(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569358 = path.getOrDefault("nodeName")
  valid_569358 = validateParameter(valid_569358, JString, required = true,
                                 default = nil)
  if valid_569358 != nil:
    section.add "nodeName", valid_569358
  var valid_569359 = path.getOrDefault("applicationId")
  valid_569359 = validateParameter(valid_569359, JString, required = true,
                                 default = nil)
  if valid_569359 != nil:
    section.add "applicationId", valid_569359
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569360 = query.getOrDefault("Immediate")
  valid_569360 = validateParameter(valid_569360, JBool, required = false,
                                 default = newJBool(false))
  if valid_569360 != nil:
    section.add "Immediate", valid_569360
  var valid_569361 = query.getOrDefault("timeout")
  valid_569361 = validateParameter(valid_569361, JInt, required = false,
                                 default = newJInt(60))
  if valid_569361 != nil:
    section.add "timeout", valid_569361
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569362 = query.getOrDefault("api-version")
  valid_569362 = validateParameter(valid_569362, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569362 != nil:
    section.add "api-version", valid_569362
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569364: Call_ReportDeployedApplicationHealth_569355;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569364.validator(path, query, header, formData, body)
  let scheme = call_569364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569364.url(scheme.get, call_569364.host, call_569364.base,
                         call_569364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569364, url, valid)

proc call*(call_569365: Call_ReportDeployedApplicationHealth_569355;
          nodeName: string; HealthInformation: JsonNode; applicationId: string;
          Immediate: bool = false; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportDeployedApplicationHealth
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_569366 = newJObject()
  var query_569367 = newJObject()
  var body_569368 = newJObject()
  add(query_569367, "Immediate", newJBool(Immediate))
  add(query_569367, "timeout", newJInt(timeout))
  add(query_569367, "api-version", newJString(apiVersion))
  add(path_569366, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_569368 = HealthInformation
  add(path_569366, "applicationId", newJString(applicationId))
  result = call_569365.call(path_569366, query_569367, nil, nil, body_569368)

var reportDeployedApplicationHealth* = Call_ReportDeployedApplicationHealth_569355(
    name: "reportDeployedApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth",
    validator: validate_ReportDeployedApplicationHealth_569356, base: "",
    url: url_ReportDeployedApplicationHealth_569357,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealthUsingPolicy_569380 = ref object of OpenApiRestCall_567667
proc url_GetNodeHealthUsingPolicy_569382(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealthUsingPolicy_569381(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569383 = path.getOrDefault("nodeName")
  valid_569383 = validateParameter(valid_569383, JString, required = true,
                                 default = nil)
  if valid_569383 != nil:
    section.add "nodeName", valid_569383
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569384 = query.getOrDefault("timeout")
  valid_569384 = validateParameter(valid_569384, JInt, required = false,
                                 default = newJInt(60))
  if valid_569384 != nil:
    section.add "timeout", valid_569384
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569385 = query.getOrDefault("api-version")
  valid_569385 = validateParameter(valid_569385, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569385 != nil:
    section.add "api-version", valid_569385
  var valid_569386 = query.getOrDefault("EventsHealthStateFilter")
  valid_569386 = validateParameter(valid_569386, JInt, required = false,
                                 default = newJInt(0))
  if valid_569386 != nil:
    section.add "EventsHealthStateFilter", valid_569386
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569388: Call_GetNodeHealthUsingPolicy_569380; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_569388.validator(path, query, header, formData, body)
  let scheme = call_569388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569388.url(scheme.get, call_569388.host, call_569388.base,
                         call_569388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569388, url, valid)

proc call*(call_569389: Call_GetNodeHealthUsingPolicy_569380; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0; ClusterHealthPolicy: JsonNode = nil): Recallable =
  ## getNodeHealthUsingPolicy
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  var path_569390 = newJObject()
  var query_569391 = newJObject()
  var body_569392 = newJObject()
  add(query_569391, "timeout", newJInt(timeout))
  add(query_569391, "api-version", newJString(apiVersion))
  add(path_569390, "nodeName", newJString(nodeName))
  add(query_569391, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  if ClusterHealthPolicy != nil:
    body_569392 = ClusterHealthPolicy
  result = call_569389.call(path_569390, query_569391, nil, nil, body_569392)

var getNodeHealthUsingPolicy* = Call_GetNodeHealthUsingPolicy_569380(
    name: "getNodeHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetHealth",
    validator: validate_GetNodeHealthUsingPolicy_569381, base: "",
    url: url_GetNodeHealthUsingPolicy_569382, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealth_569369 = ref object of OpenApiRestCall_567667
proc url_GetNodeHealth_569371(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealth_569370(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569372 = path.getOrDefault("nodeName")
  valid_569372 = validateParameter(valid_569372, JString, required = true,
                                 default = nil)
  if valid_569372 != nil:
    section.add "nodeName", valid_569372
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569373 = query.getOrDefault("timeout")
  valid_569373 = validateParameter(valid_569373, JInt, required = false,
                                 default = newJInt(60))
  if valid_569373 != nil:
    section.add "timeout", valid_569373
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569374 = query.getOrDefault("api-version")
  valid_569374 = validateParameter(valid_569374, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569374 != nil:
    section.add "api-version", valid_569374
  var valid_569375 = query.getOrDefault("EventsHealthStateFilter")
  valid_569375 = validateParameter(valid_569375, JInt, required = false,
                                 default = newJInt(0))
  if valid_569375 != nil:
    section.add "EventsHealthStateFilter", valid_569375
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569376: Call_GetNodeHealth_569369; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_569376.validator(path, query, header, formData, body)
  let scheme = call_569376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569376.url(scheme.get, call_569376.host, call_569376.base,
                         call_569376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569376, url, valid)

proc call*(call_569377: Call_GetNodeHealth_569369; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getNodeHealth
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_569378 = newJObject()
  var query_569379 = newJObject()
  add(query_569379, "timeout", newJInt(timeout))
  add(query_569379, "api-version", newJString(apiVersion))
  add(path_569378, "nodeName", newJString(nodeName))
  add(query_569379, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_569377.call(path_569378, query_569379, nil, nil, nil)

var getNodeHealth* = Call_GetNodeHealth_569369(name: "getNodeHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetHealth", validator: validate_GetNodeHealth_569370,
    base: "", url: url_GetNodeHealth_569371, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeLoadInfo_569393 = ref object of OpenApiRestCall_567667
proc url_GetNodeLoadInfo_569395(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeLoadInfo_569394(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the load information of a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569396 = path.getOrDefault("nodeName")
  valid_569396 = validateParameter(valid_569396, JString, required = true,
                                 default = nil)
  if valid_569396 != nil:
    section.add "nodeName", valid_569396
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569397 = query.getOrDefault("timeout")
  valid_569397 = validateParameter(valid_569397, JInt, required = false,
                                 default = newJInt(60))
  if valid_569397 != nil:
    section.add "timeout", valid_569397
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569398 = query.getOrDefault("api-version")
  valid_569398 = validateParameter(valid_569398, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569398 != nil:
    section.add "api-version", valid_569398
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569399: Call_GetNodeLoadInfo_569393; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the load information of a Service Fabric node.
  ## 
  let valid = call_569399.validator(path, query, header, formData, body)
  let scheme = call_569399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569399.url(scheme.get, call_569399.host, call_569399.base,
                         call_569399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569399, url, valid)

proc call*(call_569400: Call_GetNodeLoadInfo_569393; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNodeLoadInfo
  ## Gets the load information of a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_569401 = newJObject()
  var query_569402 = newJObject()
  add(query_569402, "timeout", newJInt(timeout))
  add(query_569402, "api-version", newJString(apiVersion))
  add(path_569401, "nodeName", newJString(nodeName))
  result = call_569400.call(path_569401, query_569402, nil, nil, nil)

var getNodeLoadInfo* = Call_GetNodeLoadInfo_569393(name: "getNodeLoadInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetLoadInformation",
    validator: validate_GetNodeLoadInfo_569394, base: "", url: url_GetNodeLoadInfo_569395,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfoByPartitionId_569403 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServiceReplicaDetailInfoByPartitionId_569405(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfoByPartitionId_569404(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569406 = path.getOrDefault("nodeName")
  valid_569406 = validateParameter(valid_569406, JString, required = true,
                                 default = nil)
  if valid_569406 != nil:
    section.add "nodeName", valid_569406
  var valid_569407 = path.getOrDefault("partitionId")
  valid_569407 = validateParameter(valid_569407, JString, required = true,
                                 default = nil)
  if valid_569407 != nil:
    section.add "partitionId", valid_569407
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569408 = query.getOrDefault("timeout")
  valid_569408 = validateParameter(valid_569408, JInt, required = false,
                                 default = newJInt(60))
  if valid_569408 != nil:
    section.add "timeout", valid_569408
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569409 = query.getOrDefault("api-version")
  valid_569409 = validateParameter(valid_569409, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569409 != nil:
    section.add "api-version", valid_569409
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569410: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_569403;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_569410.validator(path, query, header, formData, body)
  let scheme = call_569410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569410.url(scheme.get, call_569410.host, call_569410.base,
                         call_569410.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569410, url, valid)

proc call*(call_569411: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_569403;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServiceReplicaDetailInfoByPartitionId
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569412 = newJObject()
  var query_569413 = newJObject()
  add(query_569413, "timeout", newJInt(timeout))
  add(query_569413, "api-version", newJString(apiVersion))
  add(path_569412, "nodeName", newJString(nodeName))
  add(path_569412, "partitionId", newJString(partitionId))
  result = call_569411.call(path_569412, query_569413, nil, nil, nil)

var getDeployedServiceReplicaDetailInfoByPartitionId* = Call_GetDeployedServiceReplicaDetailInfoByPartitionId_569403(
    name: "getDeployedServiceReplicaDetailInfoByPartitionId",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaDetailInfoByPartitionId_569404,
    base: "", url: url_GetDeployedServiceReplicaDetailInfoByPartitionId_569405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveReplica_569414 = ref object of OpenApiRestCall_567667
proc url_RemoveReplica_569416(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveReplica_569415(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569417 = path.getOrDefault("replicaId")
  valid_569417 = validateParameter(valid_569417, JString, required = true,
                                 default = nil)
  if valid_569417 != nil:
    section.add "replicaId", valid_569417
  var valid_569418 = path.getOrDefault("nodeName")
  valid_569418 = validateParameter(valid_569418, JString, required = true,
                                 default = nil)
  if valid_569418 != nil:
    section.add "nodeName", valid_569418
  var valid_569419 = path.getOrDefault("partitionId")
  valid_569419 = validateParameter(valid_569419, JString, required = true,
                                 default = nil)
  if valid_569419 != nil:
    section.add "partitionId", valid_569419
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_569420 = query.getOrDefault("timeout")
  valid_569420 = validateParameter(valid_569420, JInt, required = false,
                                 default = newJInt(60))
  if valid_569420 != nil:
    section.add "timeout", valid_569420
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569421 = query.getOrDefault("api-version")
  valid_569421 = validateParameter(valid_569421, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569421 != nil:
    section.add "api-version", valid_569421
  var valid_569422 = query.getOrDefault("ForceRemove")
  valid_569422 = validateParameter(valid_569422, JBool, required = false, default = nil)
  if valid_569422 != nil:
    section.add "ForceRemove", valid_569422
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569423: Call_RemoveReplica_569414; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  let valid = call_569423.validator(path, query, header, formData, body)
  let scheme = call_569423.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569423.url(scheme.get, call_569423.host, call_569423.base,
                         call_569423.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569423, url, valid)

proc call*(call_569424: Call_RemoveReplica_569414; replicaId: string;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## removeReplica
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569425 = newJObject()
  var query_569426 = newJObject()
  add(path_569425, "replicaId", newJString(replicaId))
  add(query_569426, "timeout", newJInt(timeout))
  add(query_569426, "api-version", newJString(apiVersion))
  add(query_569426, "ForceRemove", newJBool(ForceRemove))
  add(path_569425, "nodeName", newJString(nodeName))
  add(path_569425, "partitionId", newJString(partitionId))
  result = call_569424.call(path_569425, query_569426, nil, nil, nil)

var removeReplica* = Call_RemoveReplica_569414(name: "removeReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete",
    validator: validate_RemoveReplica_569415, base: "", url: url_RemoveReplica_569416,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfo_569427 = ref object of OpenApiRestCall_567667
proc url_GetDeployedServiceReplicaDetailInfo_569429(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetDetail")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfo_569428(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569430 = path.getOrDefault("replicaId")
  valid_569430 = validateParameter(valid_569430, JString, required = true,
                                 default = nil)
  if valid_569430 != nil:
    section.add "replicaId", valid_569430
  var valid_569431 = path.getOrDefault("nodeName")
  valid_569431 = validateParameter(valid_569431, JString, required = true,
                                 default = nil)
  if valid_569431 != nil:
    section.add "nodeName", valid_569431
  var valid_569432 = path.getOrDefault("partitionId")
  valid_569432 = validateParameter(valid_569432, JString, required = true,
                                 default = nil)
  if valid_569432 != nil:
    section.add "partitionId", valid_569432
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569433 = query.getOrDefault("timeout")
  valid_569433 = validateParameter(valid_569433, JInt, required = false,
                                 default = newJInt(60))
  if valid_569433 != nil:
    section.add "timeout", valid_569433
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569434 = query.getOrDefault("api-version")
  valid_569434 = validateParameter(valid_569434, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569434 != nil:
    section.add "api-version", valid_569434
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569435: Call_GetDeployedServiceReplicaDetailInfo_569427;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_569435.validator(path, query, header, formData, body)
  let scheme = call_569435.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569435.url(scheme.get, call_569435.host, call_569435.base,
                         call_569435.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569435, url, valid)

proc call*(call_569436: Call_GetDeployedServiceReplicaDetailInfo_569427;
          replicaId: string; nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServiceReplicaDetailInfo
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569437 = newJObject()
  var query_569438 = newJObject()
  add(path_569437, "replicaId", newJString(replicaId))
  add(query_569438, "timeout", newJInt(timeout))
  add(query_569438, "api-version", newJString(apiVersion))
  add(path_569437, "nodeName", newJString(nodeName))
  add(path_569437, "partitionId", newJString(partitionId))
  result = call_569436.call(path_569437, query_569438, nil, nil, nil)

var getDeployedServiceReplicaDetailInfo* = Call_GetDeployedServiceReplicaDetailInfo_569427(
    name: "getDeployedServiceReplicaDetailInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail",
    validator: validate_GetDeployedServiceReplicaDetailInfo_569428, base: "",
    url: url_GetDeployedServiceReplicaDetailInfo_569429,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartReplica_569439 = ref object of OpenApiRestCall_567667
proc url_RestartReplica_569441(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartReplica_569440(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569442 = path.getOrDefault("replicaId")
  valid_569442 = validateParameter(valid_569442, JString, required = true,
                                 default = nil)
  if valid_569442 != nil:
    section.add "replicaId", valid_569442
  var valid_569443 = path.getOrDefault("nodeName")
  valid_569443 = validateParameter(valid_569443, JString, required = true,
                                 default = nil)
  if valid_569443 != nil:
    section.add "nodeName", valid_569443
  var valid_569444 = path.getOrDefault("partitionId")
  valid_569444 = validateParameter(valid_569444, JString, required = true,
                                 default = nil)
  if valid_569444 != nil:
    section.add "partitionId", valid_569444
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569445 = query.getOrDefault("timeout")
  valid_569445 = validateParameter(valid_569445, JInt, required = false,
                                 default = newJInt(60))
  if valid_569445 != nil:
    section.add "timeout", valid_569445
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569446 = query.getOrDefault("api-version")
  valid_569446 = validateParameter(valid_569446, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569446 != nil:
    section.add "api-version", valid_569446
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569447: Call_RestartReplica_569439; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  let valid = call_569447.validator(path, query, header, formData, body)
  let scheme = call_569447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569447.url(scheme.get, call_569447.host, call_569447.base,
                         call_569447.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569447, url, valid)

proc call*(call_569448: Call_RestartReplica_569439; replicaId: string;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## restartReplica
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569449 = newJObject()
  var query_569450 = newJObject()
  add(path_569449, "replicaId", newJString(replicaId))
  add(query_569450, "timeout", newJInt(timeout))
  add(query_569450, "api-version", newJString(apiVersion))
  add(path_569449, "nodeName", newJString(nodeName))
  add(path_569449, "partitionId", newJString(partitionId))
  result = call_569448.call(path_569449, query_569450, nil, nil, nil)

var restartReplica* = Call_RestartReplica_569439(name: "restartReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart",
    validator: validate_RestartReplica_569440, base: "", url: url_RestartReplica_569441,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveNodeState_569451 = ref object of OpenApiRestCall_567667
proc url_RemoveNodeState_569453(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/RemoveNodeState")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveNodeState_569452(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569454 = path.getOrDefault("nodeName")
  valid_569454 = validateParameter(valid_569454, JString, required = true,
                                 default = nil)
  if valid_569454 != nil:
    section.add "nodeName", valid_569454
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569455 = query.getOrDefault("timeout")
  valid_569455 = validateParameter(valid_569455, JInt, required = false,
                                 default = newJInt(60))
  if valid_569455 != nil:
    section.add "timeout", valid_569455
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569456 = query.getOrDefault("api-version")
  valid_569456 = validateParameter(valid_569456, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569456 != nil:
    section.add "api-version", valid_569456
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569457: Call_RemoveNodeState_569451; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  let valid = call_569457.validator(path, query, header, formData, body)
  let scheme = call_569457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569457.url(scheme.get, call_569457.host, call_569457.base,
                         call_569457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569457, url, valid)

proc call*(call_569458: Call_RemoveNodeState_569451; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## removeNodeState
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_569459 = newJObject()
  var query_569460 = newJObject()
  add(query_569460, "timeout", newJInt(timeout))
  add(query_569460, "api-version", newJString(apiVersion))
  add(path_569459, "nodeName", newJString(nodeName))
  result = call_569458.call(path_569459, query_569460, nil, nil, nil)

var removeNodeState* = Call_RemoveNodeState_569451(name: "removeNodeState",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/RemoveNodeState",
    validator: validate_RemoveNodeState_569452, base: "", url: url_RemoveNodeState_569453,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportNodeHealth_569461 = ref object of OpenApiRestCall_567667
proc url_ReportNodeHealth_569463(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportNodeHealth_569462(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569464 = path.getOrDefault("nodeName")
  valid_569464 = validateParameter(valid_569464, JString, required = true,
                                 default = nil)
  if valid_569464 != nil:
    section.add "nodeName", valid_569464
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569465 = query.getOrDefault("Immediate")
  valid_569465 = validateParameter(valid_569465, JBool, required = false,
                                 default = newJBool(false))
  if valid_569465 != nil:
    section.add "Immediate", valid_569465
  var valid_569466 = query.getOrDefault("timeout")
  valid_569466 = validateParameter(valid_569466, JInt, required = false,
                                 default = newJInt(60))
  if valid_569466 != nil:
    section.add "timeout", valid_569466
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569467 = query.getOrDefault("api-version")
  valid_569467 = validateParameter(valid_569467, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569467 != nil:
    section.add "api-version", valid_569467
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569469: Call_ReportNodeHealth_569461; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569469.validator(path, query, header, formData, body)
  let scheme = call_569469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569469.url(scheme.get, call_569469.host, call_569469.base,
                         call_569469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569469, url, valid)

proc call*(call_569470: Call_ReportNodeHealth_569461; nodeName: string;
          HealthInformation: JsonNode; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportNodeHealth
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  var path_569471 = newJObject()
  var query_569472 = newJObject()
  var body_569473 = newJObject()
  add(query_569472, "Immediate", newJBool(Immediate))
  add(query_569472, "timeout", newJInt(timeout))
  add(query_569472, "api-version", newJString(apiVersion))
  add(path_569471, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_569473 = HealthInformation
  result = call_569470.call(path_569471, query_569472, nil, nil, body_569473)

var reportNodeHealth* = Call_ReportNodeHealth_569461(name: "reportNodeHealth",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/ReportHealth",
    validator: validate_ReportNodeHealth_569462, base: "",
    url: url_ReportNodeHealth_569463, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartNode_569474 = ref object of OpenApiRestCall_567667
proc url_RestartNode_569476(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartNode_569475(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_569477 = path.getOrDefault("nodeName")
  valid_569477 = validateParameter(valid_569477, JString, required = true,
                                 default = nil)
  if valid_569477 != nil:
    section.add "nodeName", valid_569477
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569478 = query.getOrDefault("timeout")
  valid_569478 = validateParameter(valid_569478, JInt, required = false,
                                 default = newJInt(60))
  if valid_569478 != nil:
    section.add "timeout", valid_569478
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569479 = query.getOrDefault("api-version")
  valid_569479 = validateParameter(valid_569479, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569479 != nil:
    section.add "api-version", valid_569479
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569481: Call_RestartNode_569474; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  let valid = call_569481.validator(path, query, header, formData, body)
  let scheme = call_569481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569481.url(scheme.get, call_569481.host, call_569481.base,
                         call_569481.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569481, url, valid)

proc call*(call_569482: Call_RestartNode_569474; nodeName: string;
          RestartNodeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## restartNode
  ## Restarts a Service Fabric cluster node that is already started.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  var path_569483 = newJObject()
  var query_569484 = newJObject()
  var body_569485 = newJObject()
  add(query_569484, "timeout", newJInt(timeout))
  add(query_569484, "api-version", newJString(apiVersion))
  add(path_569483, "nodeName", newJString(nodeName))
  if RestartNodeDescription != nil:
    body_569485 = RestartNodeDescription
  result = call_569482.call(path_569483, query_569484, nil, nil, body_569485)

var restartNode* = Call_RestartNode_569474(name: "restartNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}/$/Restart",
                                        validator: validate_RestartNode_569475,
                                        base: "", url: url_RestartNode_569476,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfo_569486 = ref object of OpenApiRestCall_567667
proc url_GetPartitionInfo_569488(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfo_569487(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569489 = path.getOrDefault("partitionId")
  valid_569489 = validateParameter(valid_569489, JString, required = true,
                                 default = nil)
  if valid_569489 != nil:
    section.add "partitionId", valid_569489
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569490 = query.getOrDefault("timeout")
  valid_569490 = validateParameter(valid_569490, JInt, required = false,
                                 default = newJInt(60))
  if valid_569490 != nil:
    section.add "timeout", valid_569490
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569491 = query.getOrDefault("api-version")
  valid_569491 = validateParameter(valid_569491, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569491 != nil:
    section.add "api-version", valid_569491
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569492: Call_GetPartitionInfo_569486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_569492.validator(path, query, header, formData, body)
  let scheme = call_569492.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569492.url(scheme.get, call_569492.host, call_569492.base,
                         call_569492.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569492, url, valid)

proc call*(call_569493: Call_GetPartitionInfo_569486; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionInfo
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569494 = newJObject()
  var query_569495 = newJObject()
  add(query_569495, "timeout", newJInt(timeout))
  add(query_569495, "api-version", newJString(apiVersion))
  add(path_569494, "partitionId", newJString(partitionId))
  result = call_569493.call(path_569494, query_569495, nil, nil, nil)

var getPartitionInfo* = Call_GetPartitionInfo_569486(name: "getPartitionInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}", validator: validate_GetPartitionInfo_569487,
    base: "", url: url_GetPartitionInfo_569488, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealthUsingPolicy_569509 = ref object of OpenApiRestCall_567667
proc url_GetPartitionHealthUsingPolicy_569511(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealthUsingPolicy_569510(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569512 = path.getOrDefault("partitionId")
  valid_569512 = validateParameter(valid_569512, JString, required = true,
                                 default = nil)
  if valid_569512 != nil:
    section.add "partitionId", valid_569512
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569513 = query.getOrDefault("timeout")
  valid_569513 = validateParameter(valid_569513, JInt, required = false,
                                 default = newJInt(60))
  if valid_569513 != nil:
    section.add "timeout", valid_569513
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569514 = query.getOrDefault("api-version")
  valid_569514 = validateParameter(valid_569514, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569514 != nil:
    section.add "api-version", valid_569514
  var valid_569515 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_569515 = validateParameter(valid_569515, JInt, required = false,
                                 default = newJInt(0))
  if valid_569515 != nil:
    section.add "ReplicasHealthStateFilter", valid_569515
  var valid_569516 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569516 = validateParameter(valid_569516, JBool, required = false,
                                 default = newJBool(false))
  if valid_569516 != nil:
    section.add "ExcludeHealthStatistics", valid_569516
  var valid_569517 = query.getOrDefault("EventsHealthStateFilter")
  valid_569517 = validateParameter(valid_569517, JInt, required = false,
                                 default = newJInt(0))
  if valid_569517 != nil:
    section.add "EventsHealthStateFilter", valid_569517
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569519: Call_GetPartitionHealthUsingPolicy_569509; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_569519.validator(path, query, header, formData, body)
  let scheme = call_569519.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569519.url(scheme.get, call_569519.host, call_569519.base,
                         call_569519.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569519, url, valid)

proc call*(call_569520: Call_GetPartitionHealthUsingPolicy_569509;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ReplicasHealthStateFilter: int = 0;
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealthUsingPolicy
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569521 = newJObject()
  var query_569522 = newJObject()
  var body_569523 = newJObject()
  add(query_569522, "timeout", newJInt(timeout))
  add(query_569522, "api-version", newJString(apiVersion))
  add(query_569522, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  if ApplicationHealthPolicy != nil:
    body_569523 = ApplicationHealthPolicy
  add(query_569522, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569522, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569521, "partitionId", newJString(partitionId))
  result = call_569520.call(path_569521, query_569522, nil, nil, body_569523)

var getPartitionHealthUsingPolicy* = Call_GetPartitionHealthUsingPolicy_569509(
    name: "getPartitionHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealthUsingPolicy_569510, base: "",
    url: url_GetPartitionHealthUsingPolicy_569511,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealth_569496 = ref object of OpenApiRestCall_567667
proc url_GetPartitionHealth_569498(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealth_569497(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569499 = path.getOrDefault("partitionId")
  valid_569499 = validateParameter(valid_569499, JString, required = true,
                                 default = nil)
  if valid_569499 != nil:
    section.add "partitionId", valid_569499
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569500 = query.getOrDefault("timeout")
  valid_569500 = validateParameter(valid_569500, JInt, required = false,
                                 default = newJInt(60))
  if valid_569500 != nil:
    section.add "timeout", valid_569500
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569501 = query.getOrDefault("api-version")
  valid_569501 = validateParameter(valid_569501, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569501 != nil:
    section.add "api-version", valid_569501
  var valid_569502 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_569502 = validateParameter(valid_569502, JInt, required = false,
                                 default = newJInt(0))
  if valid_569502 != nil:
    section.add "ReplicasHealthStateFilter", valid_569502
  var valid_569503 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569503 = validateParameter(valid_569503, JBool, required = false,
                                 default = newJBool(false))
  if valid_569503 != nil:
    section.add "ExcludeHealthStatistics", valid_569503
  var valid_569504 = query.getOrDefault("EventsHealthStateFilter")
  valid_569504 = validateParameter(valid_569504, JInt, required = false,
                                 default = newJInt(0))
  if valid_569504 != nil:
    section.add "EventsHealthStateFilter", valid_569504
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569505: Call_GetPartitionHealth_569496; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_569505.validator(path, query, header, formData, body)
  let scheme = call_569505.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569505.url(scheme.get, call_569505.host, call_569505.base,
                         call_569505.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569505, url, valid)

proc call*(call_569506: Call_GetPartitionHealth_569496; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ReplicasHealthStateFilter: int = 0; ExcludeHealthStatistics: bool = false;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealth
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569507 = newJObject()
  var query_569508 = newJObject()
  add(query_569508, "timeout", newJInt(timeout))
  add(query_569508, "api-version", newJString(apiVersion))
  add(query_569508, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  add(query_569508, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569508, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569507, "partitionId", newJString(partitionId))
  result = call_569506.call(path_569507, query_569508, nil, nil, nil)

var getPartitionHealth* = Call_GetPartitionHealth_569496(
    name: "getPartitionHealth", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealth_569497, base: "",
    url: url_GetPartitionHealth_569498, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionLoadInformation_569524 = ref object of OpenApiRestCall_567667
proc url_GetPartitionLoadInformation_569526(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionLoadInformation_569525(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569527 = path.getOrDefault("partitionId")
  valid_569527 = validateParameter(valid_569527, JString, required = true,
                                 default = nil)
  if valid_569527 != nil:
    section.add "partitionId", valid_569527
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569528 = query.getOrDefault("timeout")
  valid_569528 = validateParameter(valid_569528, JInt, required = false,
                                 default = newJInt(60))
  if valid_569528 != nil:
    section.add "timeout", valid_569528
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569529 = query.getOrDefault("api-version")
  valid_569529 = validateParameter(valid_569529, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569529 != nil:
    section.add "api-version", valid_569529
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569530: Call_GetPartitionLoadInformation_569524; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  let valid = call_569530.validator(path, query, header, formData, body)
  let scheme = call_569530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569530.url(scheme.get, call_569530.host, call_569530.base,
                         call_569530.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569530, url, valid)

proc call*(call_569531: Call_GetPartitionLoadInformation_569524;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionLoadInformation
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569532 = newJObject()
  var query_569533 = newJObject()
  add(query_569533, "timeout", newJInt(timeout))
  add(query_569533, "api-version", newJString(apiVersion))
  add(path_569532, "partitionId", newJString(partitionId))
  result = call_569531.call(path_569532, query_569533, nil, nil, nil)

var getPartitionLoadInformation* = Call_GetPartitionLoadInformation_569524(
    name: "getPartitionLoadInformation", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetLoadInformation",
    validator: validate_GetPartitionLoadInformation_569525, base: "",
    url: url_GetPartitionLoadInformation_569526,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfoList_569534 = ref object of OpenApiRestCall_567667
proc url_GetReplicaInfoList_569536(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfoList_569535(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569537 = path.getOrDefault("partitionId")
  valid_569537 = validateParameter(valid_569537, JString, required = true,
                                 default = nil)
  if valid_569537 != nil:
    section.add "partitionId", valid_569537
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_569538 = query.getOrDefault("timeout")
  valid_569538 = validateParameter(valid_569538, JInt, required = false,
                                 default = newJInt(60))
  if valid_569538 != nil:
    section.add "timeout", valid_569538
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569539 = query.getOrDefault("api-version")
  valid_569539 = validateParameter(valid_569539, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569539 != nil:
    section.add "api-version", valid_569539
  var valid_569540 = query.getOrDefault("ContinuationToken")
  valid_569540 = validateParameter(valid_569540, JString, required = false,
                                 default = nil)
  if valid_569540 != nil:
    section.add "ContinuationToken", valid_569540
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569541: Call_GetReplicaInfoList_569534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_569541.validator(path, query, header, formData, body)
  let scheme = call_569541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569541.url(scheme.get, call_569541.host, call_569541.base,
                         call_569541.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569541, url, valid)

proc call*(call_569542: Call_GetReplicaInfoList_569534; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = ""): Recallable =
  ## getReplicaInfoList
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_569543 = newJObject()
  var query_569544 = newJObject()
  add(query_569544, "timeout", newJInt(timeout))
  add(query_569544, "api-version", newJString(apiVersion))
  add(path_569543, "partitionId", newJString(partitionId))
  add(query_569544, "ContinuationToken", newJString(ContinuationToken))
  result = call_569542.call(path_569543, query_569544, nil, nil, nil)

var getReplicaInfoList* = Call_GetReplicaInfoList_569534(
    name: "getReplicaInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas",
    validator: validate_GetReplicaInfoList_569535, base: "",
    url: url_GetReplicaInfoList_569536, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfo_569545 = ref object of OpenApiRestCall_567667
proc url_GetReplicaInfo_569547(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfo_569546(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569548 = path.getOrDefault("replicaId")
  valid_569548 = validateParameter(valid_569548, JString, required = true,
                                 default = nil)
  if valid_569548 != nil:
    section.add "replicaId", valid_569548
  var valid_569549 = path.getOrDefault("partitionId")
  valid_569549 = validateParameter(valid_569549, JString, required = true,
                                 default = nil)
  if valid_569549 != nil:
    section.add "partitionId", valid_569549
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_569550 = query.getOrDefault("timeout")
  valid_569550 = validateParameter(valid_569550, JInt, required = false,
                                 default = newJInt(60))
  if valid_569550 != nil:
    section.add "timeout", valid_569550
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569551 = query.getOrDefault("api-version")
  valid_569551 = validateParameter(valid_569551, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569551 != nil:
    section.add "api-version", valid_569551
  var valid_569552 = query.getOrDefault("ContinuationToken")
  valid_569552 = validateParameter(valid_569552, JString, required = false,
                                 default = nil)
  if valid_569552 != nil:
    section.add "ContinuationToken", valid_569552
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569553: Call_GetReplicaInfo_569545; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_569553.validator(path, query, header, formData, body)
  let scheme = call_569553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569553.url(scheme.get, call_569553.host, call_569553.base,
                         call_569553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569553, url, valid)

proc call*(call_569554: Call_GetReplicaInfo_569545; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ContinuationToken: string = ""): Recallable =
  ## getReplicaInfo
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_569555 = newJObject()
  var query_569556 = newJObject()
  add(path_569555, "replicaId", newJString(replicaId))
  add(query_569556, "timeout", newJInt(timeout))
  add(query_569556, "api-version", newJString(apiVersion))
  add(path_569555, "partitionId", newJString(partitionId))
  add(query_569556, "ContinuationToken", newJString(ContinuationToken))
  result = call_569554.call(path_569555, query_569556, nil, nil, nil)

var getReplicaInfo* = Call_GetReplicaInfo_569545(name: "getReplicaInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}",
    validator: validate_GetReplicaInfo_569546, base: "", url: url_GetReplicaInfo_569547,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealthUsingPolicy_569569 = ref object of OpenApiRestCall_567667
proc url_GetReplicaHealthUsingPolicy_569571(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealthUsingPolicy_569570(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569572 = path.getOrDefault("replicaId")
  valid_569572 = validateParameter(valid_569572, JString, required = true,
                                 default = nil)
  if valid_569572 != nil:
    section.add "replicaId", valid_569572
  var valid_569573 = path.getOrDefault("partitionId")
  valid_569573 = validateParameter(valid_569573, JString, required = true,
                                 default = nil)
  if valid_569573 != nil:
    section.add "partitionId", valid_569573
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569574 = query.getOrDefault("timeout")
  valid_569574 = validateParameter(valid_569574, JInt, required = false,
                                 default = newJInt(60))
  if valid_569574 != nil:
    section.add "timeout", valid_569574
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569575 = query.getOrDefault("api-version")
  valid_569575 = validateParameter(valid_569575, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569575 != nil:
    section.add "api-version", valid_569575
  var valid_569576 = query.getOrDefault("EventsHealthStateFilter")
  valid_569576 = validateParameter(valid_569576, JInt, required = false,
                                 default = newJInt(0))
  if valid_569576 != nil:
    section.add "EventsHealthStateFilter", valid_569576
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569578: Call_GetReplicaHealthUsingPolicy_569569; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  let valid = call_569578.validator(path, query, header, formData, body)
  let scheme = call_569578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569578.url(scheme.get, call_569578.host, call_569578.base,
                         call_569578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569578, url, valid)

proc call*(call_569579: Call_GetReplicaHealthUsingPolicy_569569; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil; EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealthUsingPolicy
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569580 = newJObject()
  var query_569581 = newJObject()
  var body_569582 = newJObject()
  add(path_569580, "replicaId", newJString(replicaId))
  add(query_569581, "timeout", newJInt(timeout))
  add(query_569581, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_569582 = ApplicationHealthPolicy
  add(query_569581, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569580, "partitionId", newJString(partitionId))
  result = call_569579.call(path_569580, query_569581, nil, nil, body_569582)

var getReplicaHealthUsingPolicy* = Call_GetReplicaHealthUsingPolicy_569569(
    name: "getReplicaHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealthUsingPolicy_569570, base: "",
    url: url_GetReplicaHealthUsingPolicy_569571,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealth_569557 = ref object of OpenApiRestCall_567667
proc url_GetReplicaHealth_569559(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealth_569558(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569560 = path.getOrDefault("replicaId")
  valid_569560 = validateParameter(valid_569560, JString, required = true,
                                 default = nil)
  if valid_569560 != nil:
    section.add "replicaId", valid_569560
  var valid_569561 = path.getOrDefault("partitionId")
  valid_569561 = validateParameter(valid_569561, JString, required = true,
                                 default = nil)
  if valid_569561 != nil:
    section.add "partitionId", valid_569561
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569562 = query.getOrDefault("timeout")
  valid_569562 = validateParameter(valid_569562, JInt, required = false,
                                 default = newJInt(60))
  if valid_569562 != nil:
    section.add "timeout", valid_569562
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569563 = query.getOrDefault("api-version")
  valid_569563 = validateParameter(valid_569563, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569563 != nil:
    section.add "api-version", valid_569563
  var valid_569564 = query.getOrDefault("EventsHealthStateFilter")
  valid_569564 = validateParameter(valid_569564, JInt, required = false,
                                 default = newJInt(0))
  if valid_569564 != nil:
    section.add "EventsHealthStateFilter", valid_569564
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569565: Call_GetReplicaHealth_569557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  let valid = call_569565.validator(path, query, header, formData, body)
  let scheme = call_569565.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569565.url(scheme.get, call_569565.host, call_569565.base,
                         call_569565.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569565, url, valid)

proc call*(call_569566: Call_GetReplicaHealth_569557; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealth
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569567 = newJObject()
  var query_569568 = newJObject()
  add(path_569567, "replicaId", newJString(replicaId))
  add(query_569568, "timeout", newJInt(timeout))
  add(query_569568, "api-version", newJString(apiVersion))
  add(query_569568, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569567, "partitionId", newJString(partitionId))
  result = call_569566.call(path_569567, query_569568, nil, nil, nil)

var getReplicaHealth* = Call_GetReplicaHealth_569557(name: "getReplicaHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealth_569558, base: "",
    url: url_GetReplicaHealth_569559, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportReplicaHealth_569583 = ref object of OpenApiRestCall_567667
proc url_ReportReplicaHealth_569585(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportReplicaHealth_569584(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_569586 = path.getOrDefault("replicaId")
  valid_569586 = validateParameter(valid_569586, JString, required = true,
                                 default = nil)
  if valid_569586 != nil:
    section.add "replicaId", valid_569586
  var valid_569587 = path.getOrDefault("partitionId")
  valid_569587 = validateParameter(valid_569587, JString, required = true,
                                 default = nil)
  if valid_569587 != nil:
    section.add "partitionId", valid_569587
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceKind: JString (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  section = newJObject()
  var valid_569588 = query.getOrDefault("Immediate")
  valid_569588 = validateParameter(valid_569588, JBool, required = false,
                                 default = newJBool(false))
  if valid_569588 != nil:
    section.add "Immediate", valid_569588
  var valid_569589 = query.getOrDefault("timeout")
  valid_569589 = validateParameter(valid_569589, JInt, required = false,
                                 default = newJInt(60))
  if valid_569589 != nil:
    section.add "timeout", valid_569589
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569590 = query.getOrDefault("api-version")
  valid_569590 = validateParameter(valid_569590, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569590 != nil:
    section.add "api-version", valid_569590
  var valid_569591 = query.getOrDefault("ServiceKind")
  valid_569591 = validateParameter(valid_569591, JString, required = true,
                                 default = newJString("Stateful"))
  if valid_569591 != nil:
    section.add "ServiceKind", valid_569591
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569593: Call_ReportReplicaHealth_569583; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569593.validator(path, query, header, formData, body)
  let scheme = call_569593.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569593.url(scheme.get, call_569593.host, call_569593.base,
                         call_569593.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569593, url, valid)

proc call*(call_569594: Call_ReportReplicaHealth_569583; replicaId: string;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0";
          ServiceKind: string = "Stateful"): Recallable =
  ## reportReplicaHealth
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ServiceKind: string (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  var path_569595 = newJObject()
  var query_569596 = newJObject()
  var body_569597 = newJObject()
  add(path_569595, "replicaId", newJString(replicaId))
  add(query_569596, "Immediate", newJBool(Immediate))
  add(query_569596, "timeout", newJInt(timeout))
  add(query_569596, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_569597 = HealthInformation
  add(path_569595, "partitionId", newJString(partitionId))
  add(query_569596, "ServiceKind", newJString(ServiceKind))
  result = call_569594.call(path_569595, query_569596, nil, nil, body_569597)

var reportReplicaHealth* = Call_ReportReplicaHealth_569583(
    name: "reportReplicaHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth",
    validator: validate_ReportReplicaHealth_569584, base: "",
    url: url_ReportReplicaHealth_569585, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceNameInfo_569598 = ref object of OpenApiRestCall_567667
proc url_GetServiceNameInfo_569600(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetServiceName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceNameInfo_569599(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569601 = path.getOrDefault("partitionId")
  valid_569601 = validateParameter(valid_569601, JString, required = true,
                                 default = nil)
  if valid_569601 != nil:
    section.add "partitionId", valid_569601
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569602 = query.getOrDefault("timeout")
  valid_569602 = validateParameter(valid_569602, JInt, required = false,
                                 default = newJInt(60))
  if valid_569602 != nil:
    section.add "timeout", valid_569602
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569603 = query.getOrDefault("api-version")
  valid_569603 = validateParameter(valid_569603, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569603 != nil:
    section.add "api-version", valid_569603
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569604: Call_GetServiceNameInfo_569598; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  let valid = call_569604.validator(path, query, header, formData, body)
  let scheme = call_569604.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569604.url(scheme.get, call_569604.host, call_569604.base,
                         call_569604.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569604, url, valid)

proc call*(call_569605: Call_GetServiceNameInfo_569598; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceNameInfo
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569606 = newJObject()
  var query_569607 = newJObject()
  add(query_569607, "timeout", newJInt(timeout))
  add(query_569607, "api-version", newJString(apiVersion))
  add(path_569606, "partitionId", newJString(partitionId))
  result = call_569605.call(path_569606, query_569607, nil, nil, nil)

var getServiceNameInfo* = Call_GetServiceNameInfo_569598(
    name: "getServiceNameInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetServiceName",
    validator: validate_GetServiceNameInfo_569599, base: "",
    url: url_GetServiceNameInfo_569600, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverPartition_569608 = ref object of OpenApiRestCall_567667
proc url_RecoverPartition_569610(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverPartition_569609(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569611 = path.getOrDefault("partitionId")
  valid_569611 = validateParameter(valid_569611, JString, required = true,
                                 default = nil)
  if valid_569611 != nil:
    section.add "partitionId", valid_569611
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569612 = query.getOrDefault("timeout")
  valid_569612 = validateParameter(valid_569612, JInt, required = false,
                                 default = newJInt(60))
  if valid_569612 != nil:
    section.add "timeout", valid_569612
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569613 = query.getOrDefault("api-version")
  valid_569613 = validateParameter(valid_569613, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569613 != nil:
    section.add "api-version", valid_569613
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569614: Call_RecoverPartition_569608; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_569614.validator(path, query, header, formData, body)
  let scheme = call_569614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569614.url(scheme.get, call_569614.host, call_569614.base,
                         call_569614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569614, url, valid)

proc call*(call_569615: Call_RecoverPartition_569608; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## recoverPartition
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569616 = newJObject()
  var query_569617 = newJObject()
  add(query_569617, "timeout", newJInt(timeout))
  add(query_569617, "api-version", newJString(apiVersion))
  add(path_569616, "partitionId", newJString(partitionId))
  result = call_569615.call(path_569616, query_569617, nil, nil, nil)

var recoverPartition* = Call_RecoverPartition_569608(name: "recoverPartition",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/Recover",
    validator: validate_RecoverPartition_569609, base: "",
    url: url_RecoverPartition_569610, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportPartitionHealth_569618 = ref object of OpenApiRestCall_567667
proc url_ReportPartitionHealth_569620(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportPartitionHealth_569619(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569621 = path.getOrDefault("partitionId")
  valid_569621 = validateParameter(valid_569621, JString, required = true,
                                 default = nil)
  if valid_569621 != nil:
    section.add "partitionId", valid_569621
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569622 = query.getOrDefault("Immediate")
  valid_569622 = validateParameter(valid_569622, JBool, required = false,
                                 default = newJBool(false))
  if valid_569622 != nil:
    section.add "Immediate", valid_569622
  var valid_569623 = query.getOrDefault("timeout")
  valid_569623 = validateParameter(valid_569623, JInt, required = false,
                                 default = newJInt(60))
  if valid_569623 != nil:
    section.add "timeout", valid_569623
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569624 = query.getOrDefault("api-version")
  valid_569624 = validateParameter(valid_569624, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569624 != nil:
    section.add "api-version", valid_569624
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569626: Call_ReportPartitionHealth_569618; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569626.validator(path, query, header, formData, body)
  let scheme = call_569626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569626.url(scheme.get, call_569626.host, call_569626.base,
                         call_569626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569626, url, valid)

proc call*(call_569627: Call_ReportPartitionHealth_569618;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportPartitionHealth
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569628 = newJObject()
  var query_569629 = newJObject()
  var body_569630 = newJObject()
  add(query_569629, "Immediate", newJBool(Immediate))
  add(query_569629, "timeout", newJInt(timeout))
  add(query_569629, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_569630 = HealthInformation
  add(path_569628, "partitionId", newJString(partitionId))
  result = call_569627.call(path_569628, query_569629, nil, nil, body_569630)

var reportPartitionHealth* = Call_ReportPartitionHealth_569618(
    name: "reportPartitionHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ReportHealth",
    validator: validate_ReportPartitionHealth_569619, base: "",
    url: url_ReportPartitionHealth_569620, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResetPartitionLoad_569631 = ref object of OpenApiRestCall_567667
proc url_ResetPartitionLoad_569633(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ResetLoad")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResetPartitionLoad_569632(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_569634 = path.getOrDefault("partitionId")
  valid_569634 = validateParameter(valid_569634, JString, required = true,
                                 default = nil)
  if valid_569634 != nil:
    section.add "partitionId", valid_569634
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569635 = query.getOrDefault("timeout")
  valid_569635 = validateParameter(valid_569635, JInt, required = false,
                                 default = newJInt(60))
  if valid_569635 != nil:
    section.add "timeout", valid_569635
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569636 = query.getOrDefault("api-version")
  valid_569636 = validateParameter(valid_569636, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569636 != nil:
    section.add "api-version", valid_569636
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569637: Call_ResetPartitionLoad_569631; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  let valid = call_569637.validator(path, query, header, formData, body)
  let scheme = call_569637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569637.url(scheme.get, call_569637.host, call_569637.base,
                         call_569637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569637, url, valid)

proc call*(call_569638: Call_ResetPartitionLoad_569631; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## resetPartitionLoad
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_569639 = newJObject()
  var query_569640 = newJObject()
  add(query_569640, "timeout", newJInt(timeout))
  add(query_569640, "api-version", newJString(apiVersion))
  add(path_569639, "partitionId", newJString(partitionId))
  result = call_569638.call(path_569639, query_569640, nil, nil, nil)

var resetPartitionLoad* = Call_ResetPartitionLoad_569631(
    name: "resetPartitionLoad", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ResetLoad",
    validator: validate_ResetPartitionLoad_569632, base: "",
    url: url_ResetPartitionLoad_569633, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverServicePartitions_569641 = ref object of OpenApiRestCall_567667
proc url_RecoverServicePartitions_569643(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/$/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverServicePartitions_569642(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569644 = path.getOrDefault("serviceId")
  valid_569644 = validateParameter(valid_569644, JString, required = true,
                                 default = nil)
  if valid_569644 != nil:
    section.add "serviceId", valid_569644
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569645 = query.getOrDefault("timeout")
  valid_569645 = validateParameter(valid_569645, JInt, required = false,
                                 default = newJInt(60))
  if valid_569645 != nil:
    section.add "timeout", valid_569645
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569646 = query.getOrDefault("api-version")
  valid_569646 = validateParameter(valid_569646, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569646 != nil:
    section.add "api-version", valid_569646
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569647: Call_RecoverServicePartitions_569641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_569647.validator(path, query, header, formData, body)
  let scheme = call_569647.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569647.url(scheme.get, call_569647.host, call_569647.base,
                         call_569647.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569647, url, valid)

proc call*(call_569648: Call_RecoverServicePartitions_569641; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## recoverServicePartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569649 = newJObject()
  var query_569650 = newJObject()
  add(query_569650, "timeout", newJInt(timeout))
  add(query_569650, "api-version", newJString(apiVersion))
  add(path_569649, "serviceId", newJString(serviceId))
  result = call_569648.call(path_569649, query_569650, nil, nil, nil)

var recoverServicePartitions* = Call_RecoverServicePartitions_569641(
    name: "recoverServicePartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Services/$/{serviceId}/$/GetPartitions/$/Recover",
    validator: validate_RecoverServicePartitions_569642, base: "",
    url: url_RecoverServicePartitions_569643, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteService_569651 = ref object of OpenApiRestCall_567667
proc url_DeleteService_569653(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteService_569652(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569654 = path.getOrDefault("serviceId")
  valid_569654 = validateParameter(valid_569654, JString, required = true,
                                 default = nil)
  if valid_569654 != nil:
    section.add "serviceId", valid_569654
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_569655 = query.getOrDefault("timeout")
  valid_569655 = validateParameter(valid_569655, JInt, required = false,
                                 default = newJInt(60))
  if valid_569655 != nil:
    section.add "timeout", valid_569655
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569656 = query.getOrDefault("api-version")
  valid_569656 = validateParameter(valid_569656, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569656 != nil:
    section.add "api-version", valid_569656
  var valid_569657 = query.getOrDefault("ForceRemove")
  valid_569657 = validateParameter(valid_569657, JBool, required = false, default = nil)
  if valid_569657 != nil:
    section.add "ForceRemove", valid_569657
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569658: Call_DeleteService_569651; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  let valid = call_569658.validator(path, query, header, formData, body)
  let scheme = call_569658.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569658.url(scheme.get, call_569658.host, call_569658.base,
                         call_569658.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569658, url, valid)

proc call*(call_569659: Call_DeleteService_569651; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## deleteService
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569660 = newJObject()
  var query_569661 = newJObject()
  add(query_569661, "timeout", newJInt(timeout))
  add(query_569661, "api-version", newJString(apiVersion))
  add(query_569661, "ForceRemove", newJBool(ForceRemove))
  add(path_569660, "serviceId", newJString(serviceId))
  result = call_569659.call(path_569660, query_569661, nil, nil, nil)

var deleteService* = Call_DeleteService_569651(name: "deleteService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Delete", validator: validate_DeleteService_569652,
    base: "", url: url_DeleteService_569653, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationNameInfo_569662 = ref object of OpenApiRestCall_567667
proc url_GetApplicationNameInfo_569664(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetApplicationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationNameInfo_569663(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569665 = path.getOrDefault("serviceId")
  valid_569665 = validateParameter(valid_569665, JString, required = true,
                                 default = nil)
  if valid_569665 != nil:
    section.add "serviceId", valid_569665
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569666 = query.getOrDefault("timeout")
  valid_569666 = validateParameter(valid_569666, JInt, required = false,
                                 default = newJInt(60))
  if valid_569666 != nil:
    section.add "timeout", valid_569666
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569667 = query.getOrDefault("api-version")
  valid_569667 = validateParameter(valid_569667, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569667 != nil:
    section.add "api-version", valid_569667
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569668: Call_GetApplicationNameInfo_569662; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  let valid = call_569668.validator(path, query, header, formData, body)
  let scheme = call_569668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569668.url(scheme.get, call_569668.host, call_569668.base,
                         call_569668.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569668, url, valid)

proc call*(call_569669: Call_GetApplicationNameInfo_569662; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationNameInfo
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569670 = newJObject()
  var query_569671 = newJObject()
  add(query_569671, "timeout", newJInt(timeout))
  add(query_569671, "api-version", newJString(apiVersion))
  add(path_569670, "serviceId", newJString(serviceId))
  result = call_569669.call(path_569670, query_569671, nil, nil, nil)

var getApplicationNameInfo* = Call_GetApplicationNameInfo_569662(
    name: "getApplicationNameInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetApplicationName",
    validator: validate_GetApplicationNameInfo_569663, base: "",
    url: url_GetApplicationNameInfo_569664, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceDescription_569672 = ref object of OpenApiRestCall_567667
proc url_GetServiceDescription_569674(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetDescription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceDescription_569673(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569675 = path.getOrDefault("serviceId")
  valid_569675 = validateParameter(valid_569675, JString, required = true,
                                 default = nil)
  if valid_569675 != nil:
    section.add "serviceId", valid_569675
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569676 = query.getOrDefault("timeout")
  valid_569676 = validateParameter(valid_569676, JInt, required = false,
                                 default = newJInt(60))
  if valid_569676 != nil:
    section.add "timeout", valid_569676
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569677 = query.getOrDefault("api-version")
  valid_569677 = validateParameter(valid_569677, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569677 != nil:
    section.add "api-version", valid_569677
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569678: Call_GetServiceDescription_569672; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  let valid = call_569678.validator(path, query, header, formData, body)
  let scheme = call_569678.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569678.url(scheme.get, call_569678.host, call_569678.base,
                         call_569678.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569678, url, valid)

proc call*(call_569679: Call_GetServiceDescription_569672; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceDescription
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569680 = newJObject()
  var query_569681 = newJObject()
  add(query_569681, "timeout", newJInt(timeout))
  add(query_569681, "api-version", newJString(apiVersion))
  add(path_569680, "serviceId", newJString(serviceId))
  result = call_569679.call(path_569680, query_569681, nil, nil, nil)

var getServiceDescription* = Call_GetServiceDescription_569672(
    name: "getServiceDescription", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetDescription",
    validator: validate_GetServiceDescription_569673, base: "",
    url: url_GetServiceDescription_569674, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealthUsingPolicy_569695 = ref object of OpenApiRestCall_567667
proc url_GetServiceHealthUsingPolicy_569697(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealthUsingPolicy_569696(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569698 = path.getOrDefault("serviceId")
  valid_569698 = validateParameter(valid_569698, JString, required = true,
                                 default = nil)
  if valid_569698 != nil:
    section.add "serviceId", valid_569698
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569699 = query.getOrDefault("timeout")
  valid_569699 = validateParameter(valid_569699, JInt, required = false,
                                 default = newJInt(60))
  if valid_569699 != nil:
    section.add "timeout", valid_569699
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569700 = query.getOrDefault("api-version")
  valid_569700 = validateParameter(valid_569700, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569700 != nil:
    section.add "api-version", valid_569700
  var valid_569701 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569701 = validateParameter(valid_569701, JBool, required = false,
                                 default = newJBool(false))
  if valid_569701 != nil:
    section.add "ExcludeHealthStatistics", valid_569701
  var valid_569702 = query.getOrDefault("EventsHealthStateFilter")
  valid_569702 = validateParameter(valid_569702, JInt, required = false,
                                 default = newJInt(0))
  if valid_569702 != nil:
    section.add "EventsHealthStateFilter", valid_569702
  var valid_569703 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_569703 = validateParameter(valid_569703, JInt, required = false,
                                 default = newJInt(0))
  if valid_569703 != nil:
    section.add "PartitionsHealthStateFilter", valid_569703
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569705: Call_GetServiceHealthUsingPolicy_569695; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_569705.validator(path, query, header, formData, body)
  let scheme = call_569705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569705.url(scheme.get, call_569705.host, call_569705.base,
                         call_569705.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569705, url, valid)

proc call*(call_569706: Call_GetServiceHealthUsingPolicy_569695; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          PartitionsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealthUsingPolicy
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_569707 = newJObject()
  var query_569708 = newJObject()
  var body_569709 = newJObject()
  add(query_569708, "timeout", newJInt(timeout))
  add(query_569708, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_569709 = ApplicationHealthPolicy
  add(query_569708, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569708, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569707, "serviceId", newJString(serviceId))
  add(query_569708, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  result = call_569706.call(path_569707, query_569708, nil, nil, body_569709)

var getServiceHealthUsingPolicy* = Call_GetServiceHealthUsingPolicy_569695(
    name: "getServiceHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealthUsingPolicy_569696, base: "",
    url: url_GetServiceHealthUsingPolicy_569697,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealth_569682 = ref object of OpenApiRestCall_567667
proc url_GetServiceHealth_569684(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealth_569683(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569685 = path.getOrDefault("serviceId")
  valid_569685 = validateParameter(valid_569685, JString, required = true,
                                 default = nil)
  if valid_569685 != nil:
    section.add "serviceId", valid_569685
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_569686 = query.getOrDefault("timeout")
  valid_569686 = validateParameter(valid_569686, JInt, required = false,
                                 default = newJInt(60))
  if valid_569686 != nil:
    section.add "timeout", valid_569686
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569687 = query.getOrDefault("api-version")
  valid_569687 = validateParameter(valid_569687, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569687 != nil:
    section.add "api-version", valid_569687
  var valid_569688 = query.getOrDefault("ExcludeHealthStatistics")
  valid_569688 = validateParameter(valid_569688, JBool, required = false,
                                 default = newJBool(false))
  if valid_569688 != nil:
    section.add "ExcludeHealthStatistics", valid_569688
  var valid_569689 = query.getOrDefault("EventsHealthStateFilter")
  valid_569689 = validateParameter(valid_569689, JInt, required = false,
                                 default = newJInt(0))
  if valid_569689 != nil:
    section.add "EventsHealthStateFilter", valid_569689
  var valid_569690 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_569690 = validateParameter(valid_569690, JInt, required = false,
                                 default = newJInt(0))
  if valid_569690 != nil:
    section.add "PartitionsHealthStateFilter", valid_569690
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569691: Call_GetServiceHealth_569682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_569691.validator(path, query, header, formData, body)
  let scheme = call_569691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569691.url(scheme.get, call_569691.host, call_569691.base,
                         call_569691.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569691, url, valid)

proc call*(call_569692: Call_GetServiceHealth_569682; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          PartitionsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealth
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_569693 = newJObject()
  var query_569694 = newJObject()
  add(query_569694, "timeout", newJInt(timeout))
  add(query_569694, "api-version", newJString(apiVersion))
  add(query_569694, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_569694, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_569693, "serviceId", newJString(serviceId))
  add(query_569694, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  result = call_569692.call(path_569693, query_569694, nil, nil, nil)

var getServiceHealth* = Call_GetServiceHealth_569682(name: "getServiceHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealth_569683, base: "",
    url: url_GetServiceHealth_569684, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfoList_569710 = ref object of OpenApiRestCall_567667
proc url_GetPartitionInfoList_569712(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfoList_569711(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569713 = path.getOrDefault("serviceId")
  valid_569713 = validateParameter(valid_569713, JString, required = true,
                                 default = nil)
  if valid_569713 != nil:
    section.add "serviceId", valid_569713
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_569714 = query.getOrDefault("timeout")
  valid_569714 = validateParameter(valid_569714, JInt, required = false,
                                 default = newJInt(60))
  if valid_569714 != nil:
    section.add "timeout", valid_569714
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569715 = query.getOrDefault("api-version")
  valid_569715 = validateParameter(valid_569715, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569715 != nil:
    section.add "api-version", valid_569715
  var valid_569716 = query.getOrDefault("ContinuationToken")
  valid_569716 = validateParameter(valid_569716, JString, required = false,
                                 default = nil)
  if valid_569716 != nil:
    section.add "ContinuationToken", valid_569716
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569717: Call_GetPartitionInfoList_569710; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_569717.validator(path, query, header, formData, body)
  let scheme = call_569717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569717.url(scheme.get, call_569717.host, call_569717.base,
                         call_569717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569717, url, valid)

proc call*(call_569718: Call_GetPartitionInfoList_569710; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = ""): Recallable =
  ## getPartitionInfoList
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_569719 = newJObject()
  var query_569720 = newJObject()
  add(query_569720, "timeout", newJInt(timeout))
  add(query_569720, "api-version", newJString(apiVersion))
  add(path_569719, "serviceId", newJString(serviceId))
  add(query_569720, "ContinuationToken", newJString(ContinuationToken))
  result = call_569718.call(path_569719, query_569720, nil, nil, nil)

var getPartitionInfoList* = Call_GetPartitionInfoList_569710(
    name: "getPartitionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetPartitions",
    validator: validate_GetPartitionInfoList_569711, base: "",
    url: url_GetPartitionInfoList_569712, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportServiceHealth_569721 = ref object of OpenApiRestCall_567667
proc url_ReportServiceHealth_569723(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportServiceHealth_569722(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569724 = path.getOrDefault("serviceId")
  valid_569724 = validateParameter(valid_569724, JString, required = true,
                                 default = nil)
  if valid_569724 != nil:
    section.add "serviceId", valid_569724
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569725 = query.getOrDefault("Immediate")
  valid_569725 = validateParameter(valid_569725, JBool, required = false,
                                 default = newJBool(false))
  if valid_569725 != nil:
    section.add "Immediate", valid_569725
  var valid_569726 = query.getOrDefault("timeout")
  valid_569726 = validateParameter(valid_569726, JInt, required = false,
                                 default = newJInt(60))
  if valid_569726 != nil:
    section.add "timeout", valid_569726
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569727 = query.getOrDefault("api-version")
  valid_569727 = validateParameter(valid_569727, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569727 != nil:
    section.add "api-version", valid_569727
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569729: Call_ReportServiceHealth_569721; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_569729.validator(path, query, header, formData, body)
  let scheme = call_569729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569729.url(scheme.get, call_569729.host, call_569729.base,
                         call_569729.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569729, url, valid)

proc call*(call_569730: Call_ReportServiceHealth_569721;
          HealthInformation: JsonNode; serviceId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportServiceHealth
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569731 = newJObject()
  var query_569732 = newJObject()
  var body_569733 = newJObject()
  add(query_569732, "Immediate", newJBool(Immediate))
  add(query_569732, "timeout", newJInt(timeout))
  add(query_569732, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_569733 = HealthInformation
  add(path_569731, "serviceId", newJString(serviceId))
  result = call_569730.call(path_569731, query_569732, nil, nil, body_569733)

var reportServiceHealth* = Call_ReportServiceHealth_569721(
    name: "reportServiceHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/ReportHealth",
    validator: validate_ReportServiceHealth_569722, base: "",
    url: url_ReportServiceHealth_569723, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResolveService_569734 = ref object of OpenApiRestCall_567667
proc url_ResolveService_569736(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ResolvePartition")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResolveService_569735(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569737 = path.getOrDefault("serviceId")
  valid_569737 = validateParameter(valid_569737, JString, required = true,
                                 default = nil)
  if valid_569737 != nil:
    section.add "serviceId", valid_569737
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyValue: JString
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyType: JInt
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   PreviousRspVersion: JString
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  section = newJObject()
  var valid_569738 = query.getOrDefault("timeout")
  valid_569738 = validateParameter(valid_569738, JInt, required = false,
                                 default = newJInt(60))
  if valid_569738 != nil:
    section.add "timeout", valid_569738
  var valid_569739 = query.getOrDefault("PartitionKeyValue")
  valid_569739 = validateParameter(valid_569739, JString, required = false,
                                 default = nil)
  if valid_569739 != nil:
    section.add "PartitionKeyValue", valid_569739
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569740 = query.getOrDefault("api-version")
  valid_569740 = validateParameter(valid_569740, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569740 != nil:
    section.add "api-version", valid_569740
  var valid_569741 = query.getOrDefault("PartitionKeyType")
  valid_569741 = validateParameter(valid_569741, JInt, required = false, default = nil)
  if valid_569741 != nil:
    section.add "PartitionKeyType", valid_569741
  var valid_569742 = query.getOrDefault("PreviousRspVersion")
  valid_569742 = validateParameter(valid_569742, JString, required = false,
                                 default = nil)
  if valid_569742 != nil:
    section.add "PreviousRspVersion", valid_569742
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569743: Call_ResolveService_569734; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  let valid = call_569743.validator(path, query, header, formData, body)
  let scheme = call_569743.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569743.url(scheme.get, call_569743.host, call_569743.base,
                         call_569743.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569743, url, valid)

proc call*(call_569744: Call_ResolveService_569734; serviceId: string;
          timeout: int = 60; PartitionKeyValue: string = ""; apiVersion: string = "6.0";
          PartitionKeyType: int = 0; PreviousRspVersion: string = ""): Recallable =
  ## resolveService
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyValue: string
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyType: int
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PreviousRspVersion: string
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  var path_569745 = newJObject()
  var query_569746 = newJObject()
  add(query_569746, "timeout", newJInt(timeout))
  add(query_569746, "PartitionKeyValue", newJString(PartitionKeyValue))
  add(query_569746, "api-version", newJString(apiVersion))
  add(query_569746, "PartitionKeyType", newJInt(PartitionKeyType))
  add(path_569745, "serviceId", newJString(serviceId))
  add(query_569746, "PreviousRspVersion", newJString(PreviousRspVersion))
  result = call_569744.call(path_569745, query_569746, nil, nil, nil)

var resolveService* = Call_ResolveService_569734(name: "resolveService",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/ResolvePartition",
    validator: validate_ResolveService_569735, base: "", url: url_ResolveService_569736,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateService_569747 = ref object of OpenApiRestCall_567667
proc url_UpdateService_569749(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Update")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateService_569748(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the specified service using the given update description.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_569750 = path.getOrDefault("serviceId")
  valid_569750 = validateParameter(valid_569750, JString, required = true,
                                 default = nil)
  if valid_569750 != nil:
    section.add "serviceId", valid_569750
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569751 = query.getOrDefault("timeout")
  valid_569751 = validateParameter(valid_569751, JInt, required = false,
                                 default = newJInt(60))
  if valid_569751 != nil:
    section.add "timeout", valid_569751
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569752 = query.getOrDefault("api-version")
  valid_569752 = validateParameter(valid_569752, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569752 != nil:
    section.add "api-version", valid_569752
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569754: Call_UpdateService_569747; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the specified service using the given update description.
  ## 
  let valid = call_569754.validator(path, query, header, formData, body)
  let scheme = call_569754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569754.url(scheme.get, call_569754.host, call_569754.base,
                         call_569754.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569754, url, valid)

proc call*(call_569755: Call_UpdateService_569747;
          ServiceUpdateDescription: JsonNode; serviceId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## updateService
  ## Updates the specified service using the given update description.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_569756 = newJObject()
  var query_569757 = newJObject()
  var body_569758 = newJObject()
  add(query_569757, "timeout", newJInt(timeout))
  add(query_569757, "api-version", newJString(apiVersion))
  if ServiceUpdateDescription != nil:
    body_569758 = ServiceUpdateDescription
  add(path_569756, "serviceId", newJString(serviceId))
  result = call_569755.call(path_569756, query_569757, nil, nil, body_569758)

var updateService* = Call_UpdateService_569747(name: "updateService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Update", validator: validate_UpdateService_569748,
    base: "", url: url_UpdateService_569749, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetChaosReport_569759 = ref object of OpenApiRestCall_567667
proc url_GetChaosReport_569761(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetChaosReport_569760(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EndTimeUtc: JString
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   StartTimeUtc: JString
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  section = newJObject()
  var valid_569762 = query.getOrDefault("timeout")
  valid_569762 = validateParameter(valid_569762, JInt, required = false,
                                 default = newJInt(60))
  if valid_569762 != nil:
    section.add "timeout", valid_569762
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569763 = query.getOrDefault("api-version")
  valid_569763 = validateParameter(valid_569763, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569763 != nil:
    section.add "api-version", valid_569763
  var valid_569764 = query.getOrDefault("EndTimeUtc")
  valid_569764 = validateParameter(valid_569764, JString, required = false,
                                 default = nil)
  if valid_569764 != nil:
    section.add "EndTimeUtc", valid_569764
  var valid_569765 = query.getOrDefault("ContinuationToken")
  valid_569765 = validateParameter(valid_569765, JString, required = false,
                                 default = nil)
  if valid_569765 != nil:
    section.add "ContinuationToken", valid_569765
  var valid_569766 = query.getOrDefault("StartTimeUtc")
  valid_569766 = validateParameter(valid_569766, JString, required = false,
                                 default = nil)
  if valid_569766 != nil:
    section.add "StartTimeUtc", valid_569766
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569767: Call_GetChaosReport_569759; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  let valid = call_569767.validator(path, query, header, formData, body)
  let scheme = call_569767.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569767.url(scheme.get, call_569767.host, call_569767.base,
                         call_569767.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569767, url, valid)

proc call*(call_569768: Call_GetChaosReport_569759; timeout: int = 60;
          apiVersion: string = "6.0"; EndTimeUtc: string = "";
          ContinuationToken: string = ""; StartTimeUtc: string = ""): Recallable =
  ## getChaosReport
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EndTimeUtc: string
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   StartTimeUtc: string
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  var query_569769 = newJObject()
  add(query_569769, "timeout", newJInt(timeout))
  add(query_569769, "api-version", newJString(apiVersion))
  add(query_569769, "EndTimeUtc", newJString(EndTimeUtc))
  add(query_569769, "ContinuationToken", newJString(ContinuationToken))
  add(query_569769, "StartTimeUtc", newJString(StartTimeUtc))
  result = call_569768.call(nil, query_569769, nil, nil, nil)

var getChaosReport* = Call_GetChaosReport_569759(name: "getChaosReport",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Tools/Chaos/$/Report", validator: validate_GetChaosReport_569760,
    base: "", url: url_GetChaosReport_569761, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartChaos_569770 = ref object of OpenApiRestCall_567667
proc url_StartChaos_569772(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartChaos_569771(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569773 = query.getOrDefault("timeout")
  valid_569773 = validateParameter(valid_569773, JInt, required = false,
                                 default = newJInt(60))
  if valid_569773 != nil:
    section.add "timeout", valid_569773
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569774 = query.getOrDefault("api-version")
  valid_569774 = validateParameter(valid_569774, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569774 != nil:
    section.add "api-version", valid_569774
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_569776: Call_StartChaos_569770; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  let valid = call_569776.validator(path, query, header, formData, body)
  let scheme = call_569776.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569776.url(scheme.get, call_569776.host, call_569776.base,
                         call_569776.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569776, url, valid)

proc call*(call_569777: Call_StartChaos_569770; ChaosParameters: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## startChaos
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  var query_569778 = newJObject()
  var body_569779 = newJObject()
  add(query_569778, "timeout", newJInt(timeout))
  add(query_569778, "api-version", newJString(apiVersion))
  if ChaosParameters != nil:
    body_569779 = ChaosParameters
  result = call_569777.call(nil, query_569778, nil, nil, body_569779)

var startChaos* = Call_StartChaos_569770(name: "startChaos",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Tools/Chaos/$/Start",
                                      validator: validate_StartChaos_569771,
                                      base: "", url: url_StartChaos_569772,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopChaos_569780 = ref object of OpenApiRestCall_567667
proc url_StopChaos_569782(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StopChaos_569781(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_569783 = query.getOrDefault("timeout")
  valid_569783 = validateParameter(valid_569783, JInt, required = false,
                                 default = newJInt(60))
  if valid_569783 != nil:
    section.add "timeout", valid_569783
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_569784 = query.getOrDefault("api-version")
  valid_569784 = validateParameter(valid_569784, JString, required = true,
                                 default = newJString("6.0"))
  if valid_569784 != nil:
    section.add "api-version", valid_569784
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_569785: Call_StopChaos_569780; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  let valid = call_569785.validator(path, query, header, formData, body)
  let scheme = call_569785.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_569785.url(scheme.get, call_569785.host, call_569785.base,
                         call_569785.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_569785, url, valid)

proc call*(call_569786: Call_StopChaos_569780; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## stopChaos
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_569787 = newJObject()
  add(query_569787, "timeout", newJInt(timeout))
  add(query_569787, "api-version", newJString(apiVersion))
  result = call_569786.call(nil, query_569787, nil, nil, nil)

var stopChaos* = Call_StopChaos_569780(name: "stopChaos", meth: HttpMethod.HttpPost,
                                    host: "azure.local:19080",
                                    route: "/Tools/Chaos/$/Stop",
                                    validator: validate_StopChaos_569781,
                                    base: "", url: url_StopChaos_569782,
                                    schemes: {Scheme.Https, Scheme.Http})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
