
import
  json, options, hashes, uri, openapi/rest, os, uri, strutils, httpcore

## auto-generated via openapi macro
## title: Service Fabric Client APIs
## version: 6.0.0.1
## termsOfService: (not provided)
## license: (not provided)
## 
## Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
## 
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593438 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593438](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593438): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  macServiceName = "servicefabric"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_CancelRepairTask_593660 = ref object of OpenApiRestCall_593438
proc url_CancelRepairTask_593662(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelRepairTask_593661(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_593834 = query.getOrDefault("api-version")
  valid_593834 = validateParameter(valid_593834, JString, required = true,
                                 default = newJString("6.0"))
  if valid_593834 != nil:
    section.add "api-version", valid_593834
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_593858: Call_CancelRepairTask_593660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_593858.validator(path, query, header, formData, body)
  let scheme = call_593858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593858.url(scheme.get, call_593858.host, call_593858.base,
                         call_593858.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593858, url, valid)

proc call*(call_593929: Call_CancelRepairTask_593660;
          RepairTaskCancelDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## cancelRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  var query_593930 = newJObject()
  var body_593932 = newJObject()
  add(query_593930, "api-version", newJString(apiVersion))
  if RepairTaskCancelDescription != nil:
    body_593932 = RepairTaskCancelDescription
  result = call_593929.call(nil, query_593930, nil, nil, body_593932)

var cancelRepairTask* = Call_CancelRepairTask_593660(name: "cancelRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CancelRepairTask", validator: validate_CancelRepairTask_593661,
    base: "", url: url_CancelRepairTask_593662, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRepairTask_593971 = ref object of OpenApiRestCall_593438
proc url_CreateRepairTask_593973(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateRepairTask_593972(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_593974 = query.getOrDefault("api-version")
  valid_593974 = validateParameter(valid_593974, JString, required = true,
                                 default = newJString("6.0"))
  if valid_593974 != nil:
    section.add "api-version", valid_593974
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_593976: Call_CreateRepairTask_593971; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_593976.validator(path, query, header, formData, body)
  let scheme = call_593976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593976.url(scheme.get, call_593976.host, call_593976.base,
                         call_593976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593976, url, valid)

proc call*(call_593977: Call_CreateRepairTask_593971; RepairTask: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## createRepairTask
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_593978 = newJObject()
  var body_593979 = newJObject()
  if RepairTask != nil:
    body_593979 = RepairTask
  add(query_593978, "api-version", newJString(apiVersion))
  result = call_593977.call(nil, query_593978, nil, nil, body_593979)

var createRepairTask* = Call_CreateRepairTask_593971(name: "createRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CreateRepairTask", validator: validate_CreateRepairTask_593972,
    base: "", url: url_CreateRepairTask_593973, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRepairTask_593980 = ref object of OpenApiRestCall_593438
proc url_DeleteRepairTask_593982(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteRepairTask_593981(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_593983 = query.getOrDefault("api-version")
  valid_593983 = validateParameter(valid_593983, JString, required = true,
                                 default = newJString("6.0"))
  if valid_593983 != nil:
    section.add "api-version", valid_593983
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_593985: Call_DeleteRepairTask_593980; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_593985.validator(path, query, header, formData, body)
  let scheme = call_593985.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593985.url(scheme.get, call_593985.host, call_593985.base,
                         call_593985.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593985, url, valid)

proc call*(call_593986: Call_DeleteRepairTask_593980;
          RepairTaskDeleteDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## deleteRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  var query_593987 = newJObject()
  var body_593988 = newJObject()
  add(query_593987, "api-version", newJString(apiVersion))
  if RepairTaskDeleteDescription != nil:
    body_593988 = RepairTaskDeleteDescription
  result = call_593986.call(nil, query_593987, nil, nil, body_593988)

var deleteRepairTask* = Call_DeleteRepairTask_593980(name: "deleteRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/DeleteRepairTask", validator: validate_DeleteRepairTask_593981,
    base: "", url: url_DeleteRepairTask_593982, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ForceApproveRepairTask_593989 = ref object of OpenApiRestCall_593438
proc url_ForceApproveRepairTask_593991(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ForceApproveRepairTask_593990(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_593992 = query.getOrDefault("api-version")
  valid_593992 = validateParameter(valid_593992, JString, required = true,
                                 default = newJString("6.0"))
  if valid_593992 != nil:
    section.add "api-version", valid_593992
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_593994: Call_ForceApproveRepairTask_593989; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_593994.validator(path, query, header, formData, body)
  let scheme = call_593994.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593994.url(scheme.get, call_593994.host, call_593994.base,
                         call_593994.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593994, url, valid)

proc call*(call_593995: Call_ForceApproveRepairTask_593989;
          RepairTaskApproveDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## forceApproveRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  var query_593996 = newJObject()
  var body_593997 = newJObject()
  add(query_593996, "api-version", newJString(apiVersion))
  if RepairTaskApproveDescription != nil:
    body_593997 = RepairTaskApproveDescription
  result = call_593995.call(nil, query_593996, nil, nil, body_593997)

var forceApproveRepairTask* = Call_ForceApproveRepairTask_593989(
    name: "forceApproveRepairTask", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ForceApproveRepairTask",
    validator: validate_ForceApproveRepairTask_593990, base: "",
    url: url_ForceApproveRepairTask_593991, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAadMetadata_593998 = ref object of OpenApiRestCall_593438
proc url_GetAadMetadata_594000(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAadMetadata_593999(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594002 = query.getOrDefault("timeout")
  valid_594002 = validateParameter(valid_594002, JInt, required = false,
                                 default = newJInt(60))
  if valid_594002 != nil:
    section.add "timeout", valid_594002
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594003 = query.getOrDefault("api-version")
  valid_594003 = validateParameter(valid_594003, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594003 != nil:
    section.add "api-version", valid_594003
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594004: Call_GetAadMetadata_593998; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  let valid = call_594004.validator(path, query, header, formData, body)
  let scheme = call_594004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594004.url(scheme.get, call_594004.host, call_594004.base,
                         call_594004.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594004, url, valid)

proc call*(call_594005: Call_GetAadMetadata_593998; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getAadMetadata
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594006 = newJObject()
  add(query_594006, "timeout", newJInt(timeout))
  add(query_594006, "api-version", newJString(apiVersion))
  result = call_594005.call(nil, query_594006, nil, nil, nil)

var getAadMetadata* = Call_GetAadMetadata_593998(name: "getAadMetadata",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/$/GetAadMetadata",
    validator: validate_GetAadMetadata_593999, base: "", url: url_GetAadMetadata_594000,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfiguration_594007 = ref object of OpenApiRestCall_593438
proc url_GetClusterConfiguration_594009(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfiguration_594008(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ConfigurationApiVersion: JString (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594010 = query.getOrDefault("timeout")
  valid_594010 = validateParameter(valid_594010, JInt, required = false,
                                 default = newJInt(60))
  if valid_594010 != nil:
    section.add "timeout", valid_594010
  assert query != nil, "query argument is necessary due to required `ConfigurationApiVersion` field"
  var valid_594011 = query.getOrDefault("ConfigurationApiVersion")
  valid_594011 = validateParameter(valid_594011, JString, required = true,
                                 default = nil)
  if valid_594011 != nil:
    section.add "ConfigurationApiVersion", valid_594011
  var valid_594012 = query.getOrDefault("api-version")
  valid_594012 = validateParameter(valid_594012, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594012 != nil:
    section.add "api-version", valid_594012
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594013: Call_GetClusterConfiguration_594007; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  let valid = call_594013.validator(path, query, header, formData, body)
  let scheme = call_594013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594013.url(scheme.get, call_594013.host, call_594013.base,
                         call_594013.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594013, url, valid)

proc call*(call_594014: Call_GetClusterConfiguration_594007;
          ConfigurationApiVersion: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterConfiguration
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ConfigurationApiVersion: string (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594015 = newJObject()
  add(query_594015, "timeout", newJInt(timeout))
  add(query_594015, "ConfigurationApiVersion", newJString(ConfigurationApiVersion))
  add(query_594015, "api-version", newJString(apiVersion))
  result = call_594014.call(nil, query_594015, nil, nil, nil)

var getClusterConfiguration* = Call_GetClusterConfiguration_594007(
    name: "getClusterConfiguration", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfiguration",
    validator: validate_GetClusterConfiguration_594008, base: "",
    url: url_GetClusterConfiguration_594009, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfigurationUpgradeStatus_594016 = ref object of OpenApiRestCall_593438
proc url_GetClusterConfigurationUpgradeStatus_594018(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfigurationUpgradeStatus_594017(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594019 = query.getOrDefault("timeout")
  valid_594019 = validateParameter(valid_594019, JInt, required = false,
                                 default = newJInt(60))
  if valid_594019 != nil:
    section.add "timeout", valid_594019
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594020 = query.getOrDefault("api-version")
  valid_594020 = validateParameter(valid_594020, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594020 != nil:
    section.add "api-version", valid_594020
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594021: Call_GetClusterConfigurationUpgradeStatus_594016;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  let valid = call_594021.validator(path, query, header, formData, body)
  let scheme = call_594021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594021.url(scheme.get, call_594021.host, call_594021.base,
                         call_594021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594021, url, valid)

proc call*(call_594022: Call_GetClusterConfigurationUpgradeStatus_594016;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getClusterConfigurationUpgradeStatus
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594023 = newJObject()
  add(query_594023, "timeout", newJInt(timeout))
  add(query_594023, "api-version", newJString(apiVersion))
  result = call_594022.call(nil, query_594023, nil, nil, nil)

var getClusterConfigurationUpgradeStatus* = Call_GetClusterConfigurationUpgradeStatus_594016(
    name: "getClusterConfigurationUpgradeStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfigurationUpgradeStatus",
    validator: validate_GetClusterConfigurationUpgradeStatus_594017, base: "",
    url: url_GetClusterConfigurationUpgradeStatus_594018,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthUsingPolicy_594037 = ref object of OpenApiRestCall_593438
proc url_GetClusterHealthUsingPolicy_594039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthUsingPolicy_594038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_594057 = query.getOrDefault("timeout")
  valid_594057 = validateParameter(valid_594057, JInt, required = false,
                                 default = newJInt(60))
  if valid_594057 != nil:
    section.add "timeout", valid_594057
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594058 = query.getOrDefault("api-version")
  valid_594058 = validateParameter(valid_594058, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594058 != nil:
    section.add "api-version", valid_594058
  var valid_594059 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_594059 = validateParameter(valid_594059, JInt, required = false,
                                 default = newJInt(0))
  if valid_594059 != nil:
    section.add "ApplicationsHealthStateFilter", valid_594059
  var valid_594060 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_594060 = validateParameter(valid_594060, JBool, required = false,
                                 default = newJBool(false))
  if valid_594060 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_594060
  var valid_594061 = query.getOrDefault("ExcludeHealthStatistics")
  valid_594061 = validateParameter(valid_594061, JBool, required = false,
                                 default = newJBool(false))
  if valid_594061 != nil:
    section.add "ExcludeHealthStatistics", valid_594061
  var valid_594062 = query.getOrDefault("EventsHealthStateFilter")
  valid_594062 = validateParameter(valid_594062, JInt, required = false,
                                 default = newJInt(0))
  if valid_594062 != nil:
    section.add "EventsHealthStateFilter", valid_594062
  var valid_594063 = query.getOrDefault("NodesHealthStateFilter")
  valid_594063 = validateParameter(valid_594063, JInt, required = false,
                                 default = newJInt(0))
  if valid_594063 != nil:
    section.add "NodesHealthStateFilter", valid_594063
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594065: Call_GetClusterHealthUsingPolicy_594037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  let valid = call_594065.validator(path, query, header, formData, body)
  let scheme = call_594065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594065.url(scheme.get, call_594065.host, call_594065.base,
                         call_594065.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594065, url, valid)

proc call*(call_594066: Call_GetClusterHealthUsingPolicy_594037; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          IncludeSystemApplicationHealthStatistics: bool = false;
          ClusterHealthPolicies: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealthUsingPolicy
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_594067 = newJObject()
  var body_594068 = newJObject()
  add(query_594067, "timeout", newJInt(timeout))
  add(query_594067, "api-version", newJString(apiVersion))
  add(query_594067, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_594067, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  if ClusterHealthPolicies != nil:
    body_594068 = ClusterHealthPolicies
  add(query_594067, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_594067, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_594067, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_594066.call(nil, query_594067, nil, nil, body_594068)

var getClusterHealthUsingPolicy* = Call_GetClusterHealthUsingPolicy_594037(
    name: "getClusterHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/GetClusterHealth",
    validator: validate_GetClusterHealthUsingPolicy_594038, base: "",
    url: url_GetClusterHealthUsingPolicy_594039,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealth_594024 = ref object of OpenApiRestCall_593438
proc url_GetClusterHealth_594026(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealth_594025(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_594027 = query.getOrDefault("timeout")
  valid_594027 = validateParameter(valid_594027, JInt, required = false,
                                 default = newJInt(60))
  if valid_594027 != nil:
    section.add "timeout", valid_594027
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594028 = query.getOrDefault("api-version")
  valid_594028 = validateParameter(valid_594028, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594028 != nil:
    section.add "api-version", valid_594028
  var valid_594029 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_594029 = validateParameter(valid_594029, JInt, required = false,
                                 default = newJInt(0))
  if valid_594029 != nil:
    section.add "ApplicationsHealthStateFilter", valid_594029
  var valid_594030 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_594030 = validateParameter(valid_594030, JBool, required = false,
                                 default = newJBool(false))
  if valid_594030 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_594030
  var valid_594031 = query.getOrDefault("ExcludeHealthStatistics")
  valid_594031 = validateParameter(valid_594031, JBool, required = false,
                                 default = newJBool(false))
  if valid_594031 != nil:
    section.add "ExcludeHealthStatistics", valid_594031
  var valid_594032 = query.getOrDefault("EventsHealthStateFilter")
  valid_594032 = validateParameter(valid_594032, JInt, required = false,
                                 default = newJInt(0))
  if valid_594032 != nil:
    section.add "EventsHealthStateFilter", valid_594032
  var valid_594033 = query.getOrDefault("NodesHealthStateFilter")
  valid_594033 = validateParameter(valid_594033, JInt, required = false,
                                 default = newJInt(0))
  if valid_594033 != nil:
    section.add "NodesHealthStateFilter", valid_594033
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594034: Call_GetClusterHealth_594024; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  let valid = call_594034.validator(path, query, header, formData, body)
  let scheme = call_594034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594034.url(scheme.get, call_594034.host, call_594034.base,
                         call_594034.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594034, url, valid)

proc call*(call_594035: Call_GetClusterHealth_594024; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          IncludeSystemApplicationHealthStatistics: bool = false;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealth
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_594036 = newJObject()
  add(query_594036, "timeout", newJInt(timeout))
  add(query_594036, "api-version", newJString(apiVersion))
  add(query_594036, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_594036, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  add(query_594036, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_594036, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_594036, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_594035.call(nil, query_594036, nil, nil, nil)

var getClusterHealth* = Call_GetClusterHealth_594024(name: "getClusterHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterHealth", validator: validate_GetClusterHealth_594025,
    base: "", url: url_GetClusterHealth_594026, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594077 = ref object of OpenApiRestCall_593438
proc url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594079(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594078(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594080 = query.getOrDefault("timeout")
  valid_594080 = validateParameter(valid_594080, JInt, required = false,
                                 default = newJInt(60))
  if valid_594080 != nil:
    section.add "timeout", valid_594080
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594081 = query.getOrDefault("api-version")
  valid_594081 = validateParameter(valid_594081, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594081 != nil:
    section.add "api-version", valid_594081
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594083: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594077;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  let valid = call_594083.validator(path, query, header, formData, body)
  let scheme = call_594083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594083.url(scheme.get, call_594083.host, call_594083.base,
                         call_594083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594083, url, valid)

proc call*(call_594084: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594077;
          timeout: int = 60; apiVersion: string = "6.0";
          ClusterHealthChunkQueryDescription: JsonNode = nil): Recallable =
  ## getClusterHealthChunkUsingPolicyAndAdvancedFilters
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  var query_594085 = newJObject()
  var body_594086 = newJObject()
  add(query_594085, "timeout", newJInt(timeout))
  add(query_594085, "api-version", newJString(apiVersion))
  if ClusterHealthChunkQueryDescription != nil:
    body_594086 = ClusterHealthChunkQueryDescription
  result = call_594084.call(nil, query_594085, nil, nil, body_594086)

var getClusterHealthChunkUsingPolicyAndAdvancedFilters* = Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594077(
    name: "getClusterHealthChunkUsingPolicyAndAdvancedFilters",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594078,
    base: "", url: url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_594079,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunk_594069 = ref object of OpenApiRestCall_593438
proc url_GetClusterHealthChunk_594071(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunk_594070(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594072 = query.getOrDefault("timeout")
  valid_594072 = validateParameter(valid_594072, JInt, required = false,
                                 default = newJInt(60))
  if valid_594072 != nil:
    section.add "timeout", valid_594072
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594073 = query.getOrDefault("api-version")
  valid_594073 = validateParameter(valid_594073, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594073 != nil:
    section.add "api-version", valid_594073
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594074: Call_GetClusterHealthChunk_594069; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  let valid = call_594074.validator(path, query, header, formData, body)
  let scheme = call_594074.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594074.url(scheme.get, call_594074.host, call_594074.base,
                         call_594074.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594074, url, valid)

proc call*(call_594075: Call_GetClusterHealthChunk_594069; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterHealthChunk
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594076 = newJObject()
  add(query_594076, "timeout", newJInt(timeout))
  add(query_594076, "api-version", newJString(apiVersion))
  result = call_594075.call(nil, query_594076, nil, nil, nil)

var getClusterHealthChunk* = Call_GetClusterHealthChunk_594069(
    name: "getClusterHealthChunk", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunk_594070, base: "",
    url: url_GetClusterHealthChunk_594071, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterManifest_594087 = ref object of OpenApiRestCall_593438
proc url_GetClusterManifest_594089(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterManifest_594088(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594090 = query.getOrDefault("timeout")
  valid_594090 = validateParameter(valid_594090, JInt, required = false,
                                 default = newJInt(60))
  if valid_594090 != nil:
    section.add "timeout", valid_594090
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594091 = query.getOrDefault("api-version")
  valid_594091 = validateParameter(valid_594091, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594091 != nil:
    section.add "api-version", valid_594091
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594092: Call_GetClusterManifest_594087; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  let valid = call_594092.validator(path, query, header, formData, body)
  let scheme = call_594092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594092.url(scheme.get, call_594092.host, call_594092.base,
                         call_594092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594092, url, valid)

proc call*(call_594093: Call_GetClusterManifest_594087; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterManifest
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594094 = newJObject()
  add(query_594094, "timeout", newJInt(timeout))
  add(query_594094, "api-version", newJString(apiVersion))
  result = call_594093.call(nil, query_594094, nil, nil, nil)

var getClusterManifest* = Call_GetClusterManifest_594087(
    name: "getClusterManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterManifest", validator: validate_GetClusterManifest_594088,
    base: "", url: url_GetClusterManifest_594089,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricCodeVersionInfoList_594095 = ref object of OpenApiRestCall_593438
proc url_GetProvisionedFabricCodeVersionInfoList_594097(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricCodeVersionInfoList_594096(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: JString
  ##              : The product version of Service Fabric.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594098 = query.getOrDefault("timeout")
  valid_594098 = validateParameter(valid_594098, JInt, required = false,
                                 default = newJInt(60))
  if valid_594098 != nil:
    section.add "timeout", valid_594098
  var valid_594099 = query.getOrDefault("CodeVersion")
  valid_594099 = validateParameter(valid_594099, JString, required = false,
                                 default = nil)
  if valid_594099 != nil:
    section.add "CodeVersion", valid_594099
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594100 = query.getOrDefault("api-version")
  valid_594100 = validateParameter(valid_594100, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594100 != nil:
    section.add "api-version", valid_594100
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594101: Call_GetProvisionedFabricCodeVersionInfoList_594095;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_594101.validator(path, query, header, formData, body)
  let scheme = call_594101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594101.url(scheme.get, call_594101.host, call_594101.base,
                         call_594101.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594101, url, valid)

proc call*(call_594102: Call_GetProvisionedFabricCodeVersionInfoList_594095;
          timeout: int = 60; CodeVersion: string = ""; apiVersion: string = "6.0"): Recallable =
  ## getProvisionedFabricCodeVersionInfoList
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: string
  ##              : The product version of Service Fabric.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594103 = newJObject()
  add(query_594103, "timeout", newJInt(timeout))
  add(query_594103, "CodeVersion", newJString(CodeVersion))
  add(query_594103, "api-version", newJString(apiVersion))
  result = call_594102.call(nil, query_594103, nil, nil, nil)

var getProvisionedFabricCodeVersionInfoList* = Call_GetProvisionedFabricCodeVersionInfoList_594095(
    name: "getProvisionedFabricCodeVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedCodeVersions",
    validator: validate_GetProvisionedFabricCodeVersionInfoList_594096, base: "",
    url: url_GetProvisionedFabricCodeVersionInfoList_594097,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricConfigVersionInfoList_594104 = ref object of OpenApiRestCall_593438
proc url_GetProvisionedFabricConfigVersionInfoList_594106(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricConfigVersionInfoList_594105(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: JString
  ##                : The config version of Service Fabric.
  section = newJObject()
  var valid_594107 = query.getOrDefault("timeout")
  valid_594107 = validateParameter(valid_594107, JInt, required = false,
                                 default = newJInt(60))
  if valid_594107 != nil:
    section.add "timeout", valid_594107
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594108 = query.getOrDefault("api-version")
  valid_594108 = validateParameter(valid_594108, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594108 != nil:
    section.add "api-version", valid_594108
  var valid_594109 = query.getOrDefault("ConfigVersion")
  valid_594109 = validateParameter(valid_594109, JString, required = false,
                                 default = nil)
  if valid_594109 != nil:
    section.add "ConfigVersion", valid_594109
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594110: Call_GetProvisionedFabricConfigVersionInfoList_594104;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_594110.validator(path, query, header, formData, body)
  let scheme = call_594110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594110.url(scheme.get, call_594110.host, call_594110.base,
                         call_594110.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594110, url, valid)

proc call*(call_594111: Call_GetProvisionedFabricConfigVersionInfoList_594104;
          timeout: int = 60; apiVersion: string = "6.0"; ConfigVersion: string = ""): Recallable =
  ## getProvisionedFabricConfigVersionInfoList
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: string
  ##                : The config version of Service Fabric.
  var query_594112 = newJObject()
  add(query_594112, "timeout", newJInt(timeout))
  add(query_594112, "api-version", newJString(apiVersion))
  add(query_594112, "ConfigVersion", newJString(ConfigVersion))
  result = call_594111.call(nil, query_594112, nil, nil, nil)

var getProvisionedFabricConfigVersionInfoList* = Call_GetProvisionedFabricConfigVersionInfoList_594104(
    name: "getProvisionedFabricConfigVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedConfigVersions",
    validator: validate_GetProvisionedFabricConfigVersionInfoList_594105,
    base: "", url: url_GetProvisionedFabricConfigVersionInfoList_594106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRepairTaskList_594113 = ref object of OpenApiRestCall_593438
proc url_GetRepairTaskList_594115(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRepairTaskList_594114(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TaskIdFilter: JString
  ##               : The repair task ID prefix to be matched.
  ##   ExecutorFilter: JString
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   StateFilter: JInt
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594116 = query.getOrDefault("api-version")
  valid_594116 = validateParameter(valid_594116, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594116 != nil:
    section.add "api-version", valid_594116
  var valid_594117 = query.getOrDefault("TaskIdFilter")
  valid_594117 = validateParameter(valid_594117, JString, required = false,
                                 default = nil)
  if valid_594117 != nil:
    section.add "TaskIdFilter", valid_594117
  var valid_594118 = query.getOrDefault("ExecutorFilter")
  valid_594118 = validateParameter(valid_594118, JString, required = false,
                                 default = nil)
  if valid_594118 != nil:
    section.add "ExecutorFilter", valid_594118
  var valid_594119 = query.getOrDefault("StateFilter")
  valid_594119 = validateParameter(valid_594119, JInt, required = false, default = nil)
  if valid_594119 != nil:
    section.add "StateFilter", valid_594119
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594120: Call_GetRepairTaskList_594113; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_594120.validator(path, query, header, formData, body)
  let scheme = call_594120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594120.url(scheme.get, call_594120.host, call_594120.base,
                         call_594120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594120, url, valid)

proc call*(call_594121: Call_GetRepairTaskList_594113; apiVersion: string = "6.0";
          TaskIdFilter: string = ""; ExecutorFilter: string = ""; StateFilter: int = 0): Recallable =
  ## getRepairTaskList
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TaskIdFilter: string
  ##               : The repair task ID prefix to be matched.
  ##   ExecutorFilter: string
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   StateFilter: int
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  var query_594122 = newJObject()
  add(query_594122, "api-version", newJString(apiVersion))
  add(query_594122, "TaskIdFilter", newJString(TaskIdFilter))
  add(query_594122, "ExecutorFilter", newJString(ExecutorFilter))
  add(query_594122, "StateFilter", newJInt(StateFilter))
  result = call_594121.call(nil, query_594122, nil, nil, nil)

var getRepairTaskList* = Call_GetRepairTaskList_594113(name: "getRepairTaskList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetRepairTaskList", validator: validate_GetRepairTaskList_594114,
    base: "", url: url_GetRepairTaskList_594115,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterUpgradeProgress_594123 = ref object of OpenApiRestCall_593438
proc url_GetClusterUpgradeProgress_594125(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterUpgradeProgress_594124(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594126 = query.getOrDefault("timeout")
  valid_594126 = validateParameter(valid_594126, JInt, required = false,
                                 default = newJInt(60))
  if valid_594126 != nil:
    section.add "timeout", valid_594126
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594127 = query.getOrDefault("api-version")
  valid_594127 = validateParameter(valid_594127, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594127 != nil:
    section.add "api-version", valid_594127
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594128: Call_GetClusterUpgradeProgress_594123; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  let valid = call_594128.validator(path, query, header, formData, body)
  let scheme = call_594128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594128.url(scheme.get, call_594128.host, call_594128.base,
                         call_594128.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594128, url, valid)

proc call*(call_594129: Call_GetClusterUpgradeProgress_594123; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getClusterUpgradeProgress
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594130 = newJObject()
  add(query_594130, "timeout", newJInt(timeout))
  add(query_594130, "api-version", newJString(apiVersion))
  result = call_594129.call(nil, query_594130, nil, nil, nil)

var getClusterUpgradeProgress* = Call_GetClusterUpgradeProgress_594123(
    name: "getClusterUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetUpgradeProgress",
    validator: validate_GetClusterUpgradeProgress_594124, base: "",
    url: url_GetClusterUpgradeProgress_594125,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureCommand_594131 = ref object of OpenApiRestCall_593438
proc url_InvokeInfrastructureCommand_594133(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureCommand_594132(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  var valid_594134 = query.getOrDefault("timeout")
  valid_594134 = validateParameter(valid_594134, JInt, required = false,
                                 default = newJInt(60))
  if valid_594134 != nil:
    section.add "timeout", valid_594134
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594135 = query.getOrDefault("api-version")
  valid_594135 = validateParameter(valid_594135, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594135 != nil:
    section.add "api-version", valid_594135
  var valid_594136 = query.getOrDefault("ServiceId")
  valid_594136 = validateParameter(valid_594136, JString, required = false,
                                 default = nil)
  if valid_594136 != nil:
    section.add "ServiceId", valid_594136
  var valid_594137 = query.getOrDefault("Command")
  valid_594137 = validateParameter(valid_594137, JString, required = true,
                                 default = nil)
  if valid_594137 != nil:
    section.add "Command", valid_594137
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594138: Call_InvokeInfrastructureCommand_594131; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_594138.validator(path, query, header, formData, body)
  let scheme = call_594138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594138.url(scheme.get, call_594138.host, call_594138.base,
                         call_594138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594138, url, valid)

proc call*(call_594139: Call_InvokeInfrastructureCommand_594131; Command: string;
          timeout: int = 60; apiVersion: string = "6.0"; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureCommand
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_594140 = newJObject()
  add(query_594140, "timeout", newJInt(timeout))
  add(query_594140, "api-version", newJString(apiVersion))
  add(query_594140, "ServiceId", newJString(ServiceId))
  add(query_594140, "Command", newJString(Command))
  result = call_594139.call(nil, query_594140, nil, nil, nil)

var invokeInfrastructureCommand* = Call_InvokeInfrastructureCommand_594131(
    name: "invokeInfrastructureCommand", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureCommand",
    validator: validate_InvokeInfrastructureCommand_594132, base: "",
    url: url_InvokeInfrastructureCommand_594133,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureQuery_594141 = ref object of OpenApiRestCall_593438
proc url_InvokeInfrastructureQuery_594143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureQuery_594142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  var valid_594144 = query.getOrDefault("timeout")
  valid_594144 = validateParameter(valid_594144, JInt, required = false,
                                 default = newJInt(60))
  if valid_594144 != nil:
    section.add "timeout", valid_594144
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594145 = query.getOrDefault("api-version")
  valid_594145 = validateParameter(valid_594145, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594145 != nil:
    section.add "api-version", valid_594145
  var valid_594146 = query.getOrDefault("ServiceId")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "ServiceId", valid_594146
  var valid_594147 = query.getOrDefault("Command")
  valid_594147 = validateParameter(valid_594147, JString, required = true,
                                 default = nil)
  if valid_594147 != nil:
    section.add "Command", valid_594147
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594148: Call_InvokeInfrastructureQuery_594141; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_594148.validator(path, query, header, formData, body)
  let scheme = call_594148.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594148.url(scheme.get, call_594148.host, call_594148.base,
                         call_594148.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594148, url, valid)

proc call*(call_594149: Call_InvokeInfrastructureQuery_594141; Command: string;
          timeout: int = 60; apiVersion: string = "6.0"; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureQuery
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_594150 = newJObject()
  add(query_594150, "timeout", newJInt(timeout))
  add(query_594150, "api-version", newJString(apiVersion))
  add(query_594150, "ServiceId", newJString(ServiceId))
  add(query_594150, "Command", newJString(Command))
  result = call_594149.call(nil, query_594150, nil, nil, nil)

var invokeInfrastructureQuery* = Call_InvokeInfrastructureQuery_594141(
    name: "invokeInfrastructureQuery", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureQuery",
    validator: validate_InvokeInfrastructureQuery_594142, base: "",
    url: url_InvokeInfrastructureQuery_594143,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeClusterUpgrade_594151 = ref object of OpenApiRestCall_593438
proc url_ResumeClusterUpgrade_594153(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ResumeClusterUpgrade_594152(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594154 = query.getOrDefault("timeout")
  valid_594154 = validateParameter(valid_594154, JInt, required = false,
                                 default = newJInt(60))
  if valid_594154 != nil:
    section.add "timeout", valid_594154
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594155 = query.getOrDefault("api-version")
  valid_594155 = validateParameter(valid_594155, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594155 != nil:
    section.add "api-version", valid_594155
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594157: Call_ResumeClusterUpgrade_594151; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  let valid = call_594157.validator(path, query, header, formData, body)
  let scheme = call_594157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594157.url(scheme.get, call_594157.host, call_594157.base,
                         call_594157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594157, url, valid)

proc call*(call_594158: Call_ResumeClusterUpgrade_594151;
          ResumeClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## resumeClusterUpgrade
  ## Make the cluster upgrade move on to the next upgrade domain.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  var query_594159 = newJObject()
  var body_594160 = newJObject()
  add(query_594159, "timeout", newJInt(timeout))
  add(query_594159, "api-version", newJString(apiVersion))
  if ResumeClusterUpgradeDescription != nil:
    body_594160 = ResumeClusterUpgradeDescription
  result = call_594158.call(nil, query_594159, nil, nil, body_594160)

var resumeClusterUpgrade* = Call_ResumeClusterUpgrade_594151(
    name: "resumeClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeClusterUpgrade_594152, base: "",
    url: url_ResumeClusterUpgrade_594153, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionCluster_594161 = ref object of OpenApiRestCall_593438
proc url_ProvisionCluster_594163(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionCluster_594162(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594164 = query.getOrDefault("timeout")
  valid_594164 = validateParameter(valid_594164, JInt, required = false,
                                 default = newJInt(60))
  if valid_594164 != nil:
    section.add "timeout", valid_594164
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594165 = query.getOrDefault("api-version")
  valid_594165 = validateParameter(valid_594165, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594165 != nil:
    section.add "api-version", valid_594165
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594167: Call_ProvisionCluster_594161; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_594167.validator(path, query, header, formData, body)
  let scheme = call_594167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594167.url(scheme.get, call_594167.host, call_594167.base,
                         call_594167.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594167, url, valid)

proc call*(call_594168: Call_ProvisionCluster_594161;
          ProvisionFabricDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## provisionCluster
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  var query_594169 = newJObject()
  var body_594170 = newJObject()
  add(query_594169, "timeout", newJInt(timeout))
  add(query_594169, "api-version", newJString(apiVersion))
  if ProvisionFabricDescription != nil:
    body_594170 = ProvisionFabricDescription
  result = call_594168.call(nil, query_594169, nil, nil, body_594170)

var provisionCluster* = Call_ProvisionCluster_594161(name: "provisionCluster",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/$/Provision",
    validator: validate_ProvisionCluster_594162, base: "",
    url: url_ProvisionCluster_594163, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverAllPartitions_594171 = ref object of OpenApiRestCall_593438
proc url_RecoverAllPartitions_594173(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverAllPartitions_594172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594174 = query.getOrDefault("timeout")
  valid_594174 = validateParameter(valid_594174, JInt, required = false,
                                 default = newJInt(60))
  if valid_594174 != nil:
    section.add "timeout", valid_594174
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594175 = query.getOrDefault("api-version")
  valid_594175 = validateParameter(valid_594175, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594175 != nil:
    section.add "api-version", valid_594175
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594176: Call_RecoverAllPartitions_594171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_594176.validator(path, query, header, formData, body)
  let scheme = call_594176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594176.url(scheme.get, call_594176.host, call_594176.base,
                         call_594176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594176, url, valid)

proc call*(call_594177: Call_RecoverAllPartitions_594171; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## recoverAllPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594178 = newJObject()
  add(query_594178, "timeout", newJInt(timeout))
  add(query_594178, "api-version", newJString(apiVersion))
  result = call_594177.call(nil, query_594178, nil, nil, nil)

var recoverAllPartitions* = Call_RecoverAllPartitions_594171(
    name: "recoverAllPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverAllPartitions",
    validator: validate_RecoverAllPartitions_594172, base: "",
    url: url_RecoverAllPartitions_594173, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverSystemPartitions_594179 = ref object of OpenApiRestCall_593438
proc url_RecoverSystemPartitions_594181(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverSystemPartitions_594180(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594182 = query.getOrDefault("timeout")
  valid_594182 = validateParameter(valid_594182, JInt, required = false,
                                 default = newJInt(60))
  if valid_594182 != nil:
    section.add "timeout", valid_594182
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594183 = query.getOrDefault("api-version")
  valid_594183 = validateParameter(valid_594183, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594183 != nil:
    section.add "api-version", valid_594183
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594184: Call_RecoverSystemPartitions_594179; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_594184.validator(path, query, header, formData, body)
  let scheme = call_594184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594184.url(scheme.get, call_594184.host, call_594184.base,
                         call_594184.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594184, url, valid)

proc call*(call_594185: Call_RecoverSystemPartitions_594179; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## recoverSystemPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594186 = newJObject()
  add(query_594186, "timeout", newJInt(timeout))
  add(query_594186, "api-version", newJString(apiVersion))
  result = call_594185.call(nil, query_594186, nil, nil, nil)

var recoverSystemPartitions* = Call_RecoverSystemPartitions_594179(
    name: "recoverSystemPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverSystemPartitions",
    validator: validate_RecoverSystemPartitions_594180, base: "",
    url: url_RecoverSystemPartitions_594181, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportClusterHealth_594187 = ref object of OpenApiRestCall_593438
proc url_ReportClusterHealth_594189(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ReportClusterHealth_594188(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594190 = query.getOrDefault("Immediate")
  valid_594190 = validateParameter(valid_594190, JBool, required = false,
                                 default = newJBool(false))
  if valid_594190 != nil:
    section.add "Immediate", valid_594190
  var valid_594191 = query.getOrDefault("timeout")
  valid_594191 = validateParameter(valid_594191, JInt, required = false,
                                 default = newJInt(60))
  if valid_594191 != nil:
    section.add "timeout", valid_594191
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594192 = query.getOrDefault("api-version")
  valid_594192 = validateParameter(valid_594192, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594192 != nil:
    section.add "api-version", valid_594192
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594194: Call_ReportClusterHealth_594187; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_594194.validator(path, query, header, formData, body)
  let scheme = call_594194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594194.url(scheme.get, call_594194.host, call_594194.base,
                         call_594194.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594194, url, valid)

proc call*(call_594195: Call_ReportClusterHealth_594187;
          HealthInformation: JsonNode; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportClusterHealth
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  var query_594196 = newJObject()
  var body_594197 = newJObject()
  add(query_594196, "Immediate", newJBool(Immediate))
  add(query_594196, "timeout", newJInt(timeout))
  add(query_594196, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_594197 = HealthInformation
  result = call_594195.call(nil, query_594196, nil, nil, body_594197)

var reportClusterHealth* = Call_ReportClusterHealth_594187(
    name: "reportClusterHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ReportClusterHealth",
    validator: validate_ReportClusterHealth_594188, base: "",
    url: url_ReportClusterHealth_594189, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackClusterUpgrade_594198 = ref object of OpenApiRestCall_593438
proc url_RollbackClusterUpgrade_594200(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RollbackClusterUpgrade_594199(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594201 = query.getOrDefault("timeout")
  valid_594201 = validateParameter(valid_594201, JInt, required = false,
                                 default = newJInt(60))
  if valid_594201 != nil:
    section.add "timeout", valid_594201
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594202 = query.getOrDefault("api-version")
  valid_594202 = validateParameter(valid_594202, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594202 != nil:
    section.add "api-version", valid_594202
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594203: Call_RollbackClusterUpgrade_594198; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  let valid = call_594203.validator(path, query, header, formData, body)
  let scheme = call_594203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594203.url(scheme.get, call_594203.host, call_594203.base,
                         call_594203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594203, url, valid)

proc call*(call_594204: Call_RollbackClusterUpgrade_594198; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## rollbackClusterUpgrade
  ## Rollback the upgrade of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594205 = newJObject()
  add(query_594205, "timeout", newJInt(timeout))
  add(query_594205, "api-version", newJString(apiVersion))
  result = call_594204.call(nil, query_594205, nil, nil, nil)

var rollbackClusterUpgrade* = Call_RollbackClusterUpgrade_594198(
    name: "rollbackClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RollbackUpgrade",
    validator: validate_RollbackClusterUpgrade_594199, base: "",
    url: url_RollbackClusterUpgrade_594200, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterConfigurationUpgrade_594206 = ref object of OpenApiRestCall_593438
proc url_StartClusterConfigurationUpgrade_594208(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterConfigurationUpgrade_594207(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594209 = query.getOrDefault("timeout")
  valid_594209 = validateParameter(valid_594209, JInt, required = false,
                                 default = newJInt(60))
  if valid_594209 != nil:
    section.add "timeout", valid_594209
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594210 = query.getOrDefault("api-version")
  valid_594210 = validateParameter(valid_594210, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594210 != nil:
    section.add "api-version", valid_594210
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594212: Call_StartClusterConfigurationUpgrade_594206;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  let valid = call_594212.validator(path, query, header, formData, body)
  let scheme = call_594212.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594212.url(scheme.get, call_594212.host, call_594212.base,
                         call_594212.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594212, url, valid)

proc call*(call_594213: Call_StartClusterConfigurationUpgrade_594206;
          ClusterConfigurationUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startClusterConfigurationUpgrade
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  var query_594214 = newJObject()
  var body_594215 = newJObject()
  add(query_594214, "timeout", newJInt(timeout))
  add(query_594214, "api-version", newJString(apiVersion))
  if ClusterConfigurationUpgradeDescription != nil:
    body_594215 = ClusterConfigurationUpgradeDescription
  result = call_594213.call(nil, query_594214, nil, nil, body_594215)

var startClusterConfigurationUpgrade* = Call_StartClusterConfigurationUpgrade_594206(
    name: "startClusterConfigurationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/StartClusterConfigurationUpgrade",
    validator: validate_StartClusterConfigurationUpgrade_594207, base: "",
    url: url_StartClusterConfigurationUpgrade_594208,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionCluster_594216 = ref object of OpenApiRestCall_593438
proc url_UnprovisionCluster_594218(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UnprovisionCluster_594217(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594219 = query.getOrDefault("timeout")
  valid_594219 = validateParameter(valid_594219, JInt, required = false,
                                 default = newJInt(60))
  if valid_594219 != nil:
    section.add "timeout", valid_594219
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594220 = query.getOrDefault("api-version")
  valid_594220 = validateParameter(valid_594220, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594220 != nil:
    section.add "api-version", valid_594220
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594222: Call_UnprovisionCluster_594216; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_594222.validator(path, query, header, formData, body)
  let scheme = call_594222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594222.url(scheme.get, call_594222.host, call_594222.base,
                         call_594222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594222, url, valid)

proc call*(call_594223: Call_UnprovisionCluster_594216;
          UnprovisionFabricDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## unprovisionCluster
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  var query_594224 = newJObject()
  var body_594225 = newJObject()
  add(query_594224, "timeout", newJInt(timeout))
  add(query_594224, "api-version", newJString(apiVersion))
  if UnprovisionFabricDescription != nil:
    body_594225 = UnprovisionFabricDescription
  result = call_594223.call(nil, query_594224, nil, nil, body_594225)

var unprovisionCluster* = Call_UnprovisionCluster_594216(
    name: "unprovisionCluster", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Unprovision",
    validator: validate_UnprovisionCluster_594217, base: "",
    url: url_UnprovisionCluster_594218, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairExecutionState_594226 = ref object of OpenApiRestCall_593438
proc url_UpdateRepairExecutionState_594228(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairExecutionState_594227(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594229 = query.getOrDefault("api-version")
  valid_594229 = validateParameter(valid_594229, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594229 != nil:
    section.add "api-version", valid_594229
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594231: Call_UpdateRepairExecutionState_594226; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_594231.validator(path, query, header, formData, body)
  let scheme = call_594231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594231.url(scheme.get, call_594231.host, call_594231.base,
                         call_594231.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594231, url, valid)

proc call*(call_594232: Call_UpdateRepairExecutionState_594226;
          RepairTask: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## updateRepairExecutionState
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594233 = newJObject()
  var body_594234 = newJObject()
  if RepairTask != nil:
    body_594234 = RepairTask
  add(query_594233, "api-version", newJString(apiVersion))
  result = call_594232.call(nil, query_594233, nil, nil, body_594234)

var updateRepairExecutionState* = Call_UpdateRepairExecutionState_594226(
    name: "updateRepairExecutionState", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairExecutionState",
    validator: validate_UpdateRepairExecutionState_594227, base: "",
    url: url_UpdateRepairExecutionState_594228,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairTaskHealthPolicy_594235 = ref object of OpenApiRestCall_593438
proc url_UpdateRepairTaskHealthPolicy_594237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairTaskHealthPolicy_594236(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594238 = query.getOrDefault("api-version")
  valid_594238 = validateParameter(valid_594238, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594238 != nil:
    section.add "api-version", valid_594238
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594240: Call_UpdateRepairTaskHealthPolicy_594235; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_594240.validator(path, query, header, formData, body)
  let scheme = call_594240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594240.url(scheme.get, call_594240.host, call_594240.base,
                         call_594240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594240, url, valid)

proc call*(call_594241: Call_UpdateRepairTaskHealthPolicy_594235;
          RepairTaskUpdateHealthPolicyDescription: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## updateRepairTaskHealthPolicy
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  var query_594242 = newJObject()
  var body_594243 = newJObject()
  add(query_594242, "api-version", newJString(apiVersion))
  if RepairTaskUpdateHealthPolicyDescription != nil:
    body_594243 = RepairTaskUpdateHealthPolicyDescription
  result = call_594241.call(nil, query_594242, nil, nil, body_594243)

var updateRepairTaskHealthPolicy* = Call_UpdateRepairTaskHealthPolicy_594235(
    name: "updateRepairTaskHealthPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairTaskHealthPolicy",
    validator: validate_UpdateRepairTaskHealthPolicy_594236, base: "",
    url: url_UpdateRepairTaskHealthPolicy_594237,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateClusterUpgrade_594244 = ref object of OpenApiRestCall_593438
proc url_UpdateClusterUpgrade_594246(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateClusterUpgrade_594245(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594247 = query.getOrDefault("timeout")
  valid_594247 = validateParameter(valid_594247, JInt, required = false,
                                 default = newJInt(60))
  if valid_594247 != nil:
    section.add "timeout", valid_594247
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594248 = query.getOrDefault("api-version")
  valid_594248 = validateParameter(valid_594248, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594248 != nil:
    section.add "api-version", valid_594248
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594250: Call_UpdateClusterUpgrade_594244; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  let valid = call_594250.validator(path, query, header, formData, body)
  let scheme = call_594250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594250.url(scheme.get, call_594250.host, call_594250.base,
                         call_594250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594250, url, valid)

proc call*(call_594251: Call_UpdateClusterUpgrade_594244;
          UpdateClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## updateClusterUpgrade
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  var query_594252 = newJObject()
  var body_594253 = newJObject()
  add(query_594252, "timeout", newJInt(timeout))
  add(query_594252, "api-version", newJString(apiVersion))
  if UpdateClusterUpgradeDescription != nil:
    body_594253 = UpdateClusterUpgradeDescription
  result = call_594251.call(nil, query_594252, nil, nil, body_594253)

var updateClusterUpgrade* = Call_UpdateClusterUpgrade_594244(
    name: "updateClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateUpgrade",
    validator: validate_UpdateClusterUpgrade_594245, base: "",
    url: url_UpdateClusterUpgrade_594246, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterUpgrade_594254 = ref object of OpenApiRestCall_593438
proc url_StartClusterUpgrade_594256(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterUpgrade_594255(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594257 = query.getOrDefault("timeout")
  valid_594257 = validateParameter(valid_594257, JInt, required = false,
                                 default = newJInt(60))
  if valid_594257 != nil:
    section.add "timeout", valid_594257
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594258 = query.getOrDefault("api-version")
  valid_594258 = validateParameter(valid_594258, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594258 != nil:
    section.add "api-version", valid_594258
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594260: Call_StartClusterUpgrade_594254; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  let valid = call_594260.validator(path, query, header, formData, body)
  let scheme = call_594260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594260.url(scheme.get, call_594260.host, call_594260.base,
                         call_594260.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594260, url, valid)

proc call*(call_594261: Call_StartClusterUpgrade_594254;
          StartClusterUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startClusterUpgrade
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  var query_594262 = newJObject()
  var body_594263 = newJObject()
  add(query_594262, "timeout", newJInt(timeout))
  add(query_594262, "api-version", newJString(apiVersion))
  if StartClusterUpgradeDescription != nil:
    body_594263 = StartClusterUpgradeDescription
  result = call_594261.call(nil, query_594262, nil, nil, body_594263)

var startClusterUpgrade* = Call_StartClusterUpgrade_594254(
    name: "startClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Upgrade",
    validator: validate_StartClusterUpgrade_594255, base: "",
    url: url_StartClusterUpgrade_594256, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoList_594264 = ref object of OpenApiRestCall_593438
proc url_GetApplicationTypeInfoList_594266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationTypeInfoList_594265(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeDefinitionKindFilter: JInt
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_594267 = query.getOrDefault("timeout")
  valid_594267 = validateParameter(valid_594267, JInt, required = false,
                                 default = newJInt(60))
  if valid_594267 != nil:
    section.add "timeout", valid_594267
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594268 = query.getOrDefault("api-version")
  valid_594268 = validateParameter(valid_594268, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594268 != nil:
    section.add "api-version", valid_594268
  var valid_594269 = query.getOrDefault("ApplicationTypeDefinitionKindFilter")
  valid_594269 = validateParameter(valid_594269, JInt, required = false,
                                 default = newJInt(0))
  if valid_594269 != nil:
    section.add "ApplicationTypeDefinitionKindFilter", valid_594269
  var valid_594270 = query.getOrDefault("ContinuationToken")
  valid_594270 = validateParameter(valid_594270, JString, required = false,
                                 default = nil)
  if valid_594270 != nil:
    section.add "ContinuationToken", valid_594270
  var valid_594271 = query.getOrDefault("MaxResults")
  valid_594271 = validateParameter(valid_594271, JInt, required = false,
                                 default = newJInt(0))
  if valid_594271 != nil:
    section.add "MaxResults", valid_594271
  var valid_594272 = query.getOrDefault("ExcludeApplicationParameters")
  valid_594272 = validateParameter(valid_594272, JBool, required = false,
                                 default = newJBool(false))
  if valid_594272 != nil:
    section.add "ExcludeApplicationParameters", valid_594272
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594273: Call_GetApplicationTypeInfoList_594264; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_594273.validator(path, query, header, formData, body)
  let scheme = call_594273.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594273.url(scheme.get, call_594273.host, call_594273.base,
                         call_594273.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594273, url, valid)

proc call*(call_594274: Call_GetApplicationTypeInfoList_594264; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationTypeDefinitionKindFilter: int = 0;
          ContinuationToken: string = ""; MaxResults: int = 0;
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoList
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeDefinitionKindFilter: int
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_594275 = newJObject()
  add(query_594275, "timeout", newJInt(timeout))
  add(query_594275, "api-version", newJString(apiVersion))
  add(query_594275, "ApplicationTypeDefinitionKindFilter",
      newJInt(ApplicationTypeDefinitionKindFilter))
  add(query_594275, "ContinuationToken", newJString(ContinuationToken))
  add(query_594275, "MaxResults", newJInt(MaxResults))
  add(query_594275, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_594274.call(nil, query_594275, nil, nil, nil)

var getApplicationTypeInfoList* = Call_GetApplicationTypeInfoList_594264(
    name: "getApplicationTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes",
    validator: validate_GetApplicationTypeInfoList_594265, base: "",
    url: url_GetApplicationTypeInfoList_594266,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionApplicationType_594276 = ref object of OpenApiRestCall_593438
proc url_ProvisionApplicationType_594278(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionApplicationType_594277(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594279 = query.getOrDefault("timeout")
  valid_594279 = validateParameter(valid_594279, JInt, required = false,
                                 default = newJInt(60))
  if valid_594279 != nil:
    section.add "timeout", valid_594279
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594280 = query.getOrDefault("api-version")
  valid_594280 = validateParameter(valid_594280, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594280 != nil:
    section.add "api-version", valid_594280
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594282: Call_ProvisionApplicationType_594276; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  let valid = call_594282.validator(path, query, header, formData, body)
  let scheme = call_594282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594282.url(scheme.get, call_594282.host, call_594282.base,
                         call_594282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594282, url, valid)

proc call*(call_594283: Call_ProvisionApplicationType_594276;
          ApplicationTypeImageStorePath: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## provisionApplicationType
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  var query_594284 = newJObject()
  var body_594285 = newJObject()
  add(query_594284, "timeout", newJInt(timeout))
  add(query_594284, "api-version", newJString(apiVersion))
  if ApplicationTypeImageStorePath != nil:
    body_594285 = ApplicationTypeImageStorePath
  result = call_594283.call(nil, query_594284, nil, nil, body_594285)

var provisionApplicationType* = Call_ProvisionApplicationType_594276(
    name: "provisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ApplicationTypes/$/Provision",
    validator: validate_ProvisionApplicationType_594277, base: "",
    url: url_ProvisionApplicationType_594278, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoListByName_594286 = ref object of OpenApiRestCall_593438
proc url_GetApplicationTypeInfoListByName_594288(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationTypeInfoListByName_594287(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_594303 = path.getOrDefault("applicationTypeName")
  valid_594303 = validateParameter(valid_594303, JString, required = true,
                                 default = nil)
  if valid_594303 != nil:
    section.add "applicationTypeName", valid_594303
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString
  ##                         : The version of the application type.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_594304 = query.getOrDefault("timeout")
  valid_594304 = validateParameter(valid_594304, JInt, required = false,
                                 default = newJInt(60))
  if valid_594304 != nil:
    section.add "timeout", valid_594304
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594305 = query.getOrDefault("api-version")
  valid_594305 = validateParameter(valid_594305, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594305 != nil:
    section.add "api-version", valid_594305
  var valid_594306 = query.getOrDefault("ApplicationTypeVersion")
  valid_594306 = validateParameter(valid_594306, JString, required = false,
                                 default = nil)
  if valid_594306 != nil:
    section.add "ApplicationTypeVersion", valid_594306
  var valid_594307 = query.getOrDefault("ContinuationToken")
  valid_594307 = validateParameter(valid_594307, JString, required = false,
                                 default = nil)
  if valid_594307 != nil:
    section.add "ContinuationToken", valid_594307
  var valid_594308 = query.getOrDefault("MaxResults")
  valid_594308 = validateParameter(valid_594308, JInt, required = false,
                                 default = newJInt(0))
  if valid_594308 != nil:
    section.add "MaxResults", valid_594308
  var valid_594309 = query.getOrDefault("ExcludeApplicationParameters")
  valid_594309 = validateParameter(valid_594309, JBool, required = false,
                                 default = newJBool(false))
  if valid_594309 != nil:
    section.add "ExcludeApplicationParameters", valid_594309
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594310: Call_GetApplicationTypeInfoListByName_594286;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_594310.validator(path, query, header, formData, body)
  let scheme = call_594310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594310.url(scheme.get, call_594310.host, call_594310.base,
                         call_594310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594310, url, valid)

proc call*(call_594311: Call_GetApplicationTypeInfoListByName_594286;
          applicationTypeName: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationTypeVersion: string = ""; ContinuationToken: string = "";
          MaxResults: int = 0; ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoListByName
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string
  ##                         : The version of the application type.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var path_594312 = newJObject()
  var query_594313 = newJObject()
  add(query_594313, "timeout", newJInt(timeout))
  add(query_594313, "api-version", newJString(apiVersion))
  add(path_594312, "applicationTypeName", newJString(applicationTypeName))
  add(query_594313, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_594313, "ContinuationToken", newJString(ContinuationToken))
  add(query_594313, "MaxResults", newJInt(MaxResults))
  add(query_594313, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_594311.call(path_594312, query_594313, nil, nil, nil)

var getApplicationTypeInfoListByName* = Call_GetApplicationTypeInfoListByName_594286(
    name: "getApplicationTypeInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes/{applicationTypeName}",
    validator: validate_GetApplicationTypeInfoListByName_594287, base: "",
    url: url_GetApplicationTypeInfoListByName_594288,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationManifest_594314 = ref object of OpenApiRestCall_593438
proc url_GetApplicationManifest_594316(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetApplicationManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationManifest_594315(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_594317 = path.getOrDefault("applicationTypeName")
  valid_594317 = validateParameter(valid_594317, JString, required = true,
                                 default = nil)
  if valid_594317 != nil:
    section.add "applicationTypeName", valid_594317
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  section = newJObject()
  var valid_594318 = query.getOrDefault("timeout")
  valid_594318 = validateParameter(valid_594318, JInt, required = false,
                                 default = newJInt(60))
  if valid_594318 != nil:
    section.add "timeout", valid_594318
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594319 = query.getOrDefault("api-version")
  valid_594319 = validateParameter(valid_594319, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594319 != nil:
    section.add "api-version", valid_594319
  var valid_594320 = query.getOrDefault("ApplicationTypeVersion")
  valid_594320 = validateParameter(valid_594320, JString, required = true,
                                 default = nil)
  if valid_594320 != nil:
    section.add "ApplicationTypeVersion", valid_594320
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594321: Call_GetApplicationManifest_594314; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  let valid = call_594321.validator(path, query, header, formData, body)
  let scheme = call_594321.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594321.url(scheme.get, call_594321.host, call_594321.base,
                         call_594321.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594321, url, valid)

proc call*(call_594322: Call_GetApplicationManifest_594314;
          applicationTypeName: string; ApplicationTypeVersion: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationManifest
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  var path_594323 = newJObject()
  var query_594324 = newJObject()
  add(query_594324, "timeout", newJInt(timeout))
  add(query_594324, "api-version", newJString(apiVersion))
  add(path_594323, "applicationTypeName", newJString(applicationTypeName))
  add(query_594324, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  result = call_594322.call(path_594323, query_594324, nil, nil, nil)

var getApplicationManifest* = Call_GetApplicationManifest_594314(
    name: "getApplicationManifest", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest",
    validator: validate_GetApplicationManifest_594315, base: "",
    url: url_GetApplicationManifest_594316, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceManifest_594325 = ref object of OpenApiRestCall_593438
proc url_GetServiceManifest_594327(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceManifest_594326(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_594328 = path.getOrDefault("applicationTypeName")
  valid_594328 = validateParameter(valid_594328, JString, required = true,
                                 default = nil)
  if valid_594328 != nil:
    section.add "applicationTypeName", valid_594328
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  ##   ServiceManifestName: JString (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  var valid_594329 = query.getOrDefault("timeout")
  valid_594329 = validateParameter(valid_594329, JInt, required = false,
                                 default = newJInt(60))
  if valid_594329 != nil:
    section.add "timeout", valid_594329
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594330 = query.getOrDefault("api-version")
  valid_594330 = validateParameter(valid_594330, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594330 != nil:
    section.add "api-version", valid_594330
  var valid_594331 = query.getOrDefault("ApplicationTypeVersion")
  valid_594331 = validateParameter(valid_594331, JString, required = true,
                                 default = nil)
  if valid_594331 != nil:
    section.add "ApplicationTypeVersion", valid_594331
  var valid_594332 = query.getOrDefault("ServiceManifestName")
  valid_594332 = validateParameter(valid_594332, JString, required = true,
                                 default = nil)
  if valid_594332 != nil:
    section.add "ServiceManifestName", valid_594332
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594333: Call_GetServiceManifest_594325; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  let valid = call_594333.validator(path, query, header, formData, body)
  let scheme = call_594333.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594333.url(scheme.get, call_594333.host, call_594333.base,
                         call_594333.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594333, url, valid)

proc call*(call_594334: Call_GetServiceManifest_594325;
          applicationTypeName: string; ApplicationTypeVersion: string;
          ServiceManifestName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceManifest
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  ##   ServiceManifestName: string (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  var path_594335 = newJObject()
  var query_594336 = newJObject()
  add(query_594336, "timeout", newJInt(timeout))
  add(query_594336, "api-version", newJString(apiVersion))
  add(path_594335, "applicationTypeName", newJString(applicationTypeName))
  add(query_594336, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_594336, "ServiceManifestName", newJString(ServiceManifestName))
  result = call_594334.call(path_594335, query_594336, nil, nil, nil)

var getServiceManifest* = Call_GetServiceManifest_594325(
    name: "getServiceManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceManifest",
    validator: validate_GetServiceManifest_594326, base: "",
    url: url_GetServiceManifest_594327, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceTypeInfoList_594337 = ref object of OpenApiRestCall_593438
proc url_GetServiceTypeInfoList_594339(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceTypeInfoList_594338(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_594340 = path.getOrDefault("applicationTypeName")
  valid_594340 = validateParameter(valid_594340, JString, required = true,
                                 default = nil)
  if valid_594340 != nil:
    section.add "applicationTypeName", valid_594340
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  section = newJObject()
  var valid_594341 = query.getOrDefault("timeout")
  valid_594341 = validateParameter(valid_594341, JInt, required = false,
                                 default = newJInt(60))
  if valid_594341 != nil:
    section.add "timeout", valid_594341
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594342 = query.getOrDefault("api-version")
  valid_594342 = validateParameter(valid_594342, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594342 != nil:
    section.add "api-version", valid_594342
  var valid_594343 = query.getOrDefault("ApplicationTypeVersion")
  valid_594343 = validateParameter(valid_594343, JString, required = true,
                                 default = nil)
  if valid_594343 != nil:
    section.add "ApplicationTypeVersion", valid_594343
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594344: Call_GetServiceTypeInfoList_594337; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  let valid = call_594344.validator(path, query, header, formData, body)
  let scheme = call_594344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594344.url(scheme.get, call_594344.host, call_594344.base,
                         call_594344.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594344, url, valid)

proc call*(call_594345: Call_GetServiceTypeInfoList_594337;
          applicationTypeName: string; ApplicationTypeVersion: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceTypeInfoList
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  var path_594346 = newJObject()
  var query_594347 = newJObject()
  add(query_594347, "timeout", newJInt(timeout))
  add(query_594347, "api-version", newJString(apiVersion))
  add(path_594346, "applicationTypeName", newJString(applicationTypeName))
  add(query_594347, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  result = call_594345.call(path_594346, query_594347, nil, nil, nil)

var getServiceTypeInfoList* = Call_GetServiceTypeInfoList_594337(
    name: "getServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceTypes",
    validator: validate_GetServiceTypeInfoList_594338, base: "",
    url: url_GetServiceTypeInfoList_594339, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionApplicationType_594348 = ref object of OpenApiRestCall_593438
proc url_UnprovisionApplicationType_594350(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/Unprovision")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UnprovisionApplicationType_594349(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_594351 = path.getOrDefault("applicationTypeName")
  valid_594351 = validateParameter(valid_594351, JString, required = true,
                                 default = nil)
  if valid_594351 != nil:
    section.add "applicationTypeName", valid_594351
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594352 = query.getOrDefault("timeout")
  valid_594352 = validateParameter(valid_594352, JInt, required = false,
                                 default = newJInt(60))
  if valid_594352 != nil:
    section.add "timeout", valid_594352
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594353 = query.getOrDefault("api-version")
  valid_594353 = validateParameter(valid_594353, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594353 != nil:
    section.add "api-version", valid_594353
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594355: Call_UnprovisionApplicationType_594348; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  let valid = call_594355.validator(path, query, header, formData, body)
  let scheme = call_594355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594355.url(scheme.get, call_594355.host, call_594355.base,
                         call_594355.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594355, url, valid)

proc call*(call_594356: Call_UnprovisionApplicationType_594348;
          ApplicationTypeImageStoreVersion: JsonNode; applicationTypeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## unprovisionApplicationType
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  var path_594357 = newJObject()
  var query_594358 = newJObject()
  var body_594359 = newJObject()
  if ApplicationTypeImageStoreVersion != nil:
    body_594359 = ApplicationTypeImageStoreVersion
  add(query_594358, "timeout", newJInt(timeout))
  add(query_594358, "api-version", newJString(apiVersion))
  add(path_594357, "applicationTypeName", newJString(applicationTypeName))
  result = call_594356.call(path_594357, query_594358, nil, nil, body_594359)

var unprovisionApplicationType* = Call_UnprovisionApplicationType_594348(
    name: "unprovisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/Unprovision",
    validator: validate_UnprovisionApplicationType_594349, base: "",
    url: url_UnprovisionApplicationType_594350,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfoList_594360 = ref object of OpenApiRestCall_593438
proc url_GetApplicationInfoList_594362(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationInfoList_594361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationDefinitionKindFilter: JInt
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeName: JString
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_594363 = query.getOrDefault("timeout")
  valid_594363 = validateParameter(valid_594363, JInt, required = false,
                                 default = newJInt(60))
  if valid_594363 != nil:
    section.add "timeout", valid_594363
  var valid_594364 = query.getOrDefault("ApplicationDefinitionKindFilter")
  valid_594364 = validateParameter(valid_594364, JInt, required = false,
                                 default = newJInt(0))
  if valid_594364 != nil:
    section.add "ApplicationDefinitionKindFilter", valid_594364
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594365 = query.getOrDefault("api-version")
  valid_594365 = validateParameter(valid_594365, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594365 != nil:
    section.add "api-version", valid_594365
  var valid_594366 = query.getOrDefault("ApplicationTypeName")
  valid_594366 = validateParameter(valid_594366, JString, required = false,
                                 default = nil)
  if valid_594366 != nil:
    section.add "ApplicationTypeName", valid_594366
  var valid_594367 = query.getOrDefault("ContinuationToken")
  valid_594367 = validateParameter(valid_594367, JString, required = false,
                                 default = nil)
  if valid_594367 != nil:
    section.add "ContinuationToken", valid_594367
  var valid_594368 = query.getOrDefault("ExcludeApplicationParameters")
  valid_594368 = validateParameter(valid_594368, JBool, required = false,
                                 default = newJBool(false))
  if valid_594368 != nil:
    section.add "ExcludeApplicationParameters", valid_594368
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594369: Call_GetApplicationInfoList_594360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  let valid = call_594369.validator(path, query, header, formData, body)
  let scheme = call_594369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594369.url(scheme.get, call_594369.host, call_594369.base,
                         call_594369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594369, url, valid)

proc call*(call_594370: Call_GetApplicationInfoList_594360; timeout: int = 60;
          ApplicationDefinitionKindFilter: int = 0; apiVersion: string = "6.0";
          ApplicationTypeName: string = ""; ContinuationToken: string = "";
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfoList
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationDefinitionKindFilter: int
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeName: string
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_594371 = newJObject()
  add(query_594371, "timeout", newJInt(timeout))
  add(query_594371, "ApplicationDefinitionKindFilter",
      newJInt(ApplicationDefinitionKindFilter))
  add(query_594371, "api-version", newJString(apiVersion))
  add(query_594371, "ApplicationTypeName", newJString(ApplicationTypeName))
  add(query_594371, "ContinuationToken", newJString(ContinuationToken))
  add(query_594371, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_594370.call(nil, query_594371, nil, nil, nil)

var getApplicationInfoList* = Call_GetApplicationInfoList_594360(
    name: "getApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications",
    validator: validate_GetApplicationInfoList_594361, base: "",
    url: url_GetApplicationInfoList_594362, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateApplication_594372 = ref object of OpenApiRestCall_593438
proc url_CreateApplication_594374(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateApplication_594373(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Creates a Service Fabric application using the specified description.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594375 = query.getOrDefault("timeout")
  valid_594375 = validateParameter(valid_594375, JInt, required = false,
                                 default = newJInt(60))
  if valid_594375 != nil:
    section.add "timeout", valid_594375
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594376 = query.getOrDefault("api-version")
  valid_594376 = validateParameter(valid_594376, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594376 != nil:
    section.add "api-version", valid_594376
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594378: Call_CreateApplication_594372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric application using the specified description.
  ## 
  let valid = call_594378.validator(path, query, header, formData, body)
  let scheme = call_594378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594378.url(scheme.get, call_594378.host, call_594378.base,
                         call_594378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594378, url, valid)

proc call*(call_594379: Call_CreateApplication_594372;
          ApplicationDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## createApplication
  ## Creates a Service Fabric application using the specified description.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  var query_594380 = newJObject()
  var body_594381 = newJObject()
  add(query_594380, "timeout", newJInt(timeout))
  add(query_594380, "api-version", newJString(apiVersion))
  if ApplicationDescription != nil:
    body_594381 = ApplicationDescription
  result = call_594379.call(nil, query_594380, nil, nil, body_594381)

var createApplication* = Call_CreateApplication_594372(name: "createApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/$/Create", validator: validate_CreateApplication_594373,
    base: "", url: url_CreateApplication_594374,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfo_594382 = ref object of OpenApiRestCall_593438
proc url_GetApplicationInfo_594384(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationInfo_594383(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594385 = path.getOrDefault("applicationId")
  valid_594385 = validateParameter(valid_594385, JString, required = true,
                                 default = nil)
  if valid_594385 != nil:
    section.add "applicationId", valid_594385
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_594386 = query.getOrDefault("timeout")
  valid_594386 = validateParameter(valid_594386, JInt, required = false,
                                 default = newJInt(60))
  if valid_594386 != nil:
    section.add "timeout", valid_594386
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594387 = query.getOrDefault("api-version")
  valid_594387 = validateParameter(valid_594387, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594387 != nil:
    section.add "api-version", valid_594387
  var valid_594388 = query.getOrDefault("ExcludeApplicationParameters")
  valid_594388 = validateParameter(valid_594388, JBool, required = false,
                                 default = newJBool(false))
  if valid_594388 != nil:
    section.add "ExcludeApplicationParameters", valid_594388
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594389: Call_GetApplicationInfo_594382; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  let valid = call_594389.validator(path, query, header, formData, body)
  let scheme = call_594389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594389.url(scheme.get, call_594389.host, call_594389.base,
                         call_594389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594389, url, valid)

proc call*(call_594390: Call_GetApplicationInfo_594382; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfo
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var path_594391 = newJObject()
  var query_594392 = newJObject()
  add(query_594392, "timeout", newJInt(timeout))
  add(query_594392, "api-version", newJString(apiVersion))
  add(path_594391, "applicationId", newJString(applicationId))
  add(query_594392, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_594390.call(path_594391, query_594392, nil, nil, nil)

var getApplicationInfo* = Call_GetApplicationInfo_594382(
    name: "getApplicationInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}",
    validator: validate_GetApplicationInfo_594383, base: "",
    url: url_GetApplicationInfo_594384, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteApplication_594393 = ref object of OpenApiRestCall_593438
proc url_DeleteApplication_594395(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteApplication_594394(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594396 = path.getOrDefault("applicationId")
  valid_594396 = validateParameter(valid_594396, JString, required = true,
                                 default = nil)
  if valid_594396 != nil:
    section.add "applicationId", valid_594396
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_594397 = query.getOrDefault("timeout")
  valid_594397 = validateParameter(valid_594397, JInt, required = false,
                                 default = newJInt(60))
  if valid_594397 != nil:
    section.add "timeout", valid_594397
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594398 = query.getOrDefault("api-version")
  valid_594398 = validateParameter(valid_594398, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594398 != nil:
    section.add "api-version", valid_594398
  var valid_594399 = query.getOrDefault("ForceRemove")
  valid_594399 = validateParameter(valid_594399, JBool, required = false, default = nil)
  if valid_594399 != nil:
    section.add "ForceRemove", valid_594399
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594400: Call_DeleteApplication_594393; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  let valid = call_594400.validator(path, query, header, formData, body)
  let scheme = call_594400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594400.url(scheme.get, call_594400.host, call_594400.base,
                         call_594400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594400, url, valid)

proc call*(call_594401: Call_DeleteApplication_594393; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## deleteApplication
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594402 = newJObject()
  var query_594403 = newJObject()
  add(query_594403, "timeout", newJInt(timeout))
  add(query_594403, "api-version", newJString(apiVersion))
  add(query_594403, "ForceRemove", newJBool(ForceRemove))
  add(path_594402, "applicationId", newJString(applicationId))
  result = call_594401.call(path_594402, query_594403, nil, nil, nil)

var deleteApplication* = Call_DeleteApplication_594393(name: "deleteApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/Delete",
    validator: validate_DeleteApplication_594394, base: "",
    url: url_DeleteApplication_594395, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealthUsingPolicy_594418 = ref object of OpenApiRestCall_593438
proc url_GetApplicationHealthUsingPolicy_594420(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealthUsingPolicy_594419(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594421 = path.getOrDefault("applicationId")
  valid_594421 = validateParameter(valid_594421, JString, required = true,
                                 default = nil)
  if valid_594421 != nil:
    section.add "applicationId", valid_594421
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_594422 = query.getOrDefault("timeout")
  valid_594422 = validateParameter(valid_594422, JInt, required = false,
                                 default = newJInt(60))
  if valid_594422 != nil:
    section.add "timeout", valid_594422
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594423 = query.getOrDefault("api-version")
  valid_594423 = validateParameter(valid_594423, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594423 != nil:
    section.add "api-version", valid_594423
  var valid_594424 = query.getOrDefault("ExcludeHealthStatistics")
  valid_594424 = validateParameter(valid_594424, JBool, required = false,
                                 default = newJBool(false))
  if valid_594424 != nil:
    section.add "ExcludeHealthStatistics", valid_594424
  var valid_594425 = query.getOrDefault("EventsHealthStateFilter")
  valid_594425 = validateParameter(valid_594425, JInt, required = false,
                                 default = newJInt(0))
  if valid_594425 != nil:
    section.add "EventsHealthStateFilter", valid_594425
  var valid_594426 = query.getOrDefault("ServicesHealthStateFilter")
  valid_594426 = validateParameter(valid_594426, JInt, required = false,
                                 default = newJInt(0))
  if valid_594426 != nil:
    section.add "ServicesHealthStateFilter", valid_594426
  var valid_594427 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_594427 = validateParameter(valid_594427, JInt, required = false,
                                 default = newJInt(0))
  if valid_594427 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_594427
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594429: Call_GetApplicationHealthUsingPolicy_594418;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  let valid = call_594429.validator(path, query, header, formData, body)
  let scheme = call_594429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594429.url(scheme.get, call_594429.host, call_594429.base,
                         call_594429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594429, url, valid)

proc call*(call_594430: Call_GetApplicationHealthUsingPolicy_594418;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          ServicesHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealthUsingPolicy
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_594431 = newJObject()
  var query_594432 = newJObject()
  var body_594433 = newJObject()
  add(query_594432, "timeout", newJInt(timeout))
  add(query_594432, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_594433 = ApplicationHealthPolicy
  add(query_594432, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_594432, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_594431, "applicationId", newJString(applicationId))
  add(query_594432, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_594432, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_594430.call(path_594431, query_594432, nil, nil, body_594433)

var getApplicationHealthUsingPolicy* = Call_GetApplicationHealthUsingPolicy_594418(
    name: "getApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealthUsingPolicy_594419, base: "",
    url: url_GetApplicationHealthUsingPolicy_594420,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealth_594404 = ref object of OpenApiRestCall_593438
proc url_GetApplicationHealth_594406(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealth_594405(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594407 = path.getOrDefault("applicationId")
  valid_594407 = validateParameter(valid_594407, JString, required = true,
                                 default = nil)
  if valid_594407 != nil:
    section.add "applicationId", valid_594407
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_594408 = query.getOrDefault("timeout")
  valid_594408 = validateParameter(valid_594408, JInt, required = false,
                                 default = newJInt(60))
  if valid_594408 != nil:
    section.add "timeout", valid_594408
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594409 = query.getOrDefault("api-version")
  valid_594409 = validateParameter(valid_594409, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594409 != nil:
    section.add "api-version", valid_594409
  var valid_594410 = query.getOrDefault("ExcludeHealthStatistics")
  valid_594410 = validateParameter(valid_594410, JBool, required = false,
                                 default = newJBool(false))
  if valid_594410 != nil:
    section.add "ExcludeHealthStatistics", valid_594410
  var valid_594411 = query.getOrDefault("EventsHealthStateFilter")
  valid_594411 = validateParameter(valid_594411, JInt, required = false,
                                 default = newJInt(0))
  if valid_594411 != nil:
    section.add "EventsHealthStateFilter", valid_594411
  var valid_594412 = query.getOrDefault("ServicesHealthStateFilter")
  valid_594412 = validateParameter(valid_594412, JInt, required = false,
                                 default = newJInt(0))
  if valid_594412 != nil:
    section.add "ServicesHealthStateFilter", valid_594412
  var valid_594413 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_594413 = validateParameter(valid_594413, JInt, required = false,
                                 default = newJInt(0))
  if valid_594413 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_594413
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594414: Call_GetApplicationHealth_594404; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  let valid = call_594414.validator(path, query, header, formData, body)
  let scheme = call_594414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594414.url(scheme.get, call_594414.host, call_594414.base,
                         call_594414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594414, url, valid)

proc call*(call_594415: Call_GetApplicationHealth_594404; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          ServicesHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealth
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_594416 = newJObject()
  var query_594417 = newJObject()
  add(query_594417, "timeout", newJInt(timeout))
  add(query_594417, "api-version", newJString(apiVersion))
  add(query_594417, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_594417, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_594416, "applicationId", newJString(applicationId))
  add(query_594417, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_594417, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_594415.call(path_594416, query_594417, nil, nil, nil)

var getApplicationHealth* = Call_GetApplicationHealth_594404(
    name: "getApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealth_594405, base: "",
    url: url_GetApplicationHealth_594406, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationLoadInfo_594434 = ref object of OpenApiRestCall_593438
proc url_GetApplicationLoadInfo_594436(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationLoadInfo_594435(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594437 = path.getOrDefault("applicationId")
  valid_594437 = validateParameter(valid_594437, JString, required = true,
                                 default = nil)
  if valid_594437 != nil:
    section.add "applicationId", valid_594437
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594438 = query.getOrDefault("timeout")
  valid_594438 = validateParameter(valid_594438, JInt, required = false,
                                 default = newJInt(60))
  if valid_594438 != nil:
    section.add "timeout", valid_594438
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594439 = query.getOrDefault("api-version")
  valid_594439 = validateParameter(valid_594439, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594439 != nil:
    section.add "api-version", valid_594439
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594440: Call_GetApplicationLoadInfo_594434; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  let valid = call_594440.validator(path, query, header, formData, body)
  let scheme = call_594440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594440.url(scheme.get, call_594440.host, call_594440.base,
                         call_594440.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594440, url, valid)

proc call*(call_594441: Call_GetApplicationLoadInfo_594434; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationLoadInfo
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594442 = newJObject()
  var query_594443 = newJObject()
  add(query_594443, "timeout", newJInt(timeout))
  add(query_594443, "api-version", newJString(apiVersion))
  add(path_594442, "applicationId", newJString(applicationId))
  result = call_594441.call(path_594442, query_594443, nil, nil, nil)

var getApplicationLoadInfo* = Call_GetApplicationLoadInfo_594434(
    name: "getApplicationLoadInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetLoadInformation",
    validator: validate_GetApplicationLoadInfo_594435, base: "",
    url: url_GetApplicationLoadInfo_594436, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfoList_594444 = ref object of OpenApiRestCall_593438
proc url_GetServiceInfoList_594446(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfoList_594445(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594447 = path.getOrDefault("applicationId")
  valid_594447 = validateParameter(valid_594447, JString, required = true,
                                 default = nil)
  if valid_594447 != nil:
    section.add "applicationId", valid_594447
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: JString
  ##                  : The service type name used to filter the services to query for.
  section = newJObject()
  var valid_594448 = query.getOrDefault("timeout")
  valid_594448 = validateParameter(valid_594448, JInt, required = false,
                                 default = newJInt(60))
  if valid_594448 != nil:
    section.add "timeout", valid_594448
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594449 = query.getOrDefault("api-version")
  valid_594449 = validateParameter(valid_594449, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594449 != nil:
    section.add "api-version", valid_594449
  var valid_594450 = query.getOrDefault("ContinuationToken")
  valid_594450 = validateParameter(valid_594450, JString, required = false,
                                 default = nil)
  if valid_594450 != nil:
    section.add "ContinuationToken", valid_594450
  var valid_594451 = query.getOrDefault("ServiceTypeName")
  valid_594451 = validateParameter(valid_594451, JString, required = false,
                                 default = nil)
  if valid_594451 != nil:
    section.add "ServiceTypeName", valid_594451
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594452: Call_GetServiceInfoList_594444; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  let valid = call_594452.validator(path, query, header, formData, body)
  let scheme = call_594452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594452.url(scheme.get, call_594452.host, call_594452.base,
                         call_594452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594452, url, valid)

proc call*(call_594453: Call_GetServiceInfoList_594444; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = "";
          ServiceTypeName: string = ""): Recallable =
  ## getServiceInfoList
  ## Returns the information about all services belonging to the application specified by the application id.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: string
  ##                  : The service type name used to filter the services to query for.
  var path_594454 = newJObject()
  var query_594455 = newJObject()
  add(query_594455, "timeout", newJInt(timeout))
  add(query_594455, "api-version", newJString(apiVersion))
  add(path_594454, "applicationId", newJString(applicationId))
  add(query_594455, "ContinuationToken", newJString(ContinuationToken))
  add(query_594455, "ServiceTypeName", newJString(ServiceTypeName))
  result = call_594453.call(path_594454, query_594455, nil, nil, nil)

var getServiceInfoList* = Call_GetServiceInfoList_594444(
    name: "getServiceInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices",
    validator: validate_GetServiceInfoList_594445, base: "",
    url: url_GetServiceInfoList_594446, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateService_594456 = ref object of OpenApiRestCall_593438
proc url_CreateService_594458(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/$/Create")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateService_594457(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594459 = path.getOrDefault("applicationId")
  valid_594459 = validateParameter(valid_594459, JString, required = true,
                                 default = nil)
  if valid_594459 != nil:
    section.add "applicationId", valid_594459
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594460 = query.getOrDefault("timeout")
  valid_594460 = validateParameter(valid_594460, JInt, required = false,
                                 default = newJInt(60))
  if valid_594460 != nil:
    section.add "timeout", valid_594460
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594461 = query.getOrDefault("api-version")
  valid_594461 = validateParameter(valid_594461, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594461 != nil:
    section.add "api-version", valid_594461
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594463: Call_CreateService_594456; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified service.
  ## 
  let valid = call_594463.validator(path, query, header, formData, body)
  let scheme = call_594463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594463.url(scheme.get, call_594463.host, call_594463.base,
                         call_594463.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594463, url, valid)

proc call*(call_594464: Call_CreateService_594456; applicationId: string;
          ServiceDescription: JsonNode; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createService
  ## Creates the specified service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  var path_594465 = newJObject()
  var query_594466 = newJObject()
  var body_594467 = newJObject()
  add(query_594466, "timeout", newJInt(timeout))
  add(query_594466, "api-version", newJString(apiVersion))
  add(path_594465, "applicationId", newJString(applicationId))
  if ServiceDescription != nil:
    body_594467 = ServiceDescription
  result = call_594464.call(path_594465, query_594466, nil, nil, body_594467)

var createService* = Call_CreateService_594456(name: "createService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/Create",
    validator: validate_CreateService_594457, base: "", url: url_CreateService_594458,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateServiceFromTemplate_594468 = ref object of OpenApiRestCall_593438
proc url_CreateServiceFromTemplate_594470(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"), (
        kind: ConstantSegment, value: "/$/GetServices/$/CreateFromTemplate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateServiceFromTemplate_594469(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594471 = path.getOrDefault("applicationId")
  valid_594471 = validateParameter(valid_594471, JString, required = true,
                                 default = nil)
  if valid_594471 != nil:
    section.add "applicationId", valid_594471
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594472 = query.getOrDefault("timeout")
  valid_594472 = validateParameter(valid_594472, JInt, required = false,
                                 default = newJInt(60))
  if valid_594472 != nil:
    section.add "timeout", valid_594472
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594473 = query.getOrDefault("api-version")
  valid_594473 = validateParameter(valid_594473, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594473 != nil:
    section.add "api-version", valid_594473
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594475: Call_CreateServiceFromTemplate_594468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  let valid = call_594475.validator(path, query, header, formData, body)
  let scheme = call_594475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594475.url(scheme.get, call_594475.host, call_594475.base,
                         call_594475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594475, url, valid)

proc call*(call_594476: Call_CreateServiceFromTemplate_594468;
          ServiceFromTemplateDescription: JsonNode; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createServiceFromTemplate
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594477 = newJObject()
  var query_594478 = newJObject()
  var body_594479 = newJObject()
  add(query_594478, "timeout", newJInt(timeout))
  add(query_594478, "api-version", newJString(apiVersion))
  if ServiceFromTemplateDescription != nil:
    body_594479 = ServiceFromTemplateDescription
  add(path_594477, "applicationId", newJString(applicationId))
  result = call_594476.call(path_594477, query_594478, nil, nil, body_594479)

var createServiceFromTemplate* = Call_CreateServiceFromTemplate_594468(
    name: "createServiceFromTemplate", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/CreateFromTemplate",
    validator: validate_CreateServiceFromTemplate_594469, base: "",
    url: url_CreateServiceFromTemplate_594470,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfo_594480 = ref object of OpenApiRestCall_593438
proc url_GetServiceInfo_594482(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/"),
               (kind: VariableSegment, value: "serviceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfo_594481(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594483 = path.getOrDefault("applicationId")
  valid_594483 = validateParameter(valid_594483, JString, required = true,
                                 default = nil)
  if valid_594483 != nil:
    section.add "applicationId", valid_594483
  var valid_594484 = path.getOrDefault("serviceId")
  valid_594484 = validateParameter(valid_594484, JString, required = true,
                                 default = nil)
  if valid_594484 != nil:
    section.add "serviceId", valid_594484
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594485 = query.getOrDefault("timeout")
  valid_594485 = validateParameter(valid_594485, JInt, required = false,
                                 default = newJInt(60))
  if valid_594485 != nil:
    section.add "timeout", valid_594485
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594486 = query.getOrDefault("api-version")
  valid_594486 = validateParameter(valid_594486, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594486 != nil:
    section.add "api-version", valid_594486
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594487: Call_GetServiceInfo_594480; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  let valid = call_594487.validator(path, query, header, formData, body)
  let scheme = call_594487.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594487.url(scheme.get, call_594487.host, call_594487.base,
                         call_594487.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594487, url, valid)

proc call*(call_594488: Call_GetServiceInfo_594480; applicationId: string;
          serviceId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceInfo
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_594489 = newJObject()
  var query_594490 = newJObject()
  add(query_594490, "timeout", newJInt(timeout))
  add(query_594490, "api-version", newJString(apiVersion))
  add(path_594489, "applicationId", newJString(applicationId))
  add(path_594489, "serviceId", newJString(serviceId))
  result = call_594488.call(path_594489, query_594490, nil, nil, nil)

var getServiceInfo* = Call_GetServiceInfo_594480(name: "getServiceInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/{serviceId}",
    validator: validate_GetServiceInfo_594481, base: "", url: url_GetServiceInfo_594482,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationUpgrade_594491 = ref object of OpenApiRestCall_593438
proc url_GetApplicationUpgrade_594493(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationUpgrade_594492(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594494 = path.getOrDefault("applicationId")
  valid_594494 = validateParameter(valid_594494, JString, required = true,
                                 default = nil)
  if valid_594494 != nil:
    section.add "applicationId", valid_594494
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594495 = query.getOrDefault("timeout")
  valid_594495 = validateParameter(valid_594495, JInt, required = false,
                                 default = newJInt(60))
  if valid_594495 != nil:
    section.add "timeout", valid_594495
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594496 = query.getOrDefault("api-version")
  valid_594496 = validateParameter(valid_594496, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594496 != nil:
    section.add "api-version", valid_594496
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594497: Call_GetApplicationUpgrade_594491; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_594497.validator(path, query, header, formData, body)
  let scheme = call_594497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594497.url(scheme.get, call_594497.host, call_594497.base,
                         call_594497.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594497, url, valid)

proc call*(call_594498: Call_GetApplicationUpgrade_594491; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationUpgrade
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594499 = newJObject()
  var query_594500 = newJObject()
  add(query_594500, "timeout", newJInt(timeout))
  add(query_594500, "api-version", newJString(apiVersion))
  add(path_594499, "applicationId", newJString(applicationId))
  result = call_594498.call(path_594499, query_594500, nil, nil, nil)

var getApplicationUpgrade* = Call_GetApplicationUpgrade_594491(
    name: "getApplicationUpgrade", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetUpgradeProgress",
    validator: validate_GetApplicationUpgrade_594492, base: "",
    url: url_GetApplicationUpgrade_594493, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeApplicationUpgrade_594501 = ref object of OpenApiRestCall_593438
proc url_ResumeApplicationUpgrade_594503(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/MoveToNextUpgradeDomain")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResumeApplicationUpgrade_594502(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594504 = path.getOrDefault("applicationId")
  valid_594504 = validateParameter(valid_594504, JString, required = true,
                                 default = nil)
  if valid_594504 != nil:
    section.add "applicationId", valid_594504
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594505 = query.getOrDefault("timeout")
  valid_594505 = validateParameter(valid_594505, JInt, required = false,
                                 default = newJInt(60))
  if valid_594505 != nil:
    section.add "timeout", valid_594505
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594506 = query.getOrDefault("api-version")
  valid_594506 = validateParameter(valid_594506, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594506 != nil:
    section.add "api-version", valid_594506
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594508: Call_ResumeApplicationUpgrade_594501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  let valid = call_594508.validator(path, query, header, formData, body)
  let scheme = call_594508.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594508.url(scheme.get, call_594508.host, call_594508.base,
                         call_594508.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594508, url, valid)

proc call*(call_594509: Call_ResumeApplicationUpgrade_594501;
          ResumeApplicationUpgradeDescription: JsonNode; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## resumeApplicationUpgrade
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594510 = newJObject()
  var query_594511 = newJObject()
  var body_594512 = newJObject()
  add(query_594511, "timeout", newJInt(timeout))
  if ResumeApplicationUpgradeDescription != nil:
    body_594512 = ResumeApplicationUpgradeDescription
  add(query_594511, "api-version", newJString(apiVersion))
  add(path_594510, "applicationId", newJString(applicationId))
  result = call_594509.call(path_594510, query_594511, nil, nil, body_594512)

var resumeApplicationUpgrade* = Call_ResumeApplicationUpgrade_594501(
    name: "resumeApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeApplicationUpgrade_594502, base: "",
    url: url_ResumeApplicationUpgrade_594503, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportApplicationHealth_594513 = ref object of OpenApiRestCall_593438
proc url_ReportApplicationHealth_594515(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportApplicationHealth_594514(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594516 = path.getOrDefault("applicationId")
  valid_594516 = validateParameter(valid_594516, JString, required = true,
                                 default = nil)
  if valid_594516 != nil:
    section.add "applicationId", valid_594516
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594517 = query.getOrDefault("Immediate")
  valid_594517 = validateParameter(valid_594517, JBool, required = false,
                                 default = newJBool(false))
  if valid_594517 != nil:
    section.add "Immediate", valid_594517
  var valid_594518 = query.getOrDefault("timeout")
  valid_594518 = validateParameter(valid_594518, JInt, required = false,
                                 default = newJInt(60))
  if valid_594518 != nil:
    section.add "timeout", valid_594518
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594519 = query.getOrDefault("api-version")
  valid_594519 = validateParameter(valid_594519, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594519 != nil:
    section.add "api-version", valid_594519
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594521: Call_ReportApplicationHealth_594513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_594521.validator(path, query, header, formData, body)
  let scheme = call_594521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594521.url(scheme.get, call_594521.host, call_594521.base,
                         call_594521.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594521, url, valid)

proc call*(call_594522: Call_ReportApplicationHealth_594513;
          HealthInformation: JsonNode; applicationId: string;
          Immediate: bool = false; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportApplicationHealth
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594523 = newJObject()
  var query_594524 = newJObject()
  var body_594525 = newJObject()
  add(query_594524, "Immediate", newJBool(Immediate))
  add(query_594524, "timeout", newJInt(timeout))
  add(query_594524, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_594525 = HealthInformation
  add(path_594523, "applicationId", newJString(applicationId))
  result = call_594522.call(path_594523, query_594524, nil, nil, body_594525)

var reportApplicationHealth* = Call_ReportApplicationHealth_594513(
    name: "reportApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/ReportHealth",
    validator: validate_ReportApplicationHealth_594514, base: "",
    url: url_ReportApplicationHealth_594515, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackApplicationUpgrade_594526 = ref object of OpenApiRestCall_593438
proc url_RollbackApplicationUpgrade_594528(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/RollbackUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RollbackApplicationUpgrade_594527(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594529 = path.getOrDefault("applicationId")
  valid_594529 = validateParameter(valid_594529, JString, required = true,
                                 default = nil)
  if valid_594529 != nil:
    section.add "applicationId", valid_594529
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594530 = query.getOrDefault("timeout")
  valid_594530 = validateParameter(valid_594530, JInt, required = false,
                                 default = newJInt(60))
  if valid_594530 != nil:
    section.add "timeout", valid_594530
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594531 = query.getOrDefault("api-version")
  valid_594531 = validateParameter(valid_594531, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594531 != nil:
    section.add "api-version", valid_594531
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594532: Call_RollbackApplicationUpgrade_594526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  let valid = call_594532.validator(path, query, header, formData, body)
  let scheme = call_594532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594532.url(scheme.get, call_594532.host, call_594532.base,
                         call_594532.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594532, url, valid)

proc call*(call_594533: Call_RollbackApplicationUpgrade_594526;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## rollbackApplicationUpgrade
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594534 = newJObject()
  var query_594535 = newJObject()
  add(query_594535, "timeout", newJInt(timeout))
  add(query_594535, "api-version", newJString(apiVersion))
  add(path_594534, "applicationId", newJString(applicationId))
  result = call_594533.call(path_594534, query_594535, nil, nil, nil)

var rollbackApplicationUpgrade* = Call_RollbackApplicationUpgrade_594526(
    name: "rollbackApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/RollbackUpgrade",
    validator: validate_RollbackApplicationUpgrade_594527, base: "",
    url: url_RollbackApplicationUpgrade_594528,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateApplicationUpgrade_594536 = ref object of OpenApiRestCall_593438
proc url_UpdateApplicationUpgrade_594538(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/UpdateUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateApplicationUpgrade_594537(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594539 = path.getOrDefault("applicationId")
  valid_594539 = validateParameter(valid_594539, JString, required = true,
                                 default = nil)
  if valid_594539 != nil:
    section.add "applicationId", valid_594539
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594540 = query.getOrDefault("timeout")
  valid_594540 = validateParameter(valid_594540, JInt, required = false,
                                 default = newJInt(60))
  if valid_594540 != nil:
    section.add "timeout", valid_594540
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594541 = query.getOrDefault("api-version")
  valid_594541 = validateParameter(valid_594541, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594541 != nil:
    section.add "api-version", valid_594541
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594543: Call_UpdateApplicationUpgrade_594536; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  let valid = call_594543.validator(path, query, header, formData, body)
  let scheme = call_594543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594543.url(scheme.get, call_594543.host, call_594543.base,
                         call_594543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594543, url, valid)

proc call*(call_594544: Call_UpdateApplicationUpgrade_594536;
          applicationId: string; ApplicationUpgradeUpdateDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## updateApplicationUpgrade
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  var path_594545 = newJObject()
  var query_594546 = newJObject()
  var body_594547 = newJObject()
  add(query_594546, "timeout", newJInt(timeout))
  add(query_594546, "api-version", newJString(apiVersion))
  add(path_594545, "applicationId", newJString(applicationId))
  if ApplicationUpgradeUpdateDescription != nil:
    body_594547 = ApplicationUpgradeUpdateDescription
  result = call_594544.call(path_594545, query_594546, nil, nil, body_594547)

var updateApplicationUpgrade* = Call_UpdateApplicationUpgrade_594536(
    name: "updateApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/UpdateUpgrade",
    validator: validate_UpdateApplicationUpgrade_594537, base: "",
    url: url_UpdateApplicationUpgrade_594538, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartApplicationUpgrade_594548 = ref object of OpenApiRestCall_593438
proc url_StartApplicationUpgrade_594550(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartApplicationUpgrade_594549(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_594551 = path.getOrDefault("applicationId")
  valid_594551 = validateParameter(valid_594551, JString, required = true,
                                 default = nil)
  if valid_594551 != nil:
    section.add "applicationId", valid_594551
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594552 = query.getOrDefault("timeout")
  valid_594552 = validateParameter(valid_594552, JInt, required = false,
                                 default = newJInt(60))
  if valid_594552 != nil:
    section.add "timeout", valid_594552
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594553 = query.getOrDefault("api-version")
  valid_594553 = validateParameter(valid_594553, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594553 != nil:
    section.add "api-version", valid_594553
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594555: Call_StartApplicationUpgrade_594548; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  let valid = call_594555.validator(path, query, header, formData, body)
  let scheme = call_594555.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594555.url(scheme.get, call_594555.host, call_594555.base,
                         call_594555.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594555, url, valid)

proc call*(call_594556: Call_StartApplicationUpgrade_594548; applicationId: string;
          ApplicationUpgradeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## startApplicationUpgrade
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  var path_594557 = newJObject()
  var query_594558 = newJObject()
  var body_594559 = newJObject()
  add(query_594558, "timeout", newJInt(timeout))
  add(query_594558, "api-version", newJString(apiVersion))
  add(path_594557, "applicationId", newJString(applicationId))
  if ApplicationUpgradeDescription != nil:
    body_594559 = ApplicationUpgradeDescription
  result = call_594556.call(path_594557, query_594558, nil, nil, body_594559)

var startApplicationUpgrade* = Call_StartApplicationUpgrade_594548(
    name: "startApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/Upgrade",
    validator: validate_StartApplicationUpgrade_594549, base: "",
    url: url_StartApplicationUpgrade_594550, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatusList_594560 = ref object of OpenApiRestCall_593438
proc url_GetComposeDeploymentStatusList_594562(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetComposeDeploymentStatusList_594561(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  section = newJObject()
  var valid_594563 = query.getOrDefault("timeout")
  valid_594563 = validateParameter(valid_594563, JInt, required = false,
                                 default = newJInt(60))
  if valid_594563 != nil:
    section.add "timeout", valid_594563
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594564 = query.getOrDefault("api-version")
  valid_594564 = validateParameter(valid_594564, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594564 != nil:
    section.add "api-version", valid_594564
  var valid_594565 = query.getOrDefault("ContinuationToken")
  valid_594565 = validateParameter(valid_594565, JString, required = false,
                                 default = nil)
  if valid_594565 != nil:
    section.add "ContinuationToken", valid_594565
  var valid_594566 = query.getOrDefault("MaxResults")
  valid_594566 = validateParameter(valid_594566, JInt, required = false,
                                 default = newJInt(0))
  if valid_594566 != nil:
    section.add "MaxResults", valid_594566
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594567: Call_GetComposeDeploymentStatusList_594560; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  let valid = call_594567.validator(path, query, header, formData, body)
  let scheme = call_594567.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594567.url(scheme.get, call_594567.host, call_594567.base,
                         call_594567.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594567, url, valid)

proc call*(call_594568: Call_GetComposeDeploymentStatusList_594560;
          timeout: int = 60; apiVersion: string = "6.0-preview";
          ContinuationToken: string = ""; MaxResults: int = 0): Recallable =
  ## getComposeDeploymentStatusList
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  var query_594569 = newJObject()
  add(query_594569, "timeout", newJInt(timeout))
  add(query_594569, "api-version", newJString(apiVersion))
  add(query_594569, "ContinuationToken", newJString(ContinuationToken))
  add(query_594569, "MaxResults", newJInt(MaxResults))
  result = call_594568.call(nil, query_594569, nil, nil, nil)

var getComposeDeploymentStatusList* = Call_GetComposeDeploymentStatusList_594560(
    name: "getComposeDeploymentStatusList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments",
    validator: validate_GetComposeDeploymentStatusList_594561, base: "",
    url: url_GetComposeDeploymentStatusList_594562,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateComposeDeployment_594570 = ref object of OpenApiRestCall_593438
proc url_CreateComposeDeployment_594572(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateComposeDeployment_594571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_594573 = query.getOrDefault("timeout")
  valid_594573 = validateParameter(valid_594573, JInt, required = false,
                                 default = newJInt(60))
  if valid_594573 != nil:
    section.add "timeout", valid_594573
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594574 = query.getOrDefault("api-version")
  valid_594574 = validateParameter(valid_594574, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594574 != nil:
    section.add "api-version", valid_594574
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594576: Call_CreateComposeDeployment_594570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric compose deployment.
  ## 
  let valid = call_594576.validator(path, query, header, formData, body)
  let scheme = call_594576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594576.url(scheme.get, call_594576.host, call_594576.base,
                         call_594576.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594576, url, valid)

proc call*(call_594577: Call_CreateComposeDeployment_594570;
          CreateComposeDeploymentDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## createComposeDeployment
  ## Creates a Service Fabric compose deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  var query_594578 = newJObject()
  var body_594579 = newJObject()
  add(query_594578, "timeout", newJInt(timeout))
  add(query_594578, "api-version", newJString(apiVersion))
  if CreateComposeDeploymentDescription != nil:
    body_594579 = CreateComposeDeploymentDescription
  result = call_594577.call(nil, query_594578, nil, nil, body_594579)

var createComposeDeployment* = Call_CreateComposeDeployment_594570(
    name: "createComposeDeployment", meth: HttpMethod.HttpPut,
    host: "azure.local:19080", route: "/ComposeDeployments/$/Create",
    validator: validate_CreateComposeDeployment_594571, base: "",
    url: url_CreateComposeDeployment_594572, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatus_594580 = ref object of OpenApiRestCall_593438
proc url_GetComposeDeploymentStatus_594582(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentStatus_594581(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_594583 = path.getOrDefault("deploymentName")
  valid_594583 = validateParameter(valid_594583, JString, required = true,
                                 default = nil)
  if valid_594583 != nil:
    section.add "deploymentName", valid_594583
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_594584 = query.getOrDefault("timeout")
  valid_594584 = validateParameter(valid_594584, JInt, required = false,
                                 default = newJInt(60))
  if valid_594584 != nil:
    section.add "timeout", valid_594584
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594585 = query.getOrDefault("api-version")
  valid_594585 = validateParameter(valid_594585, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594585 != nil:
    section.add "api-version", valid_594585
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594586: Call_GetComposeDeploymentStatus_594580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  let valid = call_594586.validator(path, query, header, formData, body)
  let scheme = call_594586.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594586.url(scheme.get, call_594586.host, call_594586.base,
                         call_594586.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594586, url, valid)

proc call*(call_594587: Call_GetComposeDeploymentStatus_594580;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## getComposeDeploymentStatus
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_594588 = newJObject()
  var query_594589 = newJObject()
  add(query_594589, "timeout", newJInt(timeout))
  add(query_594589, "api-version", newJString(apiVersion))
  add(path_594588, "deploymentName", newJString(deploymentName))
  result = call_594587.call(path_594588, query_594589, nil, nil, nil)

var getComposeDeploymentStatus* = Call_GetComposeDeploymentStatus_594580(
    name: "getComposeDeploymentStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments/{deploymentName}",
    validator: validate_GetComposeDeploymentStatus_594581, base: "",
    url: url_GetComposeDeploymentStatus_594582,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveComposeDeployment_594590 = ref object of OpenApiRestCall_593438
proc url_RemoveComposeDeployment_594592(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveComposeDeployment_594591(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_594593 = path.getOrDefault("deploymentName")
  valid_594593 = validateParameter(valid_594593, JString, required = true,
                                 default = nil)
  if valid_594593 != nil:
    section.add "deploymentName", valid_594593
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_594594 = query.getOrDefault("timeout")
  valid_594594 = validateParameter(valid_594594, JInt, required = false,
                                 default = newJInt(60))
  if valid_594594 != nil:
    section.add "timeout", valid_594594
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594595 = query.getOrDefault("api-version")
  valid_594595 = validateParameter(valid_594595, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594595 != nil:
    section.add "api-version", valid_594595
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594596: Call_RemoveComposeDeployment_594590; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  let valid = call_594596.validator(path, query, header, formData, body)
  let scheme = call_594596.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594596.url(scheme.get, call_594596.host, call_594596.base,
                         call_594596.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594596, url, valid)

proc call*(call_594597: Call_RemoveComposeDeployment_594590;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## removeComposeDeployment
  ## Deletes an existing Service Fabric compose deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_594598 = newJObject()
  var query_594599 = newJObject()
  add(query_594599, "timeout", newJInt(timeout))
  add(query_594599, "api-version", newJString(apiVersion))
  add(path_594598, "deploymentName", newJString(deploymentName))
  result = call_594597.call(path_594598, query_594599, nil, nil, nil)

var removeComposeDeployment* = Call_RemoveComposeDeployment_594590(
    name: "removeComposeDeployment", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Delete",
    validator: validate_RemoveComposeDeployment_594591, base: "",
    url: url_RemoveComposeDeployment_594592, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentUpgradeProgress_594600 = ref object of OpenApiRestCall_593438
proc url_GetComposeDeploymentUpgradeProgress_594602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentUpgradeProgress_594601(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_594603 = path.getOrDefault("deploymentName")
  valid_594603 = validateParameter(valid_594603, JString, required = true,
                                 default = nil)
  if valid_594603 != nil:
    section.add "deploymentName", valid_594603
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_594604 = query.getOrDefault("timeout")
  valid_594604 = validateParameter(valid_594604, JInt, required = false,
                                 default = newJInt(60))
  if valid_594604 != nil:
    section.add "timeout", valid_594604
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594605 = query.getOrDefault("api-version")
  valid_594605 = validateParameter(valid_594605, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594605 != nil:
    section.add "api-version", valid_594605
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594606: Call_GetComposeDeploymentUpgradeProgress_594600;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_594606.validator(path, query, header, formData, body)
  let scheme = call_594606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594606.url(scheme.get, call_594606.host, call_594606.base,
                         call_594606.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594606, url, valid)

proc call*(call_594607: Call_GetComposeDeploymentUpgradeProgress_594600;
          deploymentName: string; timeout: int = 60;
          apiVersion: string = "6.0-preview"): Recallable =
  ## getComposeDeploymentUpgradeProgress
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  var path_594608 = newJObject()
  var query_594609 = newJObject()
  add(query_594609, "timeout", newJInt(timeout))
  add(query_594609, "api-version", newJString(apiVersion))
  add(path_594608, "deploymentName", newJString(deploymentName))
  result = call_594607.call(path_594608, query_594609, nil, nil, nil)

var getComposeDeploymentUpgradeProgress* = Call_GetComposeDeploymentUpgradeProgress_594600(
    name: "getComposeDeploymentUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/GetUpgradeProgress",
    validator: validate_GetComposeDeploymentUpgradeProgress_594601, base: "",
    url: url_GetComposeDeploymentUpgradeProgress_594602,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartComposeDeploymentUpgrade_594610 = ref object of OpenApiRestCall_593438
proc url_StartComposeDeploymentUpgrade_594612(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartComposeDeploymentUpgrade_594611(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_594613 = path.getOrDefault("deploymentName")
  valid_594613 = validateParameter(valid_594613, JString, required = true,
                                 default = nil)
  if valid_594613 != nil:
    section.add "deploymentName", valid_594613
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  section = newJObject()
  var valid_594614 = query.getOrDefault("timeout")
  valid_594614 = validateParameter(valid_594614, JInt, required = false,
                                 default = newJInt(60))
  if valid_594614 != nil:
    section.add "timeout", valid_594614
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594615 = query.getOrDefault("api-version")
  valid_594615 = validateParameter(valid_594615, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_594615 != nil:
    section.add "api-version", valid_594615
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594617: Call_StartComposeDeploymentUpgrade_594610; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  let valid = call_594617.validator(path, query, header, formData, body)
  let scheme = call_594617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594617.url(scheme.get, call_594617.host, call_594617.base,
                         call_594617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594617, url, valid)

proc call*(call_594618: Call_StartComposeDeploymentUpgrade_594610;
          deploymentName: string; ComposeDeploymentUpgradeDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0-preview"): Recallable =
  ## startComposeDeploymentUpgrade
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  var path_594619 = newJObject()
  var query_594620 = newJObject()
  var body_594621 = newJObject()
  add(query_594620, "timeout", newJInt(timeout))
  add(query_594620, "api-version", newJString(apiVersion))
  add(path_594619, "deploymentName", newJString(deploymentName))
  if ComposeDeploymentUpgradeDescription != nil:
    body_594621 = ComposeDeploymentUpgradeDescription
  result = call_594618.call(path_594619, query_594620, nil, nil, body_594621)

var startComposeDeploymentUpgrade* = Call_StartComposeDeploymentUpgrade_594610(
    name: "startComposeDeploymentUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Upgrade",
    validator: validate_StartComposeDeploymentUpgrade_594611, base: "",
    url: url_StartComposeDeploymentUpgrade_594612,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetFaultOperationList_594622 = ref object of OpenApiRestCall_593438
proc url_GetFaultOperationList_594624(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetFaultOperationList_594623(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TypeFilter: JInt (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: JInt (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  section = newJObject()
  var valid_594625 = query.getOrDefault("timeout")
  valid_594625 = validateParameter(valid_594625, JInt, required = false,
                                 default = newJInt(60))
  if valid_594625 != nil:
    section.add "timeout", valid_594625
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594626 = query.getOrDefault("api-version")
  valid_594626 = validateParameter(valid_594626, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594626 != nil:
    section.add "api-version", valid_594626
  var valid_594627 = query.getOrDefault("TypeFilter")
  valid_594627 = validateParameter(valid_594627, JInt, required = true,
                                 default = newJInt(65535))
  if valid_594627 != nil:
    section.add "TypeFilter", valid_594627
  var valid_594628 = query.getOrDefault("StateFilter")
  valid_594628 = validateParameter(valid_594628, JInt, required = true,
                                 default = newJInt(65535))
  if valid_594628 != nil:
    section.add "StateFilter", valid_594628
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594629: Call_GetFaultOperationList_594622; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  let valid = call_594629.validator(path, query, header, formData, body)
  let scheme = call_594629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594629.url(scheme.get, call_594629.host, call_594629.base,
                         call_594629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594629, url, valid)

proc call*(call_594630: Call_GetFaultOperationList_594622; timeout: int = 60;
          apiVersion: string = "6.0"; TypeFilter: int = 65535; StateFilter: int = 65535): Recallable =
  ## getFaultOperationList
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   TypeFilter: int (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: int (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  var query_594631 = newJObject()
  add(query_594631, "timeout", newJInt(timeout))
  add(query_594631, "api-version", newJString(apiVersion))
  add(query_594631, "TypeFilter", newJInt(TypeFilter))
  add(query_594631, "StateFilter", newJInt(StateFilter))
  result = call_594630.call(nil, query_594631, nil, nil, nil)

var getFaultOperationList* = Call_GetFaultOperationList_594622(
    name: "getFaultOperationList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/",
    validator: validate_GetFaultOperationList_594623, base: "",
    url: url_GetFaultOperationList_594624, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelOperation_594632 = ref object of OpenApiRestCall_593438
proc url_CancelOperation_594634(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelOperation_594633(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   Force: JBool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  section = newJObject()
  var valid_594635 = query.getOrDefault("timeout")
  valid_594635 = validateParameter(valid_594635, JInt, required = false,
                                 default = newJInt(60))
  if valid_594635 != nil:
    section.add "timeout", valid_594635
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594636 = query.getOrDefault("api-version")
  valid_594636 = validateParameter(valid_594636, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594636 != nil:
    section.add "api-version", valid_594636
  var valid_594637 = query.getOrDefault("OperationId")
  valid_594637 = validateParameter(valid_594637, JString, required = true,
                                 default = nil)
  if valid_594637 != nil:
    section.add "OperationId", valid_594637
  var valid_594638 = query.getOrDefault("Force")
  valid_594638 = validateParameter(valid_594638, JBool, required = true,
                                 default = newJBool(false))
  if valid_594638 != nil:
    section.add "Force", valid_594638
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594639: Call_CancelOperation_594632; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  let valid = call_594639.validator(path, query, header, formData, body)
  let scheme = call_594639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594639.url(scheme.get, call_594639.host, call_594639.base,
                         call_594639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594639, url, valid)

proc call*(call_594640: Call_CancelOperation_594632; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0"; Force: bool = false): Recallable =
  ## cancelOperation
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   Force: bool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  var query_594641 = newJObject()
  add(query_594641, "timeout", newJInt(timeout))
  add(query_594641, "api-version", newJString(apiVersion))
  add(query_594641, "OperationId", newJString(OperationId))
  add(query_594641, "Force", newJBool(Force))
  result = call_594640.call(nil, query_594641, nil, nil, nil)

var cancelOperation* = Call_CancelOperation_594632(name: "cancelOperation",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/$/Cancel",
    validator: validate_CancelOperation_594633, base: "", url: url_CancelOperation_594634,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeTransitionProgress_594642 = ref object of OpenApiRestCall_593438
proc url_GetNodeTransitionProgress_594644(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetTransitionProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeTransitionProgress_594643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594645 = path.getOrDefault("nodeName")
  valid_594645 = validateParameter(valid_594645, JString, required = true,
                                 default = nil)
  if valid_594645 != nil:
    section.add "nodeName", valid_594645
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594646 = query.getOrDefault("timeout")
  valid_594646 = validateParameter(valid_594646, JInt, required = false,
                                 default = newJInt(60))
  if valid_594646 != nil:
    section.add "timeout", valid_594646
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594647 = query.getOrDefault("api-version")
  valid_594647 = validateParameter(valid_594647, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594647 != nil:
    section.add "api-version", valid_594647
  var valid_594648 = query.getOrDefault("OperationId")
  valid_594648 = validateParameter(valid_594648, JString, required = true,
                                 default = nil)
  if valid_594648 != nil:
    section.add "OperationId", valid_594648
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594649: Call_GetNodeTransitionProgress_594642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  let valid = call_594649.validator(path, query, header, formData, body)
  let scheme = call_594649.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594649.url(scheme.get, call_594649.host, call_594649.base,
                         call_594649.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594649, url, valid)

proc call*(call_594650: Call_GetNodeTransitionProgress_594642; nodeName: string;
          OperationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNodeTransitionProgress
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594651 = newJObject()
  var query_594652 = newJObject()
  add(query_594652, "timeout", newJInt(timeout))
  add(query_594652, "api-version", newJString(apiVersion))
  add(path_594651, "nodeName", newJString(nodeName))
  add(query_594652, "OperationId", newJString(OperationId))
  result = call_594650.call(path_594651, query_594652, nil, nil, nil)

var getNodeTransitionProgress* = Call_GetNodeTransitionProgress_594642(
    name: "getNodeTransitionProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/GetTransitionProgress",
    validator: validate_GetNodeTransitionProgress_594643, base: "",
    url: url_GetNodeTransitionProgress_594644,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartNodeTransition_594653 = ref object of OpenApiRestCall_593438
proc url_StartNodeTransition_594655(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/StartTransition/")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartNodeTransition_594654(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594656 = path.getOrDefault("nodeName")
  valid_594656 = validateParameter(valid_594656, JString, required = true,
                                 default = nil)
  if valid_594656 != nil:
    section.add "nodeName", valid_594656
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeInstanceId: JString (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   StopDurationInSeconds: JInt (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   NodeTransitionType: JString (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594657 = query.getOrDefault("timeout")
  valid_594657 = validateParameter(valid_594657, JInt, required = false,
                                 default = newJInt(60))
  if valid_594657 != nil:
    section.add "timeout", valid_594657
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594658 = query.getOrDefault("api-version")
  valid_594658 = validateParameter(valid_594658, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594658 != nil:
    section.add "api-version", valid_594658
  var valid_594659 = query.getOrDefault("NodeInstanceId")
  valid_594659 = validateParameter(valid_594659, JString, required = true,
                                 default = nil)
  if valid_594659 != nil:
    section.add "NodeInstanceId", valid_594659
  var valid_594660 = query.getOrDefault("StopDurationInSeconds")
  valid_594660 = validateParameter(valid_594660, JInt, required = true, default = nil)
  if valid_594660 != nil:
    section.add "StopDurationInSeconds", valid_594660
  var valid_594661 = query.getOrDefault("NodeTransitionType")
  valid_594661 = validateParameter(valid_594661, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_594661 != nil:
    section.add "NodeTransitionType", valid_594661
  var valid_594662 = query.getOrDefault("OperationId")
  valid_594662 = validateParameter(valid_594662, JString, required = true,
                                 default = nil)
  if valid_594662 != nil:
    section.add "OperationId", valid_594662
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594663: Call_StartNodeTransition_594653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  let valid = call_594663.validator(path, query, header, formData, body)
  let scheme = call_594663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594663.url(scheme.get, call_594663.host, call_594663.base,
                         call_594663.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594663, url, valid)

proc call*(call_594664: Call_StartNodeTransition_594653; nodeName: string;
          NodeInstanceId: string; StopDurationInSeconds: int; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          NodeTransitionType: string = "Invalid"): Recallable =
  ## startNodeTransition
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   NodeInstanceId: string (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   StopDurationInSeconds: int (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   NodeTransitionType: string (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594665 = newJObject()
  var query_594666 = newJObject()
  add(query_594666, "timeout", newJInt(timeout))
  add(query_594666, "api-version", newJString(apiVersion))
  add(path_594665, "nodeName", newJString(nodeName))
  add(query_594666, "NodeInstanceId", newJString(NodeInstanceId))
  add(query_594666, "StopDurationInSeconds", newJInt(StopDurationInSeconds))
  add(query_594666, "NodeTransitionType", newJString(NodeTransitionType))
  add(query_594666, "OperationId", newJString(OperationId))
  result = call_594664.call(path_594665, query_594666, nil, nil, nil)

var startNodeTransition* = Call_StartNodeTransition_594653(
    name: "startNodeTransition", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/StartTransition/",
    validator: validate_StartNodeTransition_594654, base: "",
    url: url_StartNodeTransition_594655, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDataLossProgress_594667 = ref object of OpenApiRestCall_593438
proc url_GetDataLossProgress_594669(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetDataLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDataLossProgress_594668(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594670 = path.getOrDefault("partitionId")
  valid_594670 = validateParameter(valid_594670, JString, required = true,
                                 default = nil)
  if valid_594670 != nil:
    section.add "partitionId", valid_594670
  var valid_594671 = path.getOrDefault("serviceId")
  valid_594671 = validateParameter(valid_594671, JString, required = true,
                                 default = nil)
  if valid_594671 != nil:
    section.add "serviceId", valid_594671
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594672 = query.getOrDefault("timeout")
  valid_594672 = validateParameter(valid_594672, JInt, required = false,
                                 default = newJInt(60))
  if valid_594672 != nil:
    section.add "timeout", valid_594672
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594673 = query.getOrDefault("api-version")
  valid_594673 = validateParameter(valid_594673, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594673 != nil:
    section.add "api-version", valid_594673
  var valid_594674 = query.getOrDefault("OperationId")
  valid_594674 = validateParameter(valid_594674, JString, required = true,
                                 default = nil)
  if valid_594674 != nil:
    section.add "OperationId", valid_594674
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594675: Call_GetDataLossProgress_594667; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  let valid = call_594675.validator(path, query, header, formData, body)
  let scheme = call_594675.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594675.url(scheme.get, call_594675.host, call_594675.base,
                         call_594675.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594675, url, valid)

proc call*(call_594676: Call_GetDataLossProgress_594667; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDataLossProgress
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594677 = newJObject()
  var query_594678 = newJObject()
  add(query_594678, "timeout", newJInt(timeout))
  add(query_594678, "api-version", newJString(apiVersion))
  add(path_594677, "partitionId", newJString(partitionId))
  add(path_594677, "serviceId", newJString(serviceId))
  add(query_594678, "OperationId", newJString(OperationId))
  result = call_594676.call(path_594677, query_594678, nil, nil, nil)

var getDataLossProgress* = Call_GetDataLossProgress_594667(
    name: "getDataLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress",
    validator: validate_GetDataLossProgress_594668, base: "",
    url: url_GetDataLossProgress_594669, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetQuorumLossProgress_594679 = ref object of OpenApiRestCall_593438
proc url_GetQuorumLossProgress_594681(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetQuorumLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetQuorumLossProgress_594680(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594682 = path.getOrDefault("partitionId")
  valid_594682 = validateParameter(valid_594682, JString, required = true,
                                 default = nil)
  if valid_594682 != nil:
    section.add "partitionId", valid_594682
  var valid_594683 = path.getOrDefault("serviceId")
  valid_594683 = validateParameter(valid_594683, JString, required = true,
                                 default = nil)
  if valid_594683 != nil:
    section.add "serviceId", valid_594683
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594684 = query.getOrDefault("timeout")
  valid_594684 = validateParameter(valid_594684, JInt, required = false,
                                 default = newJInt(60))
  if valid_594684 != nil:
    section.add "timeout", valid_594684
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594685 = query.getOrDefault("api-version")
  valid_594685 = validateParameter(valid_594685, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594685 != nil:
    section.add "api-version", valid_594685
  var valid_594686 = query.getOrDefault("OperationId")
  valid_594686 = validateParameter(valid_594686, JString, required = true,
                                 default = nil)
  if valid_594686 != nil:
    section.add "OperationId", valid_594686
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594687: Call_GetQuorumLossProgress_594679; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  let valid = call_594687.validator(path, query, header, formData, body)
  let scheme = call_594687.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594687.url(scheme.get, call_594687.host, call_594687.base,
                         call_594687.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594687, url, valid)

proc call*(call_594688: Call_GetQuorumLossProgress_594679; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getQuorumLossProgress
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594689 = newJObject()
  var query_594690 = newJObject()
  add(query_594690, "timeout", newJInt(timeout))
  add(query_594690, "api-version", newJString(apiVersion))
  add(path_594689, "partitionId", newJString(partitionId))
  add(path_594689, "serviceId", newJString(serviceId))
  add(query_594690, "OperationId", newJString(OperationId))
  result = call_594688.call(path_594689, query_594690, nil, nil, nil)

var getQuorumLossProgress* = Call_GetQuorumLossProgress_594679(
    name: "getQuorumLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress",
    validator: validate_GetQuorumLossProgress_594680, base: "",
    url: url_GetQuorumLossProgress_594681, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionRestartProgress_594691 = ref object of OpenApiRestCall_593438
proc url_GetPartitionRestartProgress_594693(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetRestartProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionRestartProgress_594692(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594694 = path.getOrDefault("partitionId")
  valid_594694 = validateParameter(valid_594694, JString, required = true,
                                 default = nil)
  if valid_594694 != nil:
    section.add "partitionId", valid_594694
  var valid_594695 = path.getOrDefault("serviceId")
  valid_594695 = validateParameter(valid_594695, JString, required = true,
                                 default = nil)
  if valid_594695 != nil:
    section.add "serviceId", valid_594695
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594696 = query.getOrDefault("timeout")
  valid_594696 = validateParameter(valid_594696, JInt, required = false,
                                 default = newJInt(60))
  if valid_594696 != nil:
    section.add "timeout", valid_594696
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594697 = query.getOrDefault("api-version")
  valid_594697 = validateParameter(valid_594697, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594697 != nil:
    section.add "api-version", valid_594697
  var valid_594698 = query.getOrDefault("OperationId")
  valid_594698 = validateParameter(valid_594698, JString, required = true,
                                 default = nil)
  if valid_594698 != nil:
    section.add "OperationId", valid_594698
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594699: Call_GetPartitionRestartProgress_594691; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  let valid = call_594699.validator(path, query, header, formData, body)
  let scheme = call_594699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594699.url(scheme.get, call_594699.host, call_594699.base,
                         call_594699.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594699, url, valid)

proc call*(call_594700: Call_GetPartitionRestartProgress_594691;
          partitionId: string; serviceId: string; OperationId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionRestartProgress
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594701 = newJObject()
  var query_594702 = newJObject()
  add(query_594702, "timeout", newJInt(timeout))
  add(query_594702, "api-version", newJString(apiVersion))
  add(path_594701, "partitionId", newJString(partitionId))
  add(path_594701, "serviceId", newJString(serviceId))
  add(query_594702, "OperationId", newJString(OperationId))
  result = call_594700.call(path_594701, query_594702, nil, nil, nil)

var getPartitionRestartProgress* = Call_GetPartitionRestartProgress_594691(
    name: "getPartitionRestartProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress",
    validator: validate_GetPartitionRestartProgress_594692, base: "",
    url: url_GetPartitionRestartProgress_594693,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartDataLoss_594703 = ref object of OpenApiRestCall_593438
proc url_StartDataLoss_594705(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartDataLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartDataLoss_594704(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594706 = path.getOrDefault("partitionId")
  valid_594706 = validateParameter(valid_594706, JString, required = true,
                                 default = nil)
  if valid_594706 != nil:
    section.add "partitionId", valid_594706
  var valid_594707 = path.getOrDefault("serviceId")
  valid_594707 = validateParameter(valid_594707, JString, required = true,
                                 default = nil)
  if valid_594707 != nil:
    section.add "serviceId", valid_594707
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DataLossMode: JString (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594708 = query.getOrDefault("timeout")
  valid_594708 = validateParameter(valid_594708, JInt, required = false,
                                 default = newJInt(60))
  if valid_594708 != nil:
    section.add "timeout", valid_594708
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594709 = query.getOrDefault("api-version")
  valid_594709 = validateParameter(valid_594709, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594709 != nil:
    section.add "api-version", valid_594709
  var valid_594710 = query.getOrDefault("DataLossMode")
  valid_594710 = validateParameter(valid_594710, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_594710 != nil:
    section.add "DataLossMode", valid_594710
  var valid_594711 = query.getOrDefault("OperationId")
  valid_594711 = validateParameter(valid_594711, JString, required = true,
                                 default = nil)
  if valid_594711 != nil:
    section.add "OperationId", valid_594711
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594712: Call_StartDataLoss_594703; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  let valid = call_594712.validator(path, query, header, formData, body)
  let scheme = call_594712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594712.url(scheme.get, call_594712.host, call_594712.base,
                         call_594712.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594712, url, valid)

proc call*(call_594713: Call_StartDataLoss_594703; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; DataLossMode: string = "Invalid"): Recallable =
  ## startDataLoss
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   DataLossMode: string (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594714 = newJObject()
  var query_594715 = newJObject()
  add(query_594715, "timeout", newJInt(timeout))
  add(query_594715, "api-version", newJString(apiVersion))
  add(path_594714, "partitionId", newJString(partitionId))
  add(query_594715, "DataLossMode", newJString(DataLossMode))
  add(path_594714, "serviceId", newJString(serviceId))
  add(query_594715, "OperationId", newJString(OperationId))
  result = call_594713.call(path_594714, query_594715, nil, nil, nil)

var startDataLoss* = Call_StartDataLoss_594703(name: "startDataLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss",
    validator: validate_StartDataLoss_594704, base: "", url: url_StartDataLoss_594705,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartQuorumLoss_594716 = ref object of OpenApiRestCall_593438
proc url_StartQuorumLoss_594718(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartQuorumLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartQuorumLoss_594717(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594719 = path.getOrDefault("partitionId")
  valid_594719 = validateParameter(valid_594719, JString, required = true,
                                 default = nil)
  if valid_594719 != nil:
    section.add "partitionId", valid_594719
  var valid_594720 = path.getOrDefault("serviceId")
  valid_594720 = validateParameter(valid_594720, JString, required = true,
                                 default = nil)
  if valid_594720 != nil:
    section.add "serviceId", valid_594720
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   QuorumLossMode: JString (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   QuorumLossDuration: JInt (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594721 = query.getOrDefault("timeout")
  valid_594721 = validateParameter(valid_594721, JInt, required = false,
                                 default = newJInt(60))
  if valid_594721 != nil:
    section.add "timeout", valid_594721
  assert query != nil,
        "query argument is necessary due to required `QuorumLossMode` field"
  var valid_594722 = query.getOrDefault("QuorumLossMode")
  valid_594722 = validateParameter(valid_594722, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_594722 != nil:
    section.add "QuorumLossMode", valid_594722
  var valid_594723 = query.getOrDefault("api-version")
  valid_594723 = validateParameter(valid_594723, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594723 != nil:
    section.add "api-version", valid_594723
  var valid_594724 = query.getOrDefault("QuorumLossDuration")
  valid_594724 = validateParameter(valid_594724, JInt, required = true, default = nil)
  if valid_594724 != nil:
    section.add "QuorumLossDuration", valid_594724
  var valid_594725 = query.getOrDefault("OperationId")
  valid_594725 = validateParameter(valid_594725, JString, required = true,
                                 default = nil)
  if valid_594725 != nil:
    section.add "OperationId", valid_594725
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594726: Call_StartQuorumLoss_594716; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  let valid = call_594726.validator(path, query, header, formData, body)
  let scheme = call_594726.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594726.url(scheme.get, call_594726.host, call_594726.base,
                         call_594726.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594726, url, valid)

proc call*(call_594727: Call_StartQuorumLoss_594716; partitionId: string;
          QuorumLossDuration: int; serviceId: string; OperationId: string;
          timeout: int = 60; QuorumLossMode: string = "Invalid";
          apiVersion: string = "6.0"): Recallable =
  ## startQuorumLoss
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   QuorumLossMode: string (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   QuorumLossDuration: int (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594728 = newJObject()
  var query_594729 = newJObject()
  add(query_594729, "timeout", newJInt(timeout))
  add(query_594729, "QuorumLossMode", newJString(QuorumLossMode))
  add(query_594729, "api-version", newJString(apiVersion))
  add(path_594728, "partitionId", newJString(partitionId))
  add(query_594729, "QuorumLossDuration", newJInt(QuorumLossDuration))
  add(path_594728, "serviceId", newJString(serviceId))
  add(query_594729, "OperationId", newJString(OperationId))
  result = call_594727.call(path_594728, query_594729, nil, nil, nil)

var startQuorumLoss* = Call_StartQuorumLoss_594716(name: "startQuorumLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss",
    validator: validate_StartQuorumLoss_594717, base: "", url: url_StartQuorumLoss_594718,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartPartitionRestart_594730 = ref object of OpenApiRestCall_593438
proc url_StartPartitionRestart_594732(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartRestart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartPartitionRestart_594731(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_594733 = path.getOrDefault("partitionId")
  valid_594733 = validateParameter(valid_594733, JString, required = true,
                                 default = nil)
  if valid_594733 != nil:
    section.add "partitionId", valid_594733
  var valid_594734 = path.getOrDefault("serviceId")
  valid_594734 = validateParameter(valid_594734, JString, required = true,
                                 default = nil)
  if valid_594734 != nil:
    section.add "serviceId", valid_594734
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: JString (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  section = newJObject()
  var valid_594735 = query.getOrDefault("timeout")
  valid_594735 = validateParameter(valid_594735, JInt, required = false,
                                 default = newJInt(60))
  if valid_594735 != nil:
    section.add "timeout", valid_594735
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594736 = query.getOrDefault("api-version")
  valid_594736 = validateParameter(valid_594736, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594736 != nil:
    section.add "api-version", valid_594736
  var valid_594737 = query.getOrDefault("RestartPartitionMode")
  valid_594737 = validateParameter(valid_594737, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_594737 != nil:
    section.add "RestartPartitionMode", valid_594737
  var valid_594738 = query.getOrDefault("OperationId")
  valid_594738 = validateParameter(valid_594738, JString, required = true,
                                 default = nil)
  if valid_594738 != nil:
    section.add "OperationId", valid_594738
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594739: Call_StartPartitionRestart_594730; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  let valid = call_594739.validator(path, query, header, formData, body)
  let scheme = call_594739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594739.url(scheme.get, call_594739.host, call_594739.base,
                         call_594739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594739, url, valid)

proc call*(call_594740: Call_StartPartitionRestart_594730; partitionId: string;
          serviceId: string; OperationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; RestartPartitionMode: string = "Invalid"): Recallable =
  ## startPartitionRestart
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: string (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  var path_594741 = newJObject()
  var query_594742 = newJObject()
  add(query_594742, "timeout", newJInt(timeout))
  add(query_594742, "api-version", newJString(apiVersion))
  add(query_594742, "RestartPartitionMode", newJString(RestartPartitionMode))
  add(path_594741, "partitionId", newJString(partitionId))
  add(path_594741, "serviceId", newJString(serviceId))
  add(query_594742, "OperationId", newJString(OperationId))
  result = call_594740.call(path_594741, query_594742, nil, nil, nil)

var startPartitionRestart* = Call_StartPartitionRestart_594730(
    name: "startPartitionRestart", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart",
    validator: validate_StartPartitionRestart_594731, base: "",
    url: url_StartPartitionRestart_594732, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreRootContent_594743 = ref object of OpenApiRestCall_593438
proc url_GetImageStoreRootContent_594745(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetImageStoreRootContent_594744(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594746 = query.getOrDefault("timeout")
  valid_594746 = validateParameter(valid_594746, JInt, required = false,
                                 default = newJInt(60))
  if valid_594746 != nil:
    section.add "timeout", valid_594746
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594747 = query.getOrDefault("api-version")
  valid_594747 = validateParameter(valid_594747, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594747 != nil:
    section.add "api-version", valid_594747
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594748: Call_GetImageStoreRootContent_594743; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  let valid = call_594748.validator(path, query, header, formData, body)
  let scheme = call_594748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594748.url(scheme.get, call_594748.host, call_594748.base,
                         call_594748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594748, url, valid)

proc call*(call_594749: Call_GetImageStoreRootContent_594743; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getImageStoreRootContent
  ## Returns the information about the image store content at the root of the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_594750 = newJObject()
  add(query_594750, "timeout", newJInt(timeout))
  add(query_594750, "api-version", newJString(apiVersion))
  result = call_594749.call(nil, query_594750, nil, nil, nil)

var getImageStoreRootContent* = Call_GetImageStoreRootContent_594743(
    name: "getImageStoreRootContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore",
    validator: validate_GetImageStoreRootContent_594744, base: "",
    url: url_GetImageStoreRootContent_594745, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CopyImageStoreContent_594751 = ref object of OpenApiRestCall_593438
proc url_CopyImageStoreContent_594753(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CopyImageStoreContent_594752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594754 = query.getOrDefault("timeout")
  valid_594754 = validateParameter(valid_594754, JInt, required = false,
                                 default = newJInt(60))
  if valid_594754 != nil:
    section.add "timeout", valid_594754
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594755 = query.getOrDefault("api-version")
  valid_594755 = validateParameter(valid_594755, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594755 != nil:
    section.add "api-version", valid_594755
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594757: Call_CopyImageStoreContent_594751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  let valid = call_594757.validator(path, query, header, formData, body)
  let scheme = call_594757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594757.url(scheme.get, call_594757.host, call_594757.base,
                         call_594757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594757, url, valid)

proc call*(call_594758: Call_CopyImageStoreContent_594751;
          ImageStoreCopyDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## copyImageStoreContent
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  var query_594759 = newJObject()
  var body_594760 = newJObject()
  add(query_594759, "timeout", newJInt(timeout))
  add(query_594759, "api-version", newJString(apiVersion))
  if ImageStoreCopyDescription != nil:
    body_594760 = ImageStoreCopyDescription
  result = call_594758.call(nil, query_594759, nil, nil, body_594760)

var copyImageStoreContent* = Call_CopyImageStoreContent_594751(
    name: "copyImageStoreContent", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ImageStore/$/Copy",
    validator: validate_CopyImageStoreContent_594752, base: "",
    url: url_CopyImageStoreContent_594753, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UploadFile_594771 = ref object of OpenApiRestCall_593438
proc url_UploadFile_594773(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UploadFile_594772(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_594774 = path.getOrDefault("contentPath")
  valid_594774 = validateParameter(valid_594774, JString, required = true,
                                 default = nil)
  if valid_594774 != nil:
    section.add "contentPath", valid_594774
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594775 = query.getOrDefault("timeout")
  valid_594775 = validateParameter(valid_594775, JInt, required = false,
                                 default = newJInt(60))
  if valid_594775 != nil:
    section.add "timeout", valid_594775
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594776 = query.getOrDefault("api-version")
  valid_594776 = validateParameter(valid_594776, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594776 != nil:
    section.add "api-version", valid_594776
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594777: Call_UploadFile_594771; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  let valid = call_594777.validator(path, query, header, formData, body)
  let scheme = call_594777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594777.url(scheme.get, call_594777.host, call_594777.base,
                         call_594777.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594777, url, valid)

proc call*(call_594778: Call_UploadFile_594771; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## uploadFile
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_594779 = newJObject()
  var query_594780 = newJObject()
  add(query_594780, "timeout", newJInt(timeout))
  add(query_594780, "api-version", newJString(apiVersion))
  add(path_594779, "contentPath", newJString(contentPath))
  result = call_594778.call(path_594779, query_594780, nil, nil, nil)

var uploadFile* = Call_UploadFile_594771(name: "uploadFile",
                                      meth: HttpMethod.HttpPut,
                                      host: "azure.local:19080",
                                      route: "/ImageStore/{contentPath}",
                                      validator: validate_UploadFile_594772,
                                      base: "", url: url_UploadFile_594773,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreContent_594761 = ref object of OpenApiRestCall_593438
proc url_GetImageStoreContent_594763(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetImageStoreContent_594762(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_594764 = path.getOrDefault("contentPath")
  valid_594764 = validateParameter(valid_594764, JString, required = true,
                                 default = nil)
  if valid_594764 != nil:
    section.add "contentPath", valid_594764
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594765 = query.getOrDefault("timeout")
  valid_594765 = validateParameter(valid_594765, JInt, required = false,
                                 default = newJInt(60))
  if valid_594765 != nil:
    section.add "timeout", valid_594765
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594766 = query.getOrDefault("api-version")
  valid_594766 = validateParameter(valid_594766, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594766 != nil:
    section.add "api-version", valid_594766
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594767: Call_GetImageStoreContent_594761; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  let valid = call_594767.validator(path, query, header, formData, body)
  let scheme = call_594767.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594767.url(scheme.get, call_594767.host, call_594767.base,
                         call_594767.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594767, url, valid)

proc call*(call_594768: Call_GetImageStoreContent_594761; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getImageStoreContent
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_594769 = newJObject()
  var query_594770 = newJObject()
  add(query_594770, "timeout", newJInt(timeout))
  add(query_594770, "api-version", newJString(apiVersion))
  add(path_594769, "contentPath", newJString(contentPath))
  result = call_594768.call(path_594769, query_594770, nil, nil, nil)

var getImageStoreContent* = Call_GetImageStoreContent_594761(
    name: "getImageStoreContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_GetImageStoreContent_594762, base: "",
    url: url_GetImageStoreContent_594763, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteImageStoreContent_594781 = ref object of OpenApiRestCall_593438
proc url_DeleteImageStoreContent_594783(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteImageStoreContent_594782(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_594784 = path.getOrDefault("contentPath")
  valid_594784 = validateParameter(valid_594784, JString, required = true,
                                 default = nil)
  if valid_594784 != nil:
    section.add "contentPath", valid_594784
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594785 = query.getOrDefault("timeout")
  valid_594785 = validateParameter(valid_594785, JInt, required = false,
                                 default = newJInt(60))
  if valid_594785 != nil:
    section.add "timeout", valid_594785
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594786 = query.getOrDefault("api-version")
  valid_594786 = validateParameter(valid_594786, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594786 != nil:
    section.add "api-version", valid_594786
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594787: Call_DeleteImageStoreContent_594781; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  let valid = call_594787.validator(path, query, header, formData, body)
  let scheme = call_594787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594787.url(scheme.get, call_594787.host, call_594787.base,
                         call_594787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594787, url, valid)

proc call*(call_594788: Call_DeleteImageStoreContent_594781; contentPath: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## deleteImageStoreContent
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  var path_594789 = newJObject()
  var query_594790 = newJObject()
  add(query_594790, "timeout", newJInt(timeout))
  add(query_594790, "api-version", newJString(apiVersion))
  add(path_594789, "contentPath", newJString(contentPath))
  result = call_594788.call(path_594789, query_594790, nil, nil, nil)

var deleteImageStoreContent* = Call_DeleteImageStoreContent_594781(
    name: "deleteImageStoreContent", meth: HttpMethod.HttpDelete,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_DeleteImageStoreContent_594782, base: "",
    url: url_DeleteImageStoreContent_594783, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateName_594791 = ref object of OpenApiRestCall_593438
proc url_CreateName_594793(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateName_594792(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified Service Fabric name.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594794 = query.getOrDefault("timeout")
  valid_594794 = validateParameter(valid_594794, JInt, required = false,
                                 default = newJInt(60))
  if valid_594794 != nil:
    section.add "timeout", valid_594794
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594795 = query.getOrDefault("api-version")
  valid_594795 = validateParameter(valid_594795, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594795 != nil:
    section.add "api-version", valid_594795
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594797: Call_CreateName_594791; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified Service Fabric name.
  ## 
  let valid = call_594797.validator(path, query, header, formData, body)
  let scheme = call_594797.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594797.url(scheme.get, call_594797.host, call_594797.base,
                         call_594797.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594797, url, valid)

proc call*(call_594798: Call_CreateName_594791; NameDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## createName
  ## Creates the specified Service Fabric name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  var query_594799 = newJObject()
  var body_594800 = newJObject()
  add(query_594799, "timeout", newJInt(timeout))
  add(query_594799, "api-version", newJString(apiVersion))
  if NameDescription != nil:
    body_594800 = NameDescription
  result = call_594798.call(nil, query_594799, nil, nil, body_594800)

var createName* = Call_CreateName_594791(name: "createName",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Names/$/Create",
                                      validator: validate_CreateName_594792,
                                      base: "", url: url_CreateName_594793,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNameExistsInfo_594801 = ref object of OpenApiRestCall_593438
proc url_GetNameExistsInfo_594803(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNameExistsInfo_594802(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594804 = path.getOrDefault("nameId")
  valid_594804 = validateParameter(valid_594804, JString, required = true,
                                 default = nil)
  if valid_594804 != nil:
    section.add "nameId", valid_594804
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594805 = query.getOrDefault("timeout")
  valid_594805 = validateParameter(valid_594805, JInt, required = false,
                                 default = newJInt(60))
  if valid_594805 != nil:
    section.add "timeout", valid_594805
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594806 = query.getOrDefault("api-version")
  valid_594806 = validateParameter(valid_594806, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594806 != nil:
    section.add "api-version", valid_594806
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594807: Call_GetNameExistsInfo_594801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  let valid = call_594807.validator(path, query, header, formData, body)
  let scheme = call_594807.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594807.url(scheme.get, call_594807.host, call_594807.base,
                         call_594807.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594807, url, valid)

proc call*(call_594808: Call_GetNameExistsInfo_594801; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNameExistsInfo
  ## Returns whether the specified Service Fabric name exists.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_594809 = newJObject()
  var query_594810 = newJObject()
  add(query_594810, "timeout", newJInt(timeout))
  add(query_594810, "api-version", newJString(apiVersion))
  add(path_594809, "nameId", newJString(nameId))
  result = call_594808.call(path_594809, query_594810, nil, nil, nil)

var getNameExistsInfo* = Call_GetNameExistsInfo_594801(name: "getNameExistsInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Names/{nameId}",
    validator: validate_GetNameExistsInfo_594802, base: "",
    url: url_GetNameExistsInfo_594803, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteName_594811 = ref object of OpenApiRestCall_593438
proc url_DeleteName_594813(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteName_594812(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594814 = path.getOrDefault("nameId")
  valid_594814 = validateParameter(valid_594814, JString, required = true,
                                 default = nil)
  if valid_594814 != nil:
    section.add "nameId", valid_594814
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594815 = query.getOrDefault("timeout")
  valid_594815 = validateParameter(valid_594815, JInt, required = false,
                                 default = newJInt(60))
  if valid_594815 != nil:
    section.add "timeout", valid_594815
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594816 = query.getOrDefault("api-version")
  valid_594816 = validateParameter(valid_594816, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594816 != nil:
    section.add "api-version", valid_594816
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594817: Call_DeleteName_594811; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  let valid = call_594817.validator(path, query, header, formData, body)
  let scheme = call_594817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594817.url(scheme.get, call_594817.host, call_594817.base,
                         call_594817.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594817, url, valid)

proc call*(call_594818: Call_DeleteName_594811; nameId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## deleteName
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_594819 = newJObject()
  var query_594820 = newJObject()
  add(query_594820, "timeout", newJInt(timeout))
  add(query_594820, "api-version", newJString(apiVersion))
  add(path_594819, "nameId", newJString(nameId))
  result = call_594818.call(path_594819, query_594820, nil, nil, nil)

var deleteName* = Call_DeleteName_594811(name: "deleteName",
                                      meth: HttpMethod.HttpDelete,
                                      host: "azure.local:19080",
                                      route: "/Names/{nameId}",
                                      validator: validate_DeleteName_594812,
                                      base: "", url: url_DeleteName_594813,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfoList_594821 = ref object of OpenApiRestCall_593438
proc url_GetPropertyInfoList_594823(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfoList_594822(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594824 = path.getOrDefault("nameId")
  valid_594824 = validateParameter(valid_594824, JString, required = true,
                                 default = nil)
  if valid_594824 != nil:
    section.add "nameId", valid_594824
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   IncludeValues: JBool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  section = newJObject()
  var valid_594825 = query.getOrDefault("timeout")
  valid_594825 = validateParameter(valid_594825, JInt, required = false,
                                 default = newJInt(60))
  if valid_594825 != nil:
    section.add "timeout", valid_594825
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594826 = query.getOrDefault("api-version")
  valid_594826 = validateParameter(valid_594826, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594826 != nil:
    section.add "api-version", valid_594826
  var valid_594827 = query.getOrDefault("ContinuationToken")
  valid_594827 = validateParameter(valid_594827, JString, required = false,
                                 default = nil)
  if valid_594827 != nil:
    section.add "ContinuationToken", valid_594827
  var valid_594828 = query.getOrDefault("IncludeValues")
  valid_594828 = validateParameter(valid_594828, JBool, required = false,
                                 default = newJBool(false))
  if valid_594828 != nil:
    section.add "IncludeValues", valid_594828
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594829: Call_GetPropertyInfoList_594821; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  let valid = call_594829.validator(path, query, header, formData, body)
  let scheme = call_594829.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594829.url(scheme.get, call_594829.host, call_594829.base,
                         call_594829.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594829, url, valid)

proc call*(call_594830: Call_GetPropertyInfoList_594821; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = "";
          IncludeValues: bool = false): Recallable =
  ## getPropertyInfoList
  ## Gets information on all Service Fabric properties under a given name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   IncludeValues: bool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  var path_594831 = newJObject()
  var query_594832 = newJObject()
  add(query_594832, "timeout", newJInt(timeout))
  add(query_594832, "api-version", newJString(apiVersion))
  add(path_594831, "nameId", newJString(nameId))
  add(query_594832, "ContinuationToken", newJString(ContinuationToken))
  add(query_594832, "IncludeValues", newJBool(IncludeValues))
  result = call_594830.call(path_594831, query_594832, nil, nil, nil)

var getPropertyInfoList* = Call_GetPropertyInfoList_594821(
    name: "getPropertyInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Names/{nameId}/$/GetProperties",
    validator: validate_GetPropertyInfoList_594822, base: "",
    url: url_GetPropertyInfoList_594823, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SubmitPropertyBatch_594833 = ref object of OpenApiRestCall_593438
proc url_SubmitPropertyBatch_594835(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties/$/SubmitBatch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_SubmitPropertyBatch_594834(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594836 = path.getOrDefault("nameId")
  valid_594836 = validateParameter(valid_594836, JString, required = true,
                                 default = nil)
  if valid_594836 != nil:
    section.add "nameId", valid_594836
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594837 = query.getOrDefault("timeout")
  valid_594837 = validateParameter(valid_594837, JInt, required = false,
                                 default = newJInt(60))
  if valid_594837 != nil:
    section.add "timeout", valid_594837
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594838 = query.getOrDefault("api-version")
  valid_594838 = validateParameter(valid_594838, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594838 != nil:
    section.add "api-version", valid_594838
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594840: Call_SubmitPropertyBatch_594833; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  let valid = call_594840.validator(path, query, header, formData, body)
  let scheme = call_594840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594840.url(scheme.get, call_594840.host, call_594840.base,
                         call_594840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594840, url, valid)

proc call*(call_594841: Call_SubmitPropertyBatch_594833; nameId: string;
          PropertyBatchDescriptionList: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## submitPropertyBatch
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  var path_594842 = newJObject()
  var query_594843 = newJObject()
  var body_594844 = newJObject()
  add(query_594843, "timeout", newJInt(timeout))
  add(query_594843, "api-version", newJString(apiVersion))
  add(path_594842, "nameId", newJString(nameId))
  if PropertyBatchDescriptionList != nil:
    body_594844 = PropertyBatchDescriptionList
  result = call_594841.call(path_594842, query_594843, nil, nil, body_594844)

var submitPropertyBatch* = Call_SubmitPropertyBatch_594833(
    name: "submitPropertyBatch", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperties/$/SubmitBatch",
    validator: validate_SubmitPropertyBatch_594834, base: "",
    url: url_SubmitPropertyBatch_594835, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PutProperty_594856 = ref object of OpenApiRestCall_593438
proc url_PutProperty_594858(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_PutProperty_594857(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594859 = path.getOrDefault("nameId")
  valid_594859 = validateParameter(valid_594859, JString, required = true,
                                 default = nil)
  if valid_594859 != nil:
    section.add "nameId", valid_594859
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594860 = query.getOrDefault("timeout")
  valid_594860 = validateParameter(valid_594860, JInt, required = false,
                                 default = newJInt(60))
  if valid_594860 != nil:
    section.add "timeout", valid_594860
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594861 = query.getOrDefault("api-version")
  valid_594861 = validateParameter(valid_594861, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594861 != nil:
    section.add "api-version", valid_594861
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594863: Call_PutProperty_594856; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  let valid = call_594863.validator(path, query, header, formData, body)
  let scheme = call_594863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594863.url(scheme.get, call_594863.host, call_594863.base,
                         call_594863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594863, url, valid)

proc call*(call_594864: Call_PutProperty_594856; nameId: string;
          PropertyDescription: JsonNode; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## putProperty
  ## Creates or updates the specified Service Fabric property under a given name.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  var path_594865 = newJObject()
  var query_594866 = newJObject()
  var body_594867 = newJObject()
  add(query_594866, "timeout", newJInt(timeout))
  add(query_594866, "api-version", newJString(apiVersion))
  add(path_594865, "nameId", newJString(nameId))
  if PropertyDescription != nil:
    body_594867 = PropertyDescription
  result = call_594864.call(path_594865, query_594866, nil, nil, body_594867)

var putProperty* = Call_PutProperty_594856(name: "putProperty",
                                        meth: HttpMethod.HttpPut,
                                        host: "azure.local:19080",
                                        route: "/Names/{nameId}/$/GetProperty",
                                        validator: validate_PutProperty_594857,
                                        base: "", url: url_PutProperty_594858,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfo_594845 = ref object of OpenApiRestCall_593438
proc url_GetPropertyInfo_594847(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfo_594846(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594848 = path.getOrDefault("nameId")
  valid_594848 = validateParameter(valid_594848, JString, required = true,
                                 default = nil)
  if valid_594848 != nil:
    section.add "nameId", valid_594848
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  var valid_594849 = query.getOrDefault("timeout")
  valid_594849 = validateParameter(valid_594849, JInt, required = false,
                                 default = newJInt(60))
  if valid_594849 != nil:
    section.add "timeout", valid_594849
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594850 = query.getOrDefault("api-version")
  valid_594850 = validateParameter(valid_594850, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594850 != nil:
    section.add "api-version", valid_594850
  var valid_594851 = query.getOrDefault("PropertyName")
  valid_594851 = validateParameter(valid_594851, JString, required = true,
                                 default = nil)
  if valid_594851 != nil:
    section.add "PropertyName", valid_594851
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594852: Call_GetPropertyInfo_594845; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  let valid = call_594852.validator(path, query, header, formData, body)
  let scheme = call_594852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594852.url(scheme.get, call_594852.host, call_594852.base,
                         call_594852.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594852, url, valid)

proc call*(call_594853: Call_GetPropertyInfo_594845; nameId: string;
          PropertyName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPropertyInfo
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  var path_594854 = newJObject()
  var query_594855 = newJObject()
  add(query_594855, "timeout", newJInt(timeout))
  add(query_594855, "api-version", newJString(apiVersion))
  add(path_594854, "nameId", newJString(nameId))
  add(query_594855, "PropertyName", newJString(PropertyName))
  result = call_594853.call(path_594854, query_594855, nil, nil, nil)

var getPropertyInfo* = Call_GetPropertyInfo_594845(name: "getPropertyInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_GetPropertyInfo_594846,
    base: "", url: url_GetPropertyInfo_594847, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProperty_594868 = ref object of OpenApiRestCall_593438
proc url_DeleteProperty_594870(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteProperty_594869(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594871 = path.getOrDefault("nameId")
  valid_594871 = validateParameter(valid_594871, JString, required = true,
                                 default = nil)
  if valid_594871 != nil:
    section.add "nameId", valid_594871
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  var valid_594872 = query.getOrDefault("timeout")
  valid_594872 = validateParameter(valid_594872, JInt, required = false,
                                 default = newJInt(60))
  if valid_594872 != nil:
    section.add "timeout", valid_594872
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594873 = query.getOrDefault("api-version")
  valid_594873 = validateParameter(valid_594873, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594873 != nil:
    section.add "api-version", valid_594873
  var valid_594874 = query.getOrDefault("PropertyName")
  valid_594874 = validateParameter(valid_594874, JString, required = true,
                                 default = nil)
  if valid_594874 != nil:
    section.add "PropertyName", valid_594874
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594875: Call_DeleteProperty_594868; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  let valid = call_594875.validator(path, query, header, formData, body)
  let scheme = call_594875.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594875.url(scheme.get, call_594875.host, call_594875.base,
                         call_594875.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594875, url, valid)

proc call*(call_594876: Call_DeleteProperty_594868; nameId: string;
          PropertyName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## deleteProperty
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  var path_594877 = newJObject()
  var query_594878 = newJObject()
  add(query_594878, "timeout", newJInt(timeout))
  add(query_594878, "api-version", newJString(apiVersion))
  add(path_594877, "nameId", newJString(nameId))
  add(query_594878, "PropertyName", newJString(PropertyName))
  result = call_594876.call(path_594877, query_594878, nil, nil, nil)

var deleteProperty* = Call_DeleteProperty_594868(name: "deleteProperty",
    meth: HttpMethod.HttpDelete, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_DeleteProperty_594869,
    base: "", url: url_DeleteProperty_594870, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetSubNameInfoList_594879 = ref object of OpenApiRestCall_593438
proc url_GetSubNameInfoList_594881(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetSubNames")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetSubNameInfoList_594880(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_594882 = path.getOrDefault("nameId")
  valid_594882 = validateParameter(valid_594882, JString, required = true,
                                 default = nil)
  if valid_594882 != nil:
    section.add "nameId", valid_594882
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Recursive: JBool
  ##            : Allows specifying that the search performed should be recursive.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_594883 = query.getOrDefault("timeout")
  valid_594883 = validateParameter(valid_594883, JInt, required = false,
                                 default = newJInt(60))
  if valid_594883 != nil:
    section.add "timeout", valid_594883
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594884 = query.getOrDefault("api-version")
  valid_594884 = validateParameter(valid_594884, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594884 != nil:
    section.add "api-version", valid_594884
  var valid_594885 = query.getOrDefault("Recursive")
  valid_594885 = validateParameter(valid_594885, JBool, required = false,
                                 default = newJBool(false))
  if valid_594885 != nil:
    section.add "Recursive", valid_594885
  var valid_594886 = query.getOrDefault("ContinuationToken")
  valid_594886 = validateParameter(valid_594886, JString, required = false,
                                 default = nil)
  if valid_594886 != nil:
    section.add "ContinuationToken", valid_594886
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594887: Call_GetSubNameInfoList_594879; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  let valid = call_594887.validator(path, query, header, formData, body)
  let scheme = call_594887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594887.url(scheme.get, call_594887.host, call_594887.base,
                         call_594887.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594887, url, valid)

proc call*(call_594888: Call_GetSubNameInfoList_594879; nameId: string;
          timeout: int = 60; apiVersion: string = "6.0"; Recursive: bool = false;
          ContinuationToken: string = ""): Recallable =
  ## getSubNameInfoList
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Recursive: bool
  ##            : Allows specifying that the search performed should be recursive.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_594889 = newJObject()
  var query_594890 = newJObject()
  add(query_594890, "timeout", newJInt(timeout))
  add(query_594890, "api-version", newJString(apiVersion))
  add(query_594890, "Recursive", newJBool(Recursive))
  add(path_594889, "nameId", newJString(nameId))
  add(query_594890, "ContinuationToken", newJString(ContinuationToken))
  result = call_594888.call(path_594889, query_594890, nil, nil, nil)

var getSubNameInfoList* = Call_GetSubNameInfoList_594879(
    name: "getSubNameInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetSubNames",
    validator: validate_GetSubNameInfoList_594880, base: "",
    url: url_GetSubNameInfoList_594881, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfoList_594891 = ref object of OpenApiRestCall_593438
proc url_GetNodeInfoList_594893(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetNodeInfoList_594892(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: JString
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_594894 = query.getOrDefault("timeout")
  valid_594894 = validateParameter(valid_594894, JInt, required = false,
                                 default = newJInt(60))
  if valid_594894 != nil:
    section.add "timeout", valid_594894
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594895 = query.getOrDefault("api-version")
  valid_594895 = validateParameter(valid_594895, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594895 != nil:
    section.add "api-version", valid_594895
  var valid_594896 = query.getOrDefault("NodeStatusFilter")
  valid_594896 = validateParameter(valid_594896, JString, required = false,
                                 default = newJString("default"))
  if valid_594896 != nil:
    section.add "NodeStatusFilter", valid_594896
  var valid_594897 = query.getOrDefault("ContinuationToken")
  valid_594897 = validateParameter(valid_594897, JString, required = false,
                                 default = nil)
  if valid_594897 != nil:
    section.add "ContinuationToken", valid_594897
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594898: Call_GetNodeInfoList_594891; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_594898.validator(path, query, header, formData, body)
  let scheme = call_594898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594898.url(scheme.get, call_594898.host, call_594898.base,
                         call_594898.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594898, url, valid)

proc call*(call_594899: Call_GetNodeInfoList_594891; timeout: int = 60;
          apiVersion: string = "6.0"; NodeStatusFilter: string = "default";
          ContinuationToken: string = ""): Recallable =
  ## getNodeInfoList
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: string
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var query_594900 = newJObject()
  add(query_594900, "timeout", newJInt(timeout))
  add(query_594900, "api-version", newJString(apiVersion))
  add(query_594900, "NodeStatusFilter", newJString(NodeStatusFilter))
  add(query_594900, "ContinuationToken", newJString(ContinuationToken))
  result = call_594899.call(nil, query_594900, nil, nil, nil)

var getNodeInfoList* = Call_GetNodeInfoList_594891(name: "getNodeInfoList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Nodes",
    validator: validate_GetNodeInfoList_594892, base: "", url: url_GetNodeInfoList_594893,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfo_594901 = ref object of OpenApiRestCall_593438
proc url_GetNodeInfo_594903(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeInfo_594902(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594904 = path.getOrDefault("nodeName")
  valid_594904 = validateParameter(valid_594904, JString, required = true,
                                 default = nil)
  if valid_594904 != nil:
    section.add "nodeName", valid_594904
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594905 = query.getOrDefault("timeout")
  valid_594905 = validateParameter(valid_594905, JInt, required = false,
                                 default = newJInt(60))
  if valid_594905 != nil:
    section.add "timeout", valid_594905
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594906 = query.getOrDefault("api-version")
  valid_594906 = validateParameter(valid_594906, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594906 != nil:
    section.add "api-version", valid_594906
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594907: Call_GetNodeInfo_594901; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_594907.validator(path, query, header, formData, body)
  let scheme = call_594907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594907.url(scheme.get, call_594907.host, call_594907.base,
                         call_594907.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594907, url, valid)

proc call*(call_594908: Call_GetNodeInfo_594901; nodeName: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getNodeInfo
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_594909 = newJObject()
  var query_594910 = newJObject()
  add(query_594910, "timeout", newJInt(timeout))
  add(query_594910, "api-version", newJString(apiVersion))
  add(path_594909, "nodeName", newJString(nodeName))
  result = call_594908.call(path_594909, query_594910, nil, nil, nil)

var getNodeInfo* = Call_GetNodeInfo_594901(name: "getNodeInfo",
                                        meth: HttpMethod.HttpGet,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}",
                                        validator: validate_GetNodeInfo_594902,
                                        base: "", url: url_GetNodeInfo_594903,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableNode_594911 = ref object of OpenApiRestCall_593438
proc url_EnableNode_594913(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Activate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_EnableNode_594912(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594914 = path.getOrDefault("nodeName")
  valid_594914 = validateParameter(valid_594914, JString, required = true,
                                 default = nil)
  if valid_594914 != nil:
    section.add "nodeName", valid_594914
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594915 = query.getOrDefault("timeout")
  valid_594915 = validateParameter(valid_594915, JInt, required = false,
                                 default = newJInt(60))
  if valid_594915 != nil:
    section.add "timeout", valid_594915
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594916 = query.getOrDefault("api-version")
  valid_594916 = validateParameter(valid_594916, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594916 != nil:
    section.add "api-version", valid_594916
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594917: Call_EnableNode_594911; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  let valid = call_594917.validator(path, query, header, formData, body)
  let scheme = call_594917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594917.url(scheme.get, call_594917.host, call_594917.base,
                         call_594917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594917, url, valid)

proc call*(call_594918: Call_EnableNode_594911; nodeName: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## enableNode
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_594919 = newJObject()
  var query_594920 = newJObject()
  add(query_594920, "timeout", newJInt(timeout))
  add(query_594920, "api-version", newJString(apiVersion))
  add(path_594919, "nodeName", newJString(nodeName))
  result = call_594918.call(path_594919, query_594920, nil, nil, nil)

var enableNode* = Call_EnableNode_594911(name: "enableNode",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Nodes/{nodeName}/$/Activate",
                                      validator: validate_EnableNode_594912,
                                      base: "", url: url_EnableNode_594913,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableNode_594921 = ref object of OpenApiRestCall_593438
proc url_DisableNode_594923(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Deactivate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DisableNode_594922(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594924 = path.getOrDefault("nodeName")
  valid_594924 = validateParameter(valid_594924, JString, required = true,
                                 default = nil)
  if valid_594924 != nil:
    section.add "nodeName", valid_594924
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594925 = query.getOrDefault("timeout")
  valid_594925 = validateParameter(valid_594925, JInt, required = false,
                                 default = newJInt(60))
  if valid_594925 != nil:
    section.add "timeout", valid_594925
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594926 = query.getOrDefault("api-version")
  valid_594926 = validateParameter(valid_594926, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594926 != nil:
    section.add "api-version", valid_594926
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594928: Call_DisableNode_594921; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  let valid = call_594928.validator(path, query, header, formData, body)
  let scheme = call_594928.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594928.url(scheme.get, call_594928.host, call_594928.base,
                         call_594928.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594928, url, valid)

proc call*(call_594929: Call_DisableNode_594921; nodeName: string;
          DeactivationIntentDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## disableNode
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  var path_594930 = newJObject()
  var query_594931 = newJObject()
  var body_594932 = newJObject()
  add(query_594931, "timeout", newJInt(timeout))
  add(query_594931, "api-version", newJString(apiVersion))
  add(path_594930, "nodeName", newJString(nodeName))
  if DeactivationIntentDescription != nil:
    body_594932 = DeactivationIntentDescription
  result = call_594929.call(path_594930, query_594931, nil, nil, body_594932)

var disableNode* = Call_DisableNode_594921(name: "disableNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080", route: "/Nodes/{nodeName}/$/Deactivate",
                                        validator: validate_DisableNode_594922,
                                        base: "", url: url_DisableNode_594923,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeployedServicePackageToNode_594933 = ref object of OpenApiRestCall_593438
proc url_DeployedServicePackageToNode_594935(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/DeployServicePackage")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeployedServicePackageToNode_594934(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594936 = path.getOrDefault("nodeName")
  valid_594936 = validateParameter(valid_594936, JString, required = true,
                                 default = nil)
  if valid_594936 != nil:
    section.add "nodeName", valid_594936
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594937 = query.getOrDefault("timeout")
  valid_594937 = validateParameter(valid_594937, JInt, required = false,
                                 default = newJInt(60))
  if valid_594937 != nil:
    section.add "timeout", valid_594937
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594938 = query.getOrDefault("api-version")
  valid_594938 = validateParameter(valid_594938, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594938 != nil:
    section.add "api-version", valid_594938
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594940: Call_DeployedServicePackageToNode_594933; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  let valid = call_594940.validator(path, query, header, formData, body)
  let scheme = call_594940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594940.url(scheme.get, call_594940.host, call_594940.base,
                         call_594940.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594940, url, valid)

proc call*(call_594941: Call_DeployedServicePackageToNode_594933; nodeName: string;
          DeployServicePackageToNodeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## deployedServicePackageToNode
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  var path_594942 = newJObject()
  var query_594943 = newJObject()
  var body_594944 = newJObject()
  add(query_594943, "timeout", newJInt(timeout))
  add(query_594943, "api-version", newJString(apiVersion))
  add(path_594942, "nodeName", newJString(nodeName))
  if DeployServicePackageToNodeDescription != nil:
    body_594944 = DeployServicePackageToNodeDescription
  result = call_594941.call(path_594942, query_594943, nil, nil, body_594944)

var deployedServicePackageToNode* = Call_DeployedServicePackageToNode_594933(
    name: "deployedServicePackageToNode", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/DeployServicePackage",
    validator: validate_DeployedServicePackageToNode_594934, base: "",
    url: url_DeployedServicePackageToNode_594935,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfoList_594945 = ref object of OpenApiRestCall_593438
proc url_GetDeployedApplicationInfoList_594947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfoList_594946(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594948 = path.getOrDefault("nodeName")
  valid_594948 = validateParameter(valid_594948, JString, required = true,
                                 default = nil)
  if valid_594948 != nil:
    section.add "nodeName", valid_594948
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594949 = query.getOrDefault("timeout")
  valid_594949 = validateParameter(valid_594949, JInt, required = false,
                                 default = newJInt(60))
  if valid_594949 != nil:
    section.add "timeout", valid_594949
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594950 = query.getOrDefault("api-version")
  valid_594950 = validateParameter(valid_594950, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594950 != nil:
    section.add "api-version", valid_594950
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594951: Call_GetDeployedApplicationInfoList_594945; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  let valid = call_594951.validator(path, query, header, formData, body)
  let scheme = call_594951.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594951.url(scheme.get, call_594951.host, call_594951.base,
                         call_594951.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594951, url, valid)

proc call*(call_594952: Call_GetDeployedApplicationInfoList_594945;
          nodeName: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedApplicationInfoList
  ## Gets the list of applications deployed on a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_594953 = newJObject()
  var query_594954 = newJObject()
  add(query_594954, "timeout", newJInt(timeout))
  add(query_594954, "api-version", newJString(apiVersion))
  add(path_594953, "nodeName", newJString(nodeName))
  result = call_594952.call(path_594953, query_594954, nil, nil, nil)

var getDeployedApplicationInfoList* = Call_GetDeployedApplicationInfoList_594945(
    name: "getDeployedApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications",
    validator: validate_GetDeployedApplicationInfoList_594946, base: "",
    url: url_GetDeployedApplicationInfoList_594947,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfo_594955 = ref object of OpenApiRestCall_593438
proc url_GetDeployedApplicationInfo_594957(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfo_594956(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594958 = path.getOrDefault("nodeName")
  valid_594958 = validateParameter(valid_594958, JString, required = true,
                                 default = nil)
  if valid_594958 != nil:
    section.add "nodeName", valid_594958
  var valid_594959 = path.getOrDefault("applicationId")
  valid_594959 = validateParameter(valid_594959, JString, required = true,
                                 default = nil)
  if valid_594959 != nil:
    section.add "applicationId", valid_594959
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594960 = query.getOrDefault("timeout")
  valid_594960 = validateParameter(valid_594960, JInt, required = false,
                                 default = newJInt(60))
  if valid_594960 != nil:
    section.add "timeout", valid_594960
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594961 = query.getOrDefault("api-version")
  valid_594961 = validateParameter(valid_594961, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594961 != nil:
    section.add "api-version", valid_594961
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594962: Call_GetDeployedApplicationInfo_594955; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  let valid = call_594962.validator(path, query, header, formData, body)
  let scheme = call_594962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594962.url(scheme.get, call_594962.host, call_594962.base,
                         call_594962.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594962, url, valid)

proc call*(call_594963: Call_GetDeployedApplicationInfo_594955; nodeName: string;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedApplicationInfo
  ## Gets the information about an application deployed on a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_594964 = newJObject()
  var query_594965 = newJObject()
  add(query_594965, "timeout", newJInt(timeout))
  add(query_594965, "api-version", newJString(apiVersion))
  add(path_594964, "nodeName", newJString(nodeName))
  add(path_594964, "applicationId", newJString(applicationId))
  result = call_594963.call(path_594964, query_594965, nil, nil, nil)

var getDeployedApplicationInfo* = Call_GetDeployedApplicationInfo_594955(
    name: "getDeployedApplicationInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}",
    validator: validate_GetDeployedApplicationInfo_594956, base: "",
    url: url_GetDeployedApplicationInfo_594957,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedCodePackageInfoList_594966 = ref object of OpenApiRestCall_593438
proc url_GetDeployedCodePackageInfoList_594968(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedCodePackageInfoList_594967(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594969 = path.getOrDefault("nodeName")
  valid_594969 = validateParameter(valid_594969, JString, required = true,
                                 default = nil)
  if valid_594969 != nil:
    section.add "nodeName", valid_594969
  var valid_594970 = path.getOrDefault("applicationId")
  valid_594970 = validateParameter(valid_594970, JString, required = true,
                                 default = nil)
  if valid_594970 != nil:
    section.add "applicationId", valid_594970
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   CodePackageName: JString
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  var valid_594971 = query.getOrDefault("timeout")
  valid_594971 = validateParameter(valid_594971, JInt, required = false,
                                 default = newJInt(60))
  if valid_594971 != nil:
    section.add "timeout", valid_594971
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594972 = query.getOrDefault("api-version")
  valid_594972 = validateParameter(valid_594972, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594972 != nil:
    section.add "api-version", valid_594972
  var valid_594973 = query.getOrDefault("ServiceManifestName")
  valid_594973 = validateParameter(valid_594973, JString, required = false,
                                 default = nil)
  if valid_594973 != nil:
    section.add "ServiceManifestName", valid_594973
  var valid_594974 = query.getOrDefault("CodePackageName")
  valid_594974 = validateParameter(valid_594974, JString, required = false,
                                 default = nil)
  if valid_594974 != nil:
    section.add "CodePackageName", valid_594974
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594975: Call_GetDeployedCodePackageInfoList_594966; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_594975.validator(path, query, header, formData, body)
  let scheme = call_594975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594975.url(scheme.get, call_594975.host, call_594975.base,
                         call_594975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594975, url, valid)

proc call*(call_594976: Call_GetDeployedCodePackageInfoList_594966;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = "";
          CodePackageName: string = ""): Recallable =
  ## getDeployedCodePackageInfoList
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   CodePackageName: string
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  var path_594977 = newJObject()
  var query_594978 = newJObject()
  add(query_594978, "timeout", newJInt(timeout))
  add(query_594978, "api-version", newJString(apiVersion))
  add(path_594977, "nodeName", newJString(nodeName))
  add(query_594978, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_594977, "applicationId", newJString(applicationId))
  add(query_594978, "CodePackageName", newJString(CodePackageName))
  result = call_594976.call(path_594977, query_594978, nil, nil, nil)

var getDeployedCodePackageInfoList* = Call_GetDeployedCodePackageInfoList_594966(
    name: "getDeployedCodePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages",
    validator: validate_GetDeployedCodePackageInfoList_594967, base: "",
    url: url_GetDeployedCodePackageInfoList_594968,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartDeployedCodePackage_594979 = ref object of OpenApiRestCall_593438
proc url_RestartDeployedCodePackage_594981(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartDeployedCodePackage_594980(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594982 = path.getOrDefault("nodeName")
  valid_594982 = validateParameter(valid_594982, JString, required = true,
                                 default = nil)
  if valid_594982 != nil:
    section.add "nodeName", valid_594982
  var valid_594983 = path.getOrDefault("applicationId")
  valid_594983 = validateParameter(valid_594983, JString, required = true,
                                 default = nil)
  if valid_594983 != nil:
    section.add "applicationId", valid_594983
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_594984 = query.getOrDefault("timeout")
  valid_594984 = validateParameter(valid_594984, JInt, required = false,
                                 default = newJInt(60))
  if valid_594984 != nil:
    section.add "timeout", valid_594984
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594985 = query.getOrDefault("api-version")
  valid_594985 = validateParameter(valid_594985, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594985 != nil:
    section.add "api-version", valid_594985
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_594987: Call_RestartDeployedCodePackage_594979; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  let valid = call_594987.validator(path, query, header, formData, body)
  let scheme = call_594987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594987.url(scheme.get, call_594987.host, call_594987.base,
                         call_594987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594987, url, valid)

proc call*(call_594988: Call_RestartDeployedCodePackage_594979; nodeName: string;
          applicationId: string; RestartDeployedCodePackageDescription: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## restartDeployedCodePackage
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  var path_594989 = newJObject()
  var query_594990 = newJObject()
  var body_594991 = newJObject()
  add(query_594990, "timeout", newJInt(timeout))
  add(query_594990, "api-version", newJString(apiVersion))
  add(path_594989, "nodeName", newJString(nodeName))
  add(path_594989, "applicationId", newJString(applicationId))
  if RestartDeployedCodePackageDescription != nil:
    body_594991 = RestartDeployedCodePackageDescription
  result = call_594988.call(path_594989, query_594990, nil, nil, body_594991)

var restartDeployedCodePackage* = Call_RestartDeployedCodePackage_594979(
    name: "restartDeployedCodePackage", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart",
    validator: validate_RestartDeployedCodePackage_594980, base: "",
    url: url_RestartDeployedCodePackage_594981,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealthUsingPolicy_595006 = ref object of OpenApiRestCall_593438
proc url_GetDeployedApplicationHealthUsingPolicy_595008(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealthUsingPolicy_595007(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595009 = path.getOrDefault("nodeName")
  valid_595009 = validateParameter(valid_595009, JString, required = true,
                                 default = nil)
  if valid_595009 != nil:
    section.add "nodeName", valid_595009
  var valid_595010 = path.getOrDefault("applicationId")
  valid_595010 = validateParameter(valid_595010, JString, required = true,
                                 default = nil)
  if valid_595010 != nil:
    section.add "applicationId", valid_595010
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595011 = query.getOrDefault("timeout")
  valid_595011 = validateParameter(valid_595011, JInt, required = false,
                                 default = newJInt(60))
  if valid_595011 != nil:
    section.add "timeout", valid_595011
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595012 = query.getOrDefault("api-version")
  valid_595012 = validateParameter(valid_595012, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595012 != nil:
    section.add "api-version", valid_595012
  var valid_595013 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_595013 = validateParameter(valid_595013, JInt, required = false,
                                 default = newJInt(0))
  if valid_595013 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_595013
  var valid_595014 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595014 = validateParameter(valid_595014, JBool, required = false,
                                 default = newJBool(false))
  if valid_595014 != nil:
    section.add "ExcludeHealthStatistics", valid_595014
  var valid_595015 = query.getOrDefault("EventsHealthStateFilter")
  valid_595015 = validateParameter(valid_595015, JInt, required = false,
                                 default = newJInt(0))
  if valid_595015 != nil:
    section.add "EventsHealthStateFilter", valid_595015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595017: Call_GetDeployedApplicationHealthUsingPolicy_595006;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  let valid = call_595017.validator(path, query, header, formData, body)
  let scheme = call_595017.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595017.url(scheme.get, call_595017.host, call_595017.base,
                         call_595017.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595017, url, valid)

proc call*(call_595018: Call_GetDeployedApplicationHealthUsingPolicy_595006;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ApplicationHealthPolicy: JsonNode = nil;
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealthUsingPolicy
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595019 = newJObject()
  var query_595020 = newJObject()
  var body_595021 = newJObject()
  add(query_595020, "timeout", newJInt(timeout))
  add(query_595020, "api-version", newJString(apiVersion))
  add(path_595019, "nodeName", newJString(nodeName))
  if ApplicationHealthPolicy != nil:
    body_595021 = ApplicationHealthPolicy
  add(query_595020, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_595020, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595020, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595019, "applicationId", newJString(applicationId))
  result = call_595018.call(path_595019, query_595020, nil, nil, body_595021)

var getDeployedApplicationHealthUsingPolicy* = Call_GetDeployedApplicationHealthUsingPolicy_595006(
    name: "getDeployedApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealthUsingPolicy_595007, base: "",
    url: url_GetDeployedApplicationHealthUsingPolicy_595008,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealth_594992 = ref object of OpenApiRestCall_593438
proc url_GetDeployedApplicationHealth_594994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealth_594993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_594995 = path.getOrDefault("nodeName")
  valid_594995 = validateParameter(valid_594995, JString, required = true,
                                 default = nil)
  if valid_594995 != nil:
    section.add "nodeName", valid_594995
  var valid_594996 = path.getOrDefault("applicationId")
  valid_594996 = validateParameter(valid_594996, JString, required = true,
                                 default = nil)
  if valid_594996 != nil:
    section.add "applicationId", valid_594996
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_594997 = query.getOrDefault("timeout")
  valid_594997 = validateParameter(valid_594997, JInt, required = false,
                                 default = newJInt(60))
  if valid_594997 != nil:
    section.add "timeout", valid_594997
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_594998 = query.getOrDefault("api-version")
  valid_594998 = validateParameter(valid_594998, JString, required = true,
                                 default = newJString("6.0"))
  if valid_594998 != nil:
    section.add "api-version", valid_594998
  var valid_594999 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_594999 = validateParameter(valid_594999, JInt, required = false,
                                 default = newJInt(0))
  if valid_594999 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_594999
  var valid_595000 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595000 = validateParameter(valid_595000, JBool, required = false,
                                 default = newJBool(false))
  if valid_595000 != nil:
    section.add "ExcludeHealthStatistics", valid_595000
  var valid_595001 = query.getOrDefault("EventsHealthStateFilter")
  valid_595001 = validateParameter(valid_595001, JInt, required = false,
                                 default = newJInt(0))
  if valid_595001 != nil:
    section.add "EventsHealthStateFilter", valid_595001
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595002: Call_GetDeployedApplicationHealth_594992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  let valid = call_595002.validator(path, query, header, formData, body)
  let scheme = call_595002.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595002.url(scheme.get, call_595002.host, call_595002.base,
                         call_595002.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595002, url, valid)

proc call*(call_595003: Call_GetDeployedApplicationHealth_594992; nodeName: string;
          applicationId: string; timeout: int = 60; apiVersion: string = "6.0";
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealth
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595004 = newJObject()
  var query_595005 = newJObject()
  add(query_595005, "timeout", newJInt(timeout))
  add(query_595005, "api-version", newJString(apiVersion))
  add(path_595004, "nodeName", newJString(nodeName))
  add(query_595005, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_595005, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595005, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595004, "applicationId", newJString(applicationId))
  result = call_595003.call(path_595004, query_595005, nil, nil, nil)

var getDeployedApplicationHealth* = Call_GetDeployedApplicationHealth_594992(
    name: "getDeployedApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealth_594993, base: "",
    url: url_GetDeployedApplicationHealth_594994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaInfoList_595022 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServiceReplicaInfoList_595024(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaInfoList_595023(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595025 = path.getOrDefault("nodeName")
  valid_595025 = validateParameter(valid_595025, JString, required = true,
                                 default = nil)
  if valid_595025 != nil:
    section.add "nodeName", valid_595025
  var valid_595026 = path.getOrDefault("applicationId")
  valid_595026 = validateParameter(valid_595026, JString, required = true,
                                 default = nil)
  if valid_595026 != nil:
    section.add "applicationId", valid_595026
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   PartitionId: JString
  ##              : The identity of the partition.
  section = newJObject()
  var valid_595027 = query.getOrDefault("timeout")
  valid_595027 = validateParameter(valid_595027, JInt, required = false,
                                 default = newJInt(60))
  if valid_595027 != nil:
    section.add "timeout", valid_595027
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595028 = query.getOrDefault("api-version")
  valid_595028 = validateParameter(valid_595028, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595028 != nil:
    section.add "api-version", valid_595028
  var valid_595029 = query.getOrDefault("ServiceManifestName")
  valid_595029 = validateParameter(valid_595029, JString, required = false,
                                 default = nil)
  if valid_595029 != nil:
    section.add "ServiceManifestName", valid_595029
  var valid_595030 = query.getOrDefault("PartitionId")
  valid_595030 = validateParameter(valid_595030, JString, required = false,
                                 default = nil)
  if valid_595030 != nil:
    section.add "PartitionId", valid_595030
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595031: Call_GetDeployedServiceReplicaInfoList_595022;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  let valid = call_595031.validator(path, query, header, formData, body)
  let scheme = call_595031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595031.url(scheme.get, call_595031.host, call_595031.base,
                         call_595031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595031, url, valid)

proc call*(call_595032: Call_GetDeployedServiceReplicaInfoList_595022;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = "";
          PartitionId: string = ""): Recallable =
  ## getDeployedServiceReplicaInfoList
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   PartitionId: string
  ##              : The identity of the partition.
  var path_595033 = newJObject()
  var query_595034 = newJObject()
  add(query_595034, "timeout", newJInt(timeout))
  add(query_595034, "api-version", newJString(apiVersion))
  add(path_595033, "nodeName", newJString(nodeName))
  add(query_595034, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_595033, "applicationId", newJString(applicationId))
  add(query_595034, "PartitionId", newJString(PartitionId))
  result = call_595032.call(path_595033, query_595034, nil, nil, nil)

var getDeployedServiceReplicaInfoList* = Call_GetDeployedServiceReplicaInfoList_595022(
    name: "getDeployedServiceReplicaInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaInfoList_595023, base: "",
    url: url_GetDeployedServiceReplicaInfoList_595024,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoList_595035 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServicePackageInfoList_595037(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoList_595036(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595038 = path.getOrDefault("nodeName")
  valid_595038 = validateParameter(valid_595038, JString, required = true,
                                 default = nil)
  if valid_595038 != nil:
    section.add "nodeName", valid_595038
  var valid_595039 = path.getOrDefault("applicationId")
  valid_595039 = validateParameter(valid_595039, JString, required = true,
                                 default = nil)
  if valid_595039 != nil:
    section.add "applicationId", valid_595039
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595040 = query.getOrDefault("timeout")
  valid_595040 = validateParameter(valid_595040, JInt, required = false,
                                 default = newJInt(60))
  if valid_595040 != nil:
    section.add "timeout", valid_595040
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595041 = query.getOrDefault("api-version")
  valid_595041 = validateParameter(valid_595041, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595041 != nil:
    section.add "api-version", valid_595041
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595042: Call_GetDeployedServicePackageInfoList_595035;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_595042.validator(path, query, header, formData, body)
  let scheme = call_595042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595042.url(scheme.get, call_595042.host, call_595042.base,
                         call_595042.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595042, url, valid)

proc call*(call_595043: Call_GetDeployedServicePackageInfoList_595035;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServicePackageInfoList
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595044 = newJObject()
  var query_595045 = newJObject()
  add(query_595045, "timeout", newJInt(timeout))
  add(query_595045, "api-version", newJString(apiVersion))
  add(path_595044, "nodeName", newJString(nodeName))
  add(path_595044, "applicationId", newJString(applicationId))
  result = call_595043.call(path_595044, query_595045, nil, nil, nil)

var getDeployedServicePackageInfoList* = Call_GetDeployedServicePackageInfoList_595035(
    name: "getDeployedServicePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages",
    validator: validate_GetDeployedServicePackageInfoList_595036, base: "",
    url: url_GetDeployedServicePackageInfoList_595037,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoListByName_595046 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServicePackageInfoListByName_595048(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoListByName_595047(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595049 = path.getOrDefault("nodeName")
  valid_595049 = validateParameter(valid_595049, JString, required = true,
                                 default = nil)
  if valid_595049 != nil:
    section.add "nodeName", valid_595049
  var valid_595050 = path.getOrDefault("applicationId")
  valid_595050 = validateParameter(valid_595050, JString, required = true,
                                 default = nil)
  if valid_595050 != nil:
    section.add "applicationId", valid_595050
  var valid_595051 = path.getOrDefault("servicePackageName")
  valid_595051 = validateParameter(valid_595051, JString, required = true,
                                 default = nil)
  if valid_595051 != nil:
    section.add "servicePackageName", valid_595051
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595052 = query.getOrDefault("timeout")
  valid_595052 = validateParameter(valid_595052, JInt, required = false,
                                 default = newJInt(60))
  if valid_595052 != nil:
    section.add "timeout", valid_595052
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595053 = query.getOrDefault("api-version")
  valid_595053 = validateParameter(valid_595053, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595053 != nil:
    section.add "api-version", valid_595053
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595054: Call_GetDeployedServicePackageInfoListByName_595046;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  let valid = call_595054.validator(path, query, header, formData, body)
  let scheme = call_595054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595054.url(scheme.get, call_595054.host, call_595054.base,
                         call_595054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595054, url, valid)

proc call*(call_595055: Call_GetDeployedServicePackageInfoListByName_595046;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getDeployedServicePackageInfoListByName
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_595056 = newJObject()
  var query_595057 = newJObject()
  add(query_595057, "timeout", newJInt(timeout))
  add(query_595057, "api-version", newJString(apiVersion))
  add(path_595056, "nodeName", newJString(nodeName))
  add(path_595056, "applicationId", newJString(applicationId))
  add(path_595056, "servicePackageName", newJString(servicePackageName))
  result = call_595055.call(path_595056, query_595057, nil, nil, nil)

var getDeployedServicePackageInfoListByName* = Call_GetDeployedServicePackageInfoListByName_595046(
    name: "getDeployedServicePackageInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}",
    validator: validate_GetDeployedServicePackageInfoListByName_595047, base: "",
    url: url_GetDeployedServicePackageInfoListByName_595048,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealthUsingPolicy_595071 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServicePackageHealthUsingPolicy_595073(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealthUsingPolicy_595072(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595074 = path.getOrDefault("nodeName")
  valid_595074 = validateParameter(valid_595074, JString, required = true,
                                 default = nil)
  if valid_595074 != nil:
    section.add "nodeName", valid_595074
  var valid_595075 = path.getOrDefault("applicationId")
  valid_595075 = validateParameter(valid_595075, JString, required = true,
                                 default = nil)
  if valid_595075 != nil:
    section.add "applicationId", valid_595075
  var valid_595076 = path.getOrDefault("servicePackageName")
  valid_595076 = validateParameter(valid_595076, JString, required = true,
                                 default = nil)
  if valid_595076 != nil:
    section.add "servicePackageName", valid_595076
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595077 = query.getOrDefault("timeout")
  valid_595077 = validateParameter(valid_595077, JInt, required = false,
                                 default = newJInt(60))
  if valid_595077 != nil:
    section.add "timeout", valid_595077
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595078 = query.getOrDefault("api-version")
  valid_595078 = validateParameter(valid_595078, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595078 != nil:
    section.add "api-version", valid_595078
  var valid_595079 = query.getOrDefault("EventsHealthStateFilter")
  valid_595079 = validateParameter(valid_595079, JInt, required = false,
                                 default = newJInt(0))
  if valid_595079 != nil:
    section.add "EventsHealthStateFilter", valid_595079
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595081: Call_GetDeployedServicePackageHealthUsingPolicy_595071;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  let valid = call_595081.validator(path, query, header, formData, body)
  let scheme = call_595081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595081.url(scheme.get, call_595081.host, call_595081.base,
                         call_595081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595081, url, valid)

proc call*(call_595082: Call_GetDeployedServicePackageHealthUsingPolicy_595071;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealthUsingPolicy
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_595083 = newJObject()
  var query_595084 = newJObject()
  var body_595085 = newJObject()
  add(query_595084, "timeout", newJInt(timeout))
  add(query_595084, "api-version", newJString(apiVersion))
  add(path_595083, "nodeName", newJString(nodeName))
  if ApplicationHealthPolicy != nil:
    body_595085 = ApplicationHealthPolicy
  add(query_595084, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595083, "applicationId", newJString(applicationId))
  add(path_595083, "servicePackageName", newJString(servicePackageName))
  result = call_595082.call(path_595083, query_595084, nil, nil, body_595085)

var getDeployedServicePackageHealthUsingPolicy* = Call_GetDeployedServicePackageHealthUsingPolicy_595071(
    name: "getDeployedServicePackageHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealthUsingPolicy_595072,
    base: "", url: url_GetDeployedServicePackageHealthUsingPolicy_595073,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealth_595058 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServicePackageHealth_595060(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealth_595059(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595061 = path.getOrDefault("nodeName")
  valid_595061 = validateParameter(valid_595061, JString, required = true,
                                 default = nil)
  if valid_595061 != nil:
    section.add "nodeName", valid_595061
  var valid_595062 = path.getOrDefault("applicationId")
  valid_595062 = validateParameter(valid_595062, JString, required = true,
                                 default = nil)
  if valid_595062 != nil:
    section.add "applicationId", valid_595062
  var valid_595063 = path.getOrDefault("servicePackageName")
  valid_595063 = validateParameter(valid_595063, JString, required = true,
                                 default = nil)
  if valid_595063 != nil:
    section.add "servicePackageName", valid_595063
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595064 = query.getOrDefault("timeout")
  valid_595064 = validateParameter(valid_595064, JInt, required = false,
                                 default = newJInt(60))
  if valid_595064 != nil:
    section.add "timeout", valid_595064
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595065 = query.getOrDefault("api-version")
  valid_595065 = validateParameter(valid_595065, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595065 != nil:
    section.add "api-version", valid_595065
  var valid_595066 = query.getOrDefault("EventsHealthStateFilter")
  valid_595066 = validateParameter(valid_595066, JInt, required = false,
                                 default = newJInt(0))
  if valid_595066 != nil:
    section.add "EventsHealthStateFilter", valid_595066
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595067: Call_GetDeployedServicePackageHealth_595058;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  let valid = call_595067.validator(path, query, header, formData, body)
  let scheme = call_595067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595067.url(scheme.get, call_595067.host, call_595067.base,
                         call_595067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595067, url, valid)

proc call*(call_595068: Call_GetDeployedServicePackageHealth_595058;
          nodeName: string; applicationId: string; servicePackageName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealth
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_595069 = newJObject()
  var query_595070 = newJObject()
  add(query_595070, "timeout", newJInt(timeout))
  add(query_595070, "api-version", newJString(apiVersion))
  add(path_595069, "nodeName", newJString(nodeName))
  add(query_595070, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595069, "applicationId", newJString(applicationId))
  add(path_595069, "servicePackageName", newJString(servicePackageName))
  result = call_595068.call(path_595069, query_595070, nil, nil, nil)

var getDeployedServicePackageHealth* = Call_GetDeployedServicePackageHealth_595058(
    name: "getDeployedServicePackageHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealth_595059, base: "",
    url: url_GetDeployedServicePackageHealth_595060,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedServicePackageHealth_595086 = ref object of OpenApiRestCall_593438
proc url_ReportDeployedServicePackageHealth_595088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedServicePackageHealth_595087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595089 = path.getOrDefault("nodeName")
  valid_595089 = validateParameter(valid_595089, JString, required = true,
                                 default = nil)
  if valid_595089 != nil:
    section.add "nodeName", valid_595089
  var valid_595090 = path.getOrDefault("applicationId")
  valid_595090 = validateParameter(valid_595090, JString, required = true,
                                 default = nil)
  if valid_595090 != nil:
    section.add "applicationId", valid_595090
  var valid_595091 = path.getOrDefault("servicePackageName")
  valid_595091 = validateParameter(valid_595091, JString, required = true,
                                 default = nil)
  if valid_595091 != nil:
    section.add "servicePackageName", valid_595091
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595092 = query.getOrDefault("Immediate")
  valid_595092 = validateParameter(valid_595092, JBool, required = false,
                                 default = newJBool(false))
  if valid_595092 != nil:
    section.add "Immediate", valid_595092
  var valid_595093 = query.getOrDefault("timeout")
  valid_595093 = validateParameter(valid_595093, JInt, required = false,
                                 default = newJInt(60))
  if valid_595093 != nil:
    section.add "timeout", valid_595093
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595094 = query.getOrDefault("api-version")
  valid_595094 = validateParameter(valid_595094, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595094 != nil:
    section.add "api-version", valid_595094
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595096: Call_ReportDeployedServicePackageHealth_595086;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595096.validator(path, query, header, formData, body)
  let scheme = call_595096.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595096.url(scheme.get, call_595096.host, call_595096.base,
                         call_595096.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595096, url, valid)

proc call*(call_595097: Call_ReportDeployedServicePackageHealth_595086;
          nodeName: string; HealthInformation: JsonNode; applicationId: string;
          servicePackageName: string; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportDeployedServicePackageHealth
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  var path_595098 = newJObject()
  var query_595099 = newJObject()
  var body_595100 = newJObject()
  add(query_595099, "Immediate", newJBool(Immediate))
  add(query_595099, "timeout", newJInt(timeout))
  add(query_595099, "api-version", newJString(apiVersion))
  add(path_595098, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_595100 = HealthInformation
  add(path_595098, "applicationId", newJString(applicationId))
  add(path_595098, "servicePackageName", newJString(servicePackageName))
  result = call_595097.call(path_595098, query_595099, nil, nil, body_595100)

var reportDeployedServicePackageHealth* = Call_ReportDeployedServicePackageHealth_595086(
    name: "reportDeployedServicePackageHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth",
    validator: validate_ReportDeployedServicePackageHealth_595087, base: "",
    url: url_ReportDeployedServicePackageHealth_595088,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoList_595101 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServiceTypeInfoList_595103(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoList_595102(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595104 = path.getOrDefault("nodeName")
  valid_595104 = validateParameter(valid_595104, JString, required = true,
                                 default = nil)
  if valid_595104 != nil:
    section.add "nodeName", valid_595104
  var valid_595105 = path.getOrDefault("applicationId")
  valid_595105 = validateParameter(valid_595105, JString, required = true,
                                 default = nil)
  if valid_595105 != nil:
    section.add "applicationId", valid_595105
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  var valid_595106 = query.getOrDefault("timeout")
  valid_595106 = validateParameter(valid_595106, JInt, required = false,
                                 default = newJInt(60))
  if valid_595106 != nil:
    section.add "timeout", valid_595106
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595107 = query.getOrDefault("api-version")
  valid_595107 = validateParameter(valid_595107, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595107 != nil:
    section.add "api-version", valid_595107
  var valid_595108 = query.getOrDefault("ServiceManifestName")
  valid_595108 = validateParameter(valid_595108, JString, required = false,
                                 default = nil)
  if valid_595108 != nil:
    section.add "ServiceManifestName", valid_595108
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595109: Call_GetDeployedServiceTypeInfoList_595101; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  let valid = call_595109.validator(path, query, header, formData, body)
  let scheme = call_595109.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595109.url(scheme.get, call_595109.host, call_595109.base,
                         call_595109.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595109, url, valid)

proc call*(call_595110: Call_GetDeployedServiceTypeInfoList_595101;
          nodeName: string; applicationId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoList
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595111 = newJObject()
  var query_595112 = newJObject()
  add(query_595112, "timeout", newJInt(timeout))
  add(query_595112, "api-version", newJString(apiVersion))
  add(path_595111, "nodeName", newJString(nodeName))
  add(query_595112, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_595111, "applicationId", newJString(applicationId))
  result = call_595110.call(path_595111, query_595112, nil, nil, nil)

var getDeployedServiceTypeInfoList* = Call_GetDeployedServiceTypeInfoList_595101(
    name: "getDeployedServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes",
    validator: validate_GetDeployedServiceTypeInfoList_595102, base: "",
    url: url_GetDeployedServiceTypeInfoList_595103,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoByName_595113 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServiceTypeInfoByName_595115(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceTypeName" in path, "`serviceTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes/"),
               (kind: VariableSegment, value: "serviceTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoByName_595114(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceTypeName: JString (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `serviceTypeName` field"
  var valid_595116 = path.getOrDefault("serviceTypeName")
  valid_595116 = validateParameter(valid_595116, JString, required = true,
                                 default = nil)
  if valid_595116 != nil:
    section.add "serviceTypeName", valid_595116
  var valid_595117 = path.getOrDefault("nodeName")
  valid_595117 = validateParameter(valid_595117, JString, required = true,
                                 default = nil)
  if valid_595117 != nil:
    section.add "nodeName", valid_595117
  var valid_595118 = path.getOrDefault("applicationId")
  valid_595118 = validateParameter(valid_595118, JString, required = true,
                                 default = nil)
  if valid_595118 != nil:
    section.add "applicationId", valid_595118
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  var valid_595119 = query.getOrDefault("timeout")
  valid_595119 = validateParameter(valid_595119, JInt, required = false,
                                 default = newJInt(60))
  if valid_595119 != nil:
    section.add "timeout", valid_595119
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595120 = query.getOrDefault("api-version")
  valid_595120 = validateParameter(valid_595120, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595120 != nil:
    section.add "api-version", valid_595120
  var valid_595121 = query.getOrDefault("ServiceManifestName")
  valid_595121 = validateParameter(valid_595121, JString, required = false,
                                 default = nil)
  if valid_595121 != nil:
    section.add "ServiceManifestName", valid_595121
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595122: Call_GetDeployedServiceTypeInfoByName_595113;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  let valid = call_595122.validator(path, query, header, formData, body)
  let scheme = call_595122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595122.url(scheme.get, call_595122.host, call_595122.base,
                         call_595122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595122, url, valid)

proc call*(call_595123: Call_GetDeployedServiceTypeInfoByName_595113;
          serviceTypeName: string; nodeName: string; applicationId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoByName
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceTypeName: string (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595124 = newJObject()
  var query_595125 = newJObject()
  add(query_595125, "timeout", newJInt(timeout))
  add(path_595124, "serviceTypeName", newJString(serviceTypeName))
  add(query_595125, "api-version", newJString(apiVersion))
  add(path_595124, "nodeName", newJString(nodeName))
  add(query_595125, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_595124, "applicationId", newJString(applicationId))
  result = call_595123.call(path_595124, query_595125, nil, nil, nil)

var getDeployedServiceTypeInfoByName* = Call_GetDeployedServiceTypeInfoByName_595113(
    name: "getDeployedServiceTypeInfoByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}",
    validator: validate_GetDeployedServiceTypeInfoByName_595114, base: "",
    url: url_GetDeployedServiceTypeInfoByName_595115,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedApplicationHealth_595126 = ref object of OpenApiRestCall_593438
proc url_ReportDeployedApplicationHealth_595128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedApplicationHealth_595127(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595129 = path.getOrDefault("nodeName")
  valid_595129 = validateParameter(valid_595129, JString, required = true,
                                 default = nil)
  if valid_595129 != nil:
    section.add "nodeName", valid_595129
  var valid_595130 = path.getOrDefault("applicationId")
  valid_595130 = validateParameter(valid_595130, JString, required = true,
                                 default = nil)
  if valid_595130 != nil:
    section.add "applicationId", valid_595130
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595131 = query.getOrDefault("Immediate")
  valid_595131 = validateParameter(valid_595131, JBool, required = false,
                                 default = newJBool(false))
  if valid_595131 != nil:
    section.add "Immediate", valid_595131
  var valid_595132 = query.getOrDefault("timeout")
  valid_595132 = validateParameter(valid_595132, JInt, required = false,
                                 default = newJInt(60))
  if valid_595132 != nil:
    section.add "timeout", valid_595132
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595133 = query.getOrDefault("api-version")
  valid_595133 = validateParameter(valid_595133, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595133 != nil:
    section.add "api-version", valid_595133
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595135: Call_ReportDeployedApplicationHealth_595126;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595135.validator(path, query, header, formData, body)
  let scheme = call_595135.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595135.url(scheme.get, call_595135.host, call_595135.base,
                         call_595135.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595135, url, valid)

proc call*(call_595136: Call_ReportDeployedApplicationHealth_595126;
          nodeName: string; HealthInformation: JsonNode; applicationId: string;
          Immediate: bool = false; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportDeployedApplicationHealth
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_595137 = newJObject()
  var query_595138 = newJObject()
  var body_595139 = newJObject()
  add(query_595138, "Immediate", newJBool(Immediate))
  add(query_595138, "timeout", newJInt(timeout))
  add(query_595138, "api-version", newJString(apiVersion))
  add(path_595137, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_595139 = HealthInformation
  add(path_595137, "applicationId", newJString(applicationId))
  result = call_595136.call(path_595137, query_595138, nil, nil, body_595139)

var reportDeployedApplicationHealth* = Call_ReportDeployedApplicationHealth_595126(
    name: "reportDeployedApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth",
    validator: validate_ReportDeployedApplicationHealth_595127, base: "",
    url: url_ReportDeployedApplicationHealth_595128,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealthUsingPolicy_595151 = ref object of OpenApiRestCall_593438
proc url_GetNodeHealthUsingPolicy_595153(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealthUsingPolicy_595152(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595154 = path.getOrDefault("nodeName")
  valid_595154 = validateParameter(valid_595154, JString, required = true,
                                 default = nil)
  if valid_595154 != nil:
    section.add "nodeName", valid_595154
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595155 = query.getOrDefault("timeout")
  valid_595155 = validateParameter(valid_595155, JInt, required = false,
                                 default = newJInt(60))
  if valid_595155 != nil:
    section.add "timeout", valid_595155
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595156 = query.getOrDefault("api-version")
  valid_595156 = validateParameter(valid_595156, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595156 != nil:
    section.add "api-version", valid_595156
  var valid_595157 = query.getOrDefault("EventsHealthStateFilter")
  valid_595157 = validateParameter(valid_595157, JInt, required = false,
                                 default = newJInt(0))
  if valid_595157 != nil:
    section.add "EventsHealthStateFilter", valid_595157
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595159: Call_GetNodeHealthUsingPolicy_595151; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_595159.validator(path, query, header, formData, body)
  let scheme = call_595159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595159.url(scheme.get, call_595159.host, call_595159.base,
                         call_595159.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595159, url, valid)

proc call*(call_595160: Call_GetNodeHealthUsingPolicy_595151; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0; ClusterHealthPolicy: JsonNode = nil): Recallable =
  ## getNodeHealthUsingPolicy
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  var path_595161 = newJObject()
  var query_595162 = newJObject()
  var body_595163 = newJObject()
  add(query_595162, "timeout", newJInt(timeout))
  add(query_595162, "api-version", newJString(apiVersion))
  add(path_595161, "nodeName", newJString(nodeName))
  add(query_595162, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  if ClusterHealthPolicy != nil:
    body_595163 = ClusterHealthPolicy
  result = call_595160.call(path_595161, query_595162, nil, nil, body_595163)

var getNodeHealthUsingPolicy* = Call_GetNodeHealthUsingPolicy_595151(
    name: "getNodeHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetHealth",
    validator: validate_GetNodeHealthUsingPolicy_595152, base: "",
    url: url_GetNodeHealthUsingPolicy_595153, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealth_595140 = ref object of OpenApiRestCall_593438
proc url_GetNodeHealth_595142(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealth_595141(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595143 = path.getOrDefault("nodeName")
  valid_595143 = validateParameter(valid_595143, JString, required = true,
                                 default = nil)
  if valid_595143 != nil:
    section.add "nodeName", valid_595143
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595144 = query.getOrDefault("timeout")
  valid_595144 = validateParameter(valid_595144, JInt, required = false,
                                 default = newJInt(60))
  if valid_595144 != nil:
    section.add "timeout", valid_595144
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595145 = query.getOrDefault("api-version")
  valid_595145 = validateParameter(valid_595145, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595145 != nil:
    section.add "api-version", valid_595145
  var valid_595146 = query.getOrDefault("EventsHealthStateFilter")
  valid_595146 = validateParameter(valid_595146, JInt, required = false,
                                 default = newJInt(0))
  if valid_595146 != nil:
    section.add "EventsHealthStateFilter", valid_595146
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595147: Call_GetNodeHealth_595140; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_595147.validator(path, query, header, formData, body)
  let scheme = call_595147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595147.url(scheme.get, call_595147.host, call_595147.base,
                         call_595147.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595147, url, valid)

proc call*(call_595148: Call_GetNodeHealth_595140; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getNodeHealth
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_595149 = newJObject()
  var query_595150 = newJObject()
  add(query_595150, "timeout", newJInt(timeout))
  add(query_595150, "api-version", newJString(apiVersion))
  add(path_595149, "nodeName", newJString(nodeName))
  add(query_595150, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_595148.call(path_595149, query_595150, nil, nil, nil)

var getNodeHealth* = Call_GetNodeHealth_595140(name: "getNodeHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetHealth", validator: validate_GetNodeHealth_595141,
    base: "", url: url_GetNodeHealth_595142, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeLoadInfo_595164 = ref object of OpenApiRestCall_593438
proc url_GetNodeLoadInfo_595166(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeLoadInfo_595165(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the load information of a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595167 = path.getOrDefault("nodeName")
  valid_595167 = validateParameter(valid_595167, JString, required = true,
                                 default = nil)
  if valid_595167 != nil:
    section.add "nodeName", valid_595167
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595168 = query.getOrDefault("timeout")
  valid_595168 = validateParameter(valid_595168, JInt, required = false,
                                 default = newJInt(60))
  if valid_595168 != nil:
    section.add "timeout", valid_595168
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595169 = query.getOrDefault("api-version")
  valid_595169 = validateParameter(valid_595169, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595169 != nil:
    section.add "api-version", valid_595169
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595170: Call_GetNodeLoadInfo_595164; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the load information of a Service Fabric node.
  ## 
  let valid = call_595170.validator(path, query, header, formData, body)
  let scheme = call_595170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595170.url(scheme.get, call_595170.host, call_595170.base,
                         call_595170.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595170, url, valid)

proc call*(call_595171: Call_GetNodeLoadInfo_595164; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getNodeLoadInfo
  ## Gets the load information of a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_595172 = newJObject()
  var query_595173 = newJObject()
  add(query_595173, "timeout", newJInt(timeout))
  add(query_595173, "api-version", newJString(apiVersion))
  add(path_595172, "nodeName", newJString(nodeName))
  result = call_595171.call(path_595172, query_595173, nil, nil, nil)

var getNodeLoadInfo* = Call_GetNodeLoadInfo_595164(name: "getNodeLoadInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetLoadInformation",
    validator: validate_GetNodeLoadInfo_595165, base: "", url: url_GetNodeLoadInfo_595166,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfoByPartitionId_595174 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServiceReplicaDetailInfoByPartitionId_595176(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfoByPartitionId_595175(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595177 = path.getOrDefault("nodeName")
  valid_595177 = validateParameter(valid_595177, JString, required = true,
                                 default = nil)
  if valid_595177 != nil:
    section.add "nodeName", valid_595177
  var valid_595178 = path.getOrDefault("partitionId")
  valid_595178 = validateParameter(valid_595178, JString, required = true,
                                 default = nil)
  if valid_595178 != nil:
    section.add "partitionId", valid_595178
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595179 = query.getOrDefault("timeout")
  valid_595179 = validateParameter(valid_595179, JInt, required = false,
                                 default = newJInt(60))
  if valid_595179 != nil:
    section.add "timeout", valid_595179
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595180 = query.getOrDefault("api-version")
  valid_595180 = validateParameter(valid_595180, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595180 != nil:
    section.add "api-version", valid_595180
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595181: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_595174;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_595181.validator(path, query, header, formData, body)
  let scheme = call_595181.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595181.url(scheme.get, call_595181.host, call_595181.base,
                         call_595181.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595181, url, valid)

proc call*(call_595182: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_595174;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServiceReplicaDetailInfoByPartitionId
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595183 = newJObject()
  var query_595184 = newJObject()
  add(query_595184, "timeout", newJInt(timeout))
  add(query_595184, "api-version", newJString(apiVersion))
  add(path_595183, "nodeName", newJString(nodeName))
  add(path_595183, "partitionId", newJString(partitionId))
  result = call_595182.call(path_595183, query_595184, nil, nil, nil)

var getDeployedServiceReplicaDetailInfoByPartitionId* = Call_GetDeployedServiceReplicaDetailInfoByPartitionId_595174(
    name: "getDeployedServiceReplicaDetailInfoByPartitionId",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaDetailInfoByPartitionId_595175,
    base: "", url: url_GetDeployedServiceReplicaDetailInfoByPartitionId_595176,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveReplica_595185 = ref object of OpenApiRestCall_593438
proc url_RemoveReplica_595187(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveReplica_595186(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595188 = path.getOrDefault("replicaId")
  valid_595188 = validateParameter(valid_595188, JString, required = true,
                                 default = nil)
  if valid_595188 != nil:
    section.add "replicaId", valid_595188
  var valid_595189 = path.getOrDefault("nodeName")
  valid_595189 = validateParameter(valid_595189, JString, required = true,
                                 default = nil)
  if valid_595189 != nil:
    section.add "nodeName", valid_595189
  var valid_595190 = path.getOrDefault("partitionId")
  valid_595190 = validateParameter(valid_595190, JString, required = true,
                                 default = nil)
  if valid_595190 != nil:
    section.add "partitionId", valid_595190
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_595191 = query.getOrDefault("timeout")
  valid_595191 = validateParameter(valid_595191, JInt, required = false,
                                 default = newJInt(60))
  if valid_595191 != nil:
    section.add "timeout", valid_595191
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595192 = query.getOrDefault("api-version")
  valid_595192 = validateParameter(valid_595192, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595192 != nil:
    section.add "api-version", valid_595192
  var valid_595193 = query.getOrDefault("ForceRemove")
  valid_595193 = validateParameter(valid_595193, JBool, required = false, default = nil)
  if valid_595193 != nil:
    section.add "ForceRemove", valid_595193
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595194: Call_RemoveReplica_595185; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  let valid = call_595194.validator(path, query, header, formData, body)
  let scheme = call_595194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595194.url(scheme.get, call_595194.host, call_595194.base,
                         call_595194.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595194, url, valid)

proc call*(call_595195: Call_RemoveReplica_595185; replicaId: string;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## removeReplica
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595196 = newJObject()
  var query_595197 = newJObject()
  add(path_595196, "replicaId", newJString(replicaId))
  add(query_595197, "timeout", newJInt(timeout))
  add(query_595197, "api-version", newJString(apiVersion))
  add(query_595197, "ForceRemove", newJBool(ForceRemove))
  add(path_595196, "nodeName", newJString(nodeName))
  add(path_595196, "partitionId", newJString(partitionId))
  result = call_595195.call(path_595196, query_595197, nil, nil, nil)

var removeReplica* = Call_RemoveReplica_595185(name: "removeReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete",
    validator: validate_RemoveReplica_595186, base: "", url: url_RemoveReplica_595187,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfo_595198 = ref object of OpenApiRestCall_593438
proc url_GetDeployedServiceReplicaDetailInfo_595200(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetDetail")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfo_595199(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595201 = path.getOrDefault("replicaId")
  valid_595201 = validateParameter(valid_595201, JString, required = true,
                                 default = nil)
  if valid_595201 != nil:
    section.add "replicaId", valid_595201
  var valid_595202 = path.getOrDefault("nodeName")
  valid_595202 = validateParameter(valid_595202, JString, required = true,
                                 default = nil)
  if valid_595202 != nil:
    section.add "nodeName", valid_595202
  var valid_595203 = path.getOrDefault("partitionId")
  valid_595203 = validateParameter(valid_595203, JString, required = true,
                                 default = nil)
  if valid_595203 != nil:
    section.add "partitionId", valid_595203
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595204 = query.getOrDefault("timeout")
  valid_595204 = validateParameter(valid_595204, JInt, required = false,
                                 default = newJInt(60))
  if valid_595204 != nil:
    section.add "timeout", valid_595204
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595205 = query.getOrDefault("api-version")
  valid_595205 = validateParameter(valid_595205, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595205 != nil:
    section.add "api-version", valid_595205
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595206: Call_GetDeployedServiceReplicaDetailInfo_595198;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_595206.validator(path, query, header, formData, body)
  let scheme = call_595206.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595206.url(scheme.get, call_595206.host, call_595206.base,
                         call_595206.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595206, url, valid)

proc call*(call_595207: Call_GetDeployedServiceReplicaDetailInfo_595198;
          replicaId: string; nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## getDeployedServiceReplicaDetailInfo
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595208 = newJObject()
  var query_595209 = newJObject()
  add(path_595208, "replicaId", newJString(replicaId))
  add(query_595209, "timeout", newJInt(timeout))
  add(query_595209, "api-version", newJString(apiVersion))
  add(path_595208, "nodeName", newJString(nodeName))
  add(path_595208, "partitionId", newJString(partitionId))
  result = call_595207.call(path_595208, query_595209, nil, nil, nil)

var getDeployedServiceReplicaDetailInfo* = Call_GetDeployedServiceReplicaDetailInfo_595198(
    name: "getDeployedServiceReplicaDetailInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail",
    validator: validate_GetDeployedServiceReplicaDetailInfo_595199, base: "",
    url: url_GetDeployedServiceReplicaDetailInfo_595200,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartReplica_595210 = ref object of OpenApiRestCall_593438
proc url_RestartReplica_595212(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartReplica_595211(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595213 = path.getOrDefault("replicaId")
  valid_595213 = validateParameter(valid_595213, JString, required = true,
                                 default = nil)
  if valid_595213 != nil:
    section.add "replicaId", valid_595213
  var valid_595214 = path.getOrDefault("nodeName")
  valid_595214 = validateParameter(valid_595214, JString, required = true,
                                 default = nil)
  if valid_595214 != nil:
    section.add "nodeName", valid_595214
  var valid_595215 = path.getOrDefault("partitionId")
  valid_595215 = validateParameter(valid_595215, JString, required = true,
                                 default = nil)
  if valid_595215 != nil:
    section.add "partitionId", valid_595215
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595216 = query.getOrDefault("timeout")
  valid_595216 = validateParameter(valid_595216, JInt, required = false,
                                 default = newJInt(60))
  if valid_595216 != nil:
    section.add "timeout", valid_595216
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595217 = query.getOrDefault("api-version")
  valid_595217 = validateParameter(valid_595217, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595217 != nil:
    section.add "api-version", valid_595217
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595218: Call_RestartReplica_595210; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  let valid = call_595218.validator(path, query, header, formData, body)
  let scheme = call_595218.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595218.url(scheme.get, call_595218.host, call_595218.base,
                         call_595218.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595218, url, valid)

proc call*(call_595219: Call_RestartReplica_595210; replicaId: string;
          nodeName: string; partitionId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## restartReplica
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595220 = newJObject()
  var query_595221 = newJObject()
  add(path_595220, "replicaId", newJString(replicaId))
  add(query_595221, "timeout", newJInt(timeout))
  add(query_595221, "api-version", newJString(apiVersion))
  add(path_595220, "nodeName", newJString(nodeName))
  add(path_595220, "partitionId", newJString(partitionId))
  result = call_595219.call(path_595220, query_595221, nil, nil, nil)

var restartReplica* = Call_RestartReplica_595210(name: "restartReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart",
    validator: validate_RestartReplica_595211, base: "", url: url_RestartReplica_595212,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveNodeState_595222 = ref object of OpenApiRestCall_593438
proc url_RemoveNodeState_595224(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/RemoveNodeState")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveNodeState_595223(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595225 = path.getOrDefault("nodeName")
  valid_595225 = validateParameter(valid_595225, JString, required = true,
                                 default = nil)
  if valid_595225 != nil:
    section.add "nodeName", valid_595225
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595226 = query.getOrDefault("timeout")
  valid_595226 = validateParameter(valid_595226, JInt, required = false,
                                 default = newJInt(60))
  if valid_595226 != nil:
    section.add "timeout", valid_595226
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595227 = query.getOrDefault("api-version")
  valid_595227 = validateParameter(valid_595227, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595227 != nil:
    section.add "api-version", valid_595227
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595228: Call_RemoveNodeState_595222; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  let valid = call_595228.validator(path, query, header, formData, body)
  let scheme = call_595228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595228.url(scheme.get, call_595228.host, call_595228.base,
                         call_595228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595228, url, valid)

proc call*(call_595229: Call_RemoveNodeState_595222; nodeName: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## removeNodeState
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_595230 = newJObject()
  var query_595231 = newJObject()
  add(query_595231, "timeout", newJInt(timeout))
  add(query_595231, "api-version", newJString(apiVersion))
  add(path_595230, "nodeName", newJString(nodeName))
  result = call_595229.call(path_595230, query_595231, nil, nil, nil)

var removeNodeState* = Call_RemoveNodeState_595222(name: "removeNodeState",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/RemoveNodeState",
    validator: validate_RemoveNodeState_595223, base: "", url: url_RemoveNodeState_595224,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportNodeHealth_595232 = ref object of OpenApiRestCall_593438
proc url_ReportNodeHealth_595234(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportNodeHealth_595233(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595235 = path.getOrDefault("nodeName")
  valid_595235 = validateParameter(valid_595235, JString, required = true,
                                 default = nil)
  if valid_595235 != nil:
    section.add "nodeName", valid_595235
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595236 = query.getOrDefault("Immediate")
  valid_595236 = validateParameter(valid_595236, JBool, required = false,
                                 default = newJBool(false))
  if valid_595236 != nil:
    section.add "Immediate", valid_595236
  var valid_595237 = query.getOrDefault("timeout")
  valid_595237 = validateParameter(valid_595237, JInt, required = false,
                                 default = newJInt(60))
  if valid_595237 != nil:
    section.add "timeout", valid_595237
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595238 = query.getOrDefault("api-version")
  valid_595238 = validateParameter(valid_595238, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595238 != nil:
    section.add "api-version", valid_595238
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595240: Call_ReportNodeHealth_595232; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595240.validator(path, query, header, formData, body)
  let scheme = call_595240.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595240.url(scheme.get, call_595240.host, call_595240.base,
                         call_595240.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595240, url, valid)

proc call*(call_595241: Call_ReportNodeHealth_595232; nodeName: string;
          HealthInformation: JsonNode; Immediate: bool = false; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## reportNodeHealth
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  var path_595242 = newJObject()
  var query_595243 = newJObject()
  var body_595244 = newJObject()
  add(query_595243, "Immediate", newJBool(Immediate))
  add(query_595243, "timeout", newJInt(timeout))
  add(query_595243, "api-version", newJString(apiVersion))
  add(path_595242, "nodeName", newJString(nodeName))
  if HealthInformation != nil:
    body_595244 = HealthInformation
  result = call_595241.call(path_595242, query_595243, nil, nil, body_595244)

var reportNodeHealth* = Call_ReportNodeHealth_595232(name: "reportNodeHealth",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/ReportHealth",
    validator: validate_ReportNodeHealth_595233, base: "",
    url: url_ReportNodeHealth_595234, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartNode_595245 = ref object of OpenApiRestCall_593438
proc url_RestartNode_595247(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartNode_595246(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_595248 = path.getOrDefault("nodeName")
  valid_595248 = validateParameter(valid_595248, JString, required = true,
                                 default = nil)
  if valid_595248 != nil:
    section.add "nodeName", valid_595248
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595249 = query.getOrDefault("timeout")
  valid_595249 = validateParameter(valid_595249, JInt, required = false,
                                 default = newJInt(60))
  if valid_595249 != nil:
    section.add "timeout", valid_595249
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595250 = query.getOrDefault("api-version")
  valid_595250 = validateParameter(valid_595250, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595250 != nil:
    section.add "api-version", valid_595250
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595252: Call_RestartNode_595245; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  let valid = call_595252.validator(path, query, header, formData, body)
  let scheme = call_595252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595252.url(scheme.get, call_595252.host, call_595252.base,
                         call_595252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595252, url, valid)

proc call*(call_595253: Call_RestartNode_595245; nodeName: string;
          RestartNodeDescription: JsonNode; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## restartNode
  ## Restarts a Service Fabric cluster node that is already started.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  var path_595254 = newJObject()
  var query_595255 = newJObject()
  var body_595256 = newJObject()
  add(query_595255, "timeout", newJInt(timeout))
  add(query_595255, "api-version", newJString(apiVersion))
  add(path_595254, "nodeName", newJString(nodeName))
  if RestartNodeDescription != nil:
    body_595256 = RestartNodeDescription
  result = call_595253.call(path_595254, query_595255, nil, nil, body_595256)

var restartNode* = Call_RestartNode_595245(name: "restartNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}/$/Restart",
                                        validator: validate_RestartNode_595246,
                                        base: "", url: url_RestartNode_595247,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfo_595257 = ref object of OpenApiRestCall_593438
proc url_GetPartitionInfo_595259(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfo_595258(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595260 = path.getOrDefault("partitionId")
  valid_595260 = validateParameter(valid_595260, JString, required = true,
                                 default = nil)
  if valid_595260 != nil:
    section.add "partitionId", valid_595260
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595261 = query.getOrDefault("timeout")
  valid_595261 = validateParameter(valid_595261, JInt, required = false,
                                 default = newJInt(60))
  if valid_595261 != nil:
    section.add "timeout", valid_595261
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595262 = query.getOrDefault("api-version")
  valid_595262 = validateParameter(valid_595262, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595262 != nil:
    section.add "api-version", valid_595262
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595263: Call_GetPartitionInfo_595257; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_595263.validator(path, query, header, formData, body)
  let scheme = call_595263.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595263.url(scheme.get, call_595263.host, call_595263.base,
                         call_595263.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595263, url, valid)

proc call*(call_595264: Call_GetPartitionInfo_595257; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionInfo
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595265 = newJObject()
  var query_595266 = newJObject()
  add(query_595266, "timeout", newJInt(timeout))
  add(query_595266, "api-version", newJString(apiVersion))
  add(path_595265, "partitionId", newJString(partitionId))
  result = call_595264.call(path_595265, query_595266, nil, nil, nil)

var getPartitionInfo* = Call_GetPartitionInfo_595257(name: "getPartitionInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}", validator: validate_GetPartitionInfo_595258,
    base: "", url: url_GetPartitionInfo_595259, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealthUsingPolicy_595280 = ref object of OpenApiRestCall_593438
proc url_GetPartitionHealthUsingPolicy_595282(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealthUsingPolicy_595281(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595283 = path.getOrDefault("partitionId")
  valid_595283 = validateParameter(valid_595283, JString, required = true,
                                 default = nil)
  if valid_595283 != nil:
    section.add "partitionId", valid_595283
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595284 = query.getOrDefault("timeout")
  valid_595284 = validateParameter(valid_595284, JInt, required = false,
                                 default = newJInt(60))
  if valid_595284 != nil:
    section.add "timeout", valid_595284
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595285 = query.getOrDefault("api-version")
  valid_595285 = validateParameter(valid_595285, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595285 != nil:
    section.add "api-version", valid_595285
  var valid_595286 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_595286 = validateParameter(valid_595286, JInt, required = false,
                                 default = newJInt(0))
  if valid_595286 != nil:
    section.add "ReplicasHealthStateFilter", valid_595286
  var valid_595287 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595287 = validateParameter(valid_595287, JBool, required = false,
                                 default = newJBool(false))
  if valid_595287 != nil:
    section.add "ExcludeHealthStatistics", valid_595287
  var valid_595288 = query.getOrDefault("EventsHealthStateFilter")
  valid_595288 = validateParameter(valid_595288, JInt, required = false,
                                 default = newJInt(0))
  if valid_595288 != nil:
    section.add "EventsHealthStateFilter", valid_595288
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595290: Call_GetPartitionHealthUsingPolicy_595280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_595290.validator(path, query, header, formData, body)
  let scheme = call_595290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595290.url(scheme.get, call_595290.host, call_595290.base,
                         call_595290.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595290, url, valid)

proc call*(call_595291: Call_GetPartitionHealthUsingPolicy_595280;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ReplicasHealthStateFilter: int = 0;
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealthUsingPolicy
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595292 = newJObject()
  var query_595293 = newJObject()
  var body_595294 = newJObject()
  add(query_595293, "timeout", newJInt(timeout))
  add(query_595293, "api-version", newJString(apiVersion))
  add(query_595293, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  if ApplicationHealthPolicy != nil:
    body_595294 = ApplicationHealthPolicy
  add(query_595293, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595293, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595292, "partitionId", newJString(partitionId))
  result = call_595291.call(path_595292, query_595293, nil, nil, body_595294)

var getPartitionHealthUsingPolicy* = Call_GetPartitionHealthUsingPolicy_595280(
    name: "getPartitionHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealthUsingPolicy_595281, base: "",
    url: url_GetPartitionHealthUsingPolicy_595282,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealth_595267 = ref object of OpenApiRestCall_593438
proc url_GetPartitionHealth_595269(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealth_595268(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595270 = path.getOrDefault("partitionId")
  valid_595270 = validateParameter(valid_595270, JString, required = true,
                                 default = nil)
  if valid_595270 != nil:
    section.add "partitionId", valid_595270
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595271 = query.getOrDefault("timeout")
  valid_595271 = validateParameter(valid_595271, JInt, required = false,
                                 default = newJInt(60))
  if valid_595271 != nil:
    section.add "timeout", valid_595271
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595272 = query.getOrDefault("api-version")
  valid_595272 = validateParameter(valid_595272, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595272 != nil:
    section.add "api-version", valid_595272
  var valid_595273 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_595273 = validateParameter(valid_595273, JInt, required = false,
                                 default = newJInt(0))
  if valid_595273 != nil:
    section.add "ReplicasHealthStateFilter", valid_595273
  var valid_595274 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595274 = validateParameter(valid_595274, JBool, required = false,
                                 default = newJBool(false))
  if valid_595274 != nil:
    section.add "ExcludeHealthStatistics", valid_595274
  var valid_595275 = query.getOrDefault("EventsHealthStateFilter")
  valid_595275 = validateParameter(valid_595275, JInt, required = false,
                                 default = newJInt(0))
  if valid_595275 != nil:
    section.add "EventsHealthStateFilter", valid_595275
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595276: Call_GetPartitionHealth_595267; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_595276.validator(path, query, header, formData, body)
  let scheme = call_595276.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595276.url(scheme.get, call_595276.host, call_595276.base,
                         call_595276.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595276, url, valid)

proc call*(call_595277: Call_GetPartitionHealth_595267; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ReplicasHealthStateFilter: int = 0; ExcludeHealthStatistics: bool = false;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealth
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595278 = newJObject()
  var query_595279 = newJObject()
  add(query_595279, "timeout", newJInt(timeout))
  add(query_595279, "api-version", newJString(apiVersion))
  add(query_595279, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  add(query_595279, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595279, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595278, "partitionId", newJString(partitionId))
  result = call_595277.call(path_595278, query_595279, nil, nil, nil)

var getPartitionHealth* = Call_GetPartitionHealth_595267(
    name: "getPartitionHealth", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealth_595268, base: "",
    url: url_GetPartitionHealth_595269, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionLoadInformation_595295 = ref object of OpenApiRestCall_593438
proc url_GetPartitionLoadInformation_595297(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionLoadInformation_595296(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595298 = path.getOrDefault("partitionId")
  valid_595298 = validateParameter(valid_595298, JString, required = true,
                                 default = nil)
  if valid_595298 != nil:
    section.add "partitionId", valid_595298
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595299 = query.getOrDefault("timeout")
  valid_595299 = validateParameter(valid_595299, JInt, required = false,
                                 default = newJInt(60))
  if valid_595299 != nil:
    section.add "timeout", valid_595299
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595300 = query.getOrDefault("api-version")
  valid_595300 = validateParameter(valid_595300, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595300 != nil:
    section.add "api-version", valid_595300
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595301: Call_GetPartitionLoadInformation_595295; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  let valid = call_595301.validator(path, query, header, formData, body)
  let scheme = call_595301.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595301.url(scheme.get, call_595301.host, call_595301.base,
                         call_595301.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595301, url, valid)

proc call*(call_595302: Call_GetPartitionLoadInformation_595295;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getPartitionLoadInformation
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595303 = newJObject()
  var query_595304 = newJObject()
  add(query_595304, "timeout", newJInt(timeout))
  add(query_595304, "api-version", newJString(apiVersion))
  add(path_595303, "partitionId", newJString(partitionId))
  result = call_595302.call(path_595303, query_595304, nil, nil, nil)

var getPartitionLoadInformation* = Call_GetPartitionLoadInformation_595295(
    name: "getPartitionLoadInformation", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetLoadInformation",
    validator: validate_GetPartitionLoadInformation_595296, base: "",
    url: url_GetPartitionLoadInformation_595297,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfoList_595305 = ref object of OpenApiRestCall_593438
proc url_GetReplicaInfoList_595307(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfoList_595306(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595308 = path.getOrDefault("partitionId")
  valid_595308 = validateParameter(valid_595308, JString, required = true,
                                 default = nil)
  if valid_595308 != nil:
    section.add "partitionId", valid_595308
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_595309 = query.getOrDefault("timeout")
  valid_595309 = validateParameter(valid_595309, JInt, required = false,
                                 default = newJInt(60))
  if valid_595309 != nil:
    section.add "timeout", valid_595309
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595310 = query.getOrDefault("api-version")
  valid_595310 = validateParameter(valid_595310, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595310 != nil:
    section.add "api-version", valid_595310
  var valid_595311 = query.getOrDefault("ContinuationToken")
  valid_595311 = validateParameter(valid_595311, JString, required = false,
                                 default = nil)
  if valid_595311 != nil:
    section.add "ContinuationToken", valid_595311
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595312: Call_GetReplicaInfoList_595305; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_595312.validator(path, query, header, formData, body)
  let scheme = call_595312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595312.url(scheme.get, call_595312.host, call_595312.base,
                         call_595312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595312, url, valid)

proc call*(call_595313: Call_GetReplicaInfoList_595305; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = ""): Recallable =
  ## getReplicaInfoList
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_595314 = newJObject()
  var query_595315 = newJObject()
  add(query_595315, "timeout", newJInt(timeout))
  add(query_595315, "api-version", newJString(apiVersion))
  add(path_595314, "partitionId", newJString(partitionId))
  add(query_595315, "ContinuationToken", newJString(ContinuationToken))
  result = call_595313.call(path_595314, query_595315, nil, nil, nil)

var getReplicaInfoList* = Call_GetReplicaInfoList_595305(
    name: "getReplicaInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas",
    validator: validate_GetReplicaInfoList_595306, base: "",
    url: url_GetReplicaInfoList_595307, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfo_595316 = ref object of OpenApiRestCall_593438
proc url_GetReplicaInfo_595318(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfo_595317(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595319 = path.getOrDefault("replicaId")
  valid_595319 = validateParameter(valid_595319, JString, required = true,
                                 default = nil)
  if valid_595319 != nil:
    section.add "replicaId", valid_595319
  var valid_595320 = path.getOrDefault("partitionId")
  valid_595320 = validateParameter(valid_595320, JString, required = true,
                                 default = nil)
  if valid_595320 != nil:
    section.add "partitionId", valid_595320
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_595321 = query.getOrDefault("timeout")
  valid_595321 = validateParameter(valid_595321, JInt, required = false,
                                 default = newJInt(60))
  if valid_595321 != nil:
    section.add "timeout", valid_595321
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595322 = query.getOrDefault("api-version")
  valid_595322 = validateParameter(valid_595322, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595322 != nil:
    section.add "api-version", valid_595322
  var valid_595323 = query.getOrDefault("ContinuationToken")
  valid_595323 = validateParameter(valid_595323, JString, required = false,
                                 default = nil)
  if valid_595323 != nil:
    section.add "ContinuationToken", valid_595323
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595324: Call_GetReplicaInfo_595316; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_595324.validator(path, query, header, formData, body)
  let scheme = call_595324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595324.url(scheme.get, call_595324.host, call_595324.base,
                         call_595324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595324, url, valid)

proc call*(call_595325: Call_GetReplicaInfo_595316; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ContinuationToken: string = ""): Recallable =
  ## getReplicaInfo
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_595326 = newJObject()
  var query_595327 = newJObject()
  add(path_595326, "replicaId", newJString(replicaId))
  add(query_595327, "timeout", newJInt(timeout))
  add(query_595327, "api-version", newJString(apiVersion))
  add(path_595326, "partitionId", newJString(partitionId))
  add(query_595327, "ContinuationToken", newJString(ContinuationToken))
  result = call_595325.call(path_595326, query_595327, nil, nil, nil)

var getReplicaInfo* = Call_GetReplicaInfo_595316(name: "getReplicaInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}",
    validator: validate_GetReplicaInfo_595317, base: "", url: url_GetReplicaInfo_595318,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealthUsingPolicy_595340 = ref object of OpenApiRestCall_593438
proc url_GetReplicaHealthUsingPolicy_595342(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealthUsingPolicy_595341(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595343 = path.getOrDefault("replicaId")
  valid_595343 = validateParameter(valid_595343, JString, required = true,
                                 default = nil)
  if valid_595343 != nil:
    section.add "replicaId", valid_595343
  var valid_595344 = path.getOrDefault("partitionId")
  valid_595344 = validateParameter(valid_595344, JString, required = true,
                                 default = nil)
  if valid_595344 != nil:
    section.add "partitionId", valid_595344
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595345 = query.getOrDefault("timeout")
  valid_595345 = validateParameter(valid_595345, JInt, required = false,
                                 default = newJInt(60))
  if valid_595345 != nil:
    section.add "timeout", valid_595345
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595346 = query.getOrDefault("api-version")
  valid_595346 = validateParameter(valid_595346, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595346 != nil:
    section.add "api-version", valid_595346
  var valid_595347 = query.getOrDefault("EventsHealthStateFilter")
  valid_595347 = validateParameter(valid_595347, JInt, required = false,
                                 default = newJInt(0))
  if valid_595347 != nil:
    section.add "EventsHealthStateFilter", valid_595347
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595349: Call_GetReplicaHealthUsingPolicy_595340; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  let valid = call_595349.validator(path, query, header, formData, body)
  let scheme = call_595349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595349.url(scheme.get, call_595349.host, call_595349.base,
                         call_595349.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595349, url, valid)

proc call*(call_595350: Call_GetReplicaHealthUsingPolicy_595340; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil; EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealthUsingPolicy
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595351 = newJObject()
  var query_595352 = newJObject()
  var body_595353 = newJObject()
  add(path_595351, "replicaId", newJString(replicaId))
  add(query_595352, "timeout", newJInt(timeout))
  add(query_595352, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_595353 = ApplicationHealthPolicy
  add(query_595352, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595351, "partitionId", newJString(partitionId))
  result = call_595350.call(path_595351, query_595352, nil, nil, body_595353)

var getReplicaHealthUsingPolicy* = Call_GetReplicaHealthUsingPolicy_595340(
    name: "getReplicaHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealthUsingPolicy_595341, base: "",
    url: url_GetReplicaHealthUsingPolicy_595342,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealth_595328 = ref object of OpenApiRestCall_593438
proc url_GetReplicaHealth_595330(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealth_595329(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595331 = path.getOrDefault("replicaId")
  valid_595331 = validateParameter(valid_595331, JString, required = true,
                                 default = nil)
  if valid_595331 != nil:
    section.add "replicaId", valid_595331
  var valid_595332 = path.getOrDefault("partitionId")
  valid_595332 = validateParameter(valid_595332, JString, required = true,
                                 default = nil)
  if valid_595332 != nil:
    section.add "partitionId", valid_595332
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595333 = query.getOrDefault("timeout")
  valid_595333 = validateParameter(valid_595333, JInt, required = false,
                                 default = newJInt(60))
  if valid_595333 != nil:
    section.add "timeout", valid_595333
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595334 = query.getOrDefault("api-version")
  valid_595334 = validateParameter(valid_595334, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595334 != nil:
    section.add "api-version", valid_595334
  var valid_595335 = query.getOrDefault("EventsHealthStateFilter")
  valid_595335 = validateParameter(valid_595335, JInt, required = false,
                                 default = newJInt(0))
  if valid_595335 != nil:
    section.add "EventsHealthStateFilter", valid_595335
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595336: Call_GetReplicaHealth_595328; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  let valid = call_595336.validator(path, query, header, formData, body)
  let scheme = call_595336.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595336.url(scheme.get, call_595336.host, call_595336.base,
                         call_595336.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595336, url, valid)

proc call*(call_595337: Call_GetReplicaHealth_595328; replicaId: string;
          partitionId: string; timeout: int = 60; apiVersion: string = "6.0";
          EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealth
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595338 = newJObject()
  var query_595339 = newJObject()
  add(path_595338, "replicaId", newJString(replicaId))
  add(query_595339, "timeout", newJInt(timeout))
  add(query_595339, "api-version", newJString(apiVersion))
  add(query_595339, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595338, "partitionId", newJString(partitionId))
  result = call_595337.call(path_595338, query_595339, nil, nil, nil)

var getReplicaHealth* = Call_GetReplicaHealth_595328(name: "getReplicaHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealth_595329, base: "",
    url: url_GetReplicaHealth_595330, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportReplicaHealth_595354 = ref object of OpenApiRestCall_593438
proc url_ReportReplicaHealth_595356(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportReplicaHealth_595355(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_595357 = path.getOrDefault("replicaId")
  valid_595357 = validateParameter(valid_595357, JString, required = true,
                                 default = nil)
  if valid_595357 != nil:
    section.add "replicaId", valid_595357
  var valid_595358 = path.getOrDefault("partitionId")
  valid_595358 = validateParameter(valid_595358, JString, required = true,
                                 default = nil)
  if valid_595358 != nil:
    section.add "partitionId", valid_595358
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceKind: JString (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  section = newJObject()
  var valid_595359 = query.getOrDefault("Immediate")
  valid_595359 = validateParameter(valid_595359, JBool, required = false,
                                 default = newJBool(false))
  if valid_595359 != nil:
    section.add "Immediate", valid_595359
  var valid_595360 = query.getOrDefault("timeout")
  valid_595360 = validateParameter(valid_595360, JInt, required = false,
                                 default = newJInt(60))
  if valid_595360 != nil:
    section.add "timeout", valid_595360
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595361 = query.getOrDefault("api-version")
  valid_595361 = validateParameter(valid_595361, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595361 != nil:
    section.add "api-version", valid_595361
  var valid_595362 = query.getOrDefault("ServiceKind")
  valid_595362 = validateParameter(valid_595362, JString, required = true,
                                 default = newJString("Stateful"))
  if valid_595362 != nil:
    section.add "ServiceKind", valid_595362
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595364: Call_ReportReplicaHealth_595354; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595364.validator(path, query, header, formData, body)
  let scheme = call_595364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595364.url(scheme.get, call_595364.host, call_595364.base,
                         call_595364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595364, url, valid)

proc call*(call_595365: Call_ReportReplicaHealth_595354; replicaId: string;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0";
          ServiceKind: string = "Stateful"): Recallable =
  ## reportReplicaHealth
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ServiceKind: string (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  var path_595366 = newJObject()
  var query_595367 = newJObject()
  var body_595368 = newJObject()
  add(path_595366, "replicaId", newJString(replicaId))
  add(query_595367, "Immediate", newJBool(Immediate))
  add(query_595367, "timeout", newJInt(timeout))
  add(query_595367, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_595368 = HealthInformation
  add(path_595366, "partitionId", newJString(partitionId))
  add(query_595367, "ServiceKind", newJString(ServiceKind))
  result = call_595365.call(path_595366, query_595367, nil, nil, body_595368)

var reportReplicaHealth* = Call_ReportReplicaHealth_595354(
    name: "reportReplicaHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth",
    validator: validate_ReportReplicaHealth_595355, base: "",
    url: url_ReportReplicaHealth_595356, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceNameInfo_595369 = ref object of OpenApiRestCall_593438
proc url_GetServiceNameInfo_595371(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetServiceName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceNameInfo_595370(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595372 = path.getOrDefault("partitionId")
  valid_595372 = validateParameter(valid_595372, JString, required = true,
                                 default = nil)
  if valid_595372 != nil:
    section.add "partitionId", valid_595372
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595373 = query.getOrDefault("timeout")
  valid_595373 = validateParameter(valid_595373, JInt, required = false,
                                 default = newJInt(60))
  if valid_595373 != nil:
    section.add "timeout", valid_595373
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595374 = query.getOrDefault("api-version")
  valid_595374 = validateParameter(valid_595374, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595374 != nil:
    section.add "api-version", valid_595374
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595375: Call_GetServiceNameInfo_595369; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  let valid = call_595375.validator(path, query, header, formData, body)
  let scheme = call_595375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595375.url(scheme.get, call_595375.host, call_595375.base,
                         call_595375.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595375, url, valid)

proc call*(call_595376: Call_GetServiceNameInfo_595369; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceNameInfo
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595377 = newJObject()
  var query_595378 = newJObject()
  add(query_595378, "timeout", newJInt(timeout))
  add(query_595378, "api-version", newJString(apiVersion))
  add(path_595377, "partitionId", newJString(partitionId))
  result = call_595376.call(path_595377, query_595378, nil, nil, nil)

var getServiceNameInfo* = Call_GetServiceNameInfo_595369(
    name: "getServiceNameInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetServiceName",
    validator: validate_GetServiceNameInfo_595370, base: "",
    url: url_GetServiceNameInfo_595371, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverPartition_595379 = ref object of OpenApiRestCall_593438
proc url_RecoverPartition_595381(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverPartition_595380(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595382 = path.getOrDefault("partitionId")
  valid_595382 = validateParameter(valid_595382, JString, required = true,
                                 default = nil)
  if valid_595382 != nil:
    section.add "partitionId", valid_595382
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595383 = query.getOrDefault("timeout")
  valid_595383 = validateParameter(valid_595383, JInt, required = false,
                                 default = newJInt(60))
  if valid_595383 != nil:
    section.add "timeout", valid_595383
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595384 = query.getOrDefault("api-version")
  valid_595384 = validateParameter(valid_595384, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595384 != nil:
    section.add "api-version", valid_595384
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595385: Call_RecoverPartition_595379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_595385.validator(path, query, header, formData, body)
  let scheme = call_595385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595385.url(scheme.get, call_595385.host, call_595385.base,
                         call_595385.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595385, url, valid)

proc call*(call_595386: Call_RecoverPartition_595379; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## recoverPartition
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595387 = newJObject()
  var query_595388 = newJObject()
  add(query_595388, "timeout", newJInt(timeout))
  add(query_595388, "api-version", newJString(apiVersion))
  add(path_595387, "partitionId", newJString(partitionId))
  result = call_595386.call(path_595387, query_595388, nil, nil, nil)

var recoverPartition* = Call_RecoverPartition_595379(name: "recoverPartition",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/Recover",
    validator: validate_RecoverPartition_595380, base: "",
    url: url_RecoverPartition_595381, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportPartitionHealth_595389 = ref object of OpenApiRestCall_593438
proc url_ReportPartitionHealth_595391(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportPartitionHealth_595390(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595392 = path.getOrDefault("partitionId")
  valid_595392 = validateParameter(valid_595392, JString, required = true,
                                 default = nil)
  if valid_595392 != nil:
    section.add "partitionId", valid_595392
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595393 = query.getOrDefault("Immediate")
  valid_595393 = validateParameter(valid_595393, JBool, required = false,
                                 default = newJBool(false))
  if valid_595393 != nil:
    section.add "Immediate", valid_595393
  var valid_595394 = query.getOrDefault("timeout")
  valid_595394 = validateParameter(valid_595394, JInt, required = false,
                                 default = newJInt(60))
  if valid_595394 != nil:
    section.add "timeout", valid_595394
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595395 = query.getOrDefault("api-version")
  valid_595395 = validateParameter(valid_595395, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595395 != nil:
    section.add "api-version", valid_595395
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595397: Call_ReportPartitionHealth_595389; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595397.validator(path, query, header, formData, body)
  let scheme = call_595397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595397.url(scheme.get, call_595397.host, call_595397.base,
                         call_595397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595397, url, valid)

proc call*(call_595398: Call_ReportPartitionHealth_595389;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportPartitionHealth
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595399 = newJObject()
  var query_595400 = newJObject()
  var body_595401 = newJObject()
  add(query_595400, "Immediate", newJBool(Immediate))
  add(query_595400, "timeout", newJInt(timeout))
  add(query_595400, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_595401 = HealthInformation
  add(path_595399, "partitionId", newJString(partitionId))
  result = call_595398.call(path_595399, query_595400, nil, nil, body_595401)

var reportPartitionHealth* = Call_ReportPartitionHealth_595389(
    name: "reportPartitionHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ReportHealth",
    validator: validate_ReportPartitionHealth_595390, base: "",
    url: url_ReportPartitionHealth_595391, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResetPartitionLoad_595402 = ref object of OpenApiRestCall_593438
proc url_ResetPartitionLoad_595404(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ResetLoad")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResetPartitionLoad_595403(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_595405 = path.getOrDefault("partitionId")
  valid_595405 = validateParameter(valid_595405, JString, required = true,
                                 default = nil)
  if valid_595405 != nil:
    section.add "partitionId", valid_595405
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595406 = query.getOrDefault("timeout")
  valid_595406 = validateParameter(valid_595406, JInt, required = false,
                                 default = newJInt(60))
  if valid_595406 != nil:
    section.add "timeout", valid_595406
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595407 = query.getOrDefault("api-version")
  valid_595407 = validateParameter(valid_595407, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595407 != nil:
    section.add "api-version", valid_595407
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595408: Call_ResetPartitionLoad_595402; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  let valid = call_595408.validator(path, query, header, formData, body)
  let scheme = call_595408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595408.url(scheme.get, call_595408.host, call_595408.base,
                         call_595408.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595408, url, valid)

proc call*(call_595409: Call_ResetPartitionLoad_595402; partitionId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## resetPartitionLoad
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_595410 = newJObject()
  var query_595411 = newJObject()
  add(query_595411, "timeout", newJInt(timeout))
  add(query_595411, "api-version", newJString(apiVersion))
  add(path_595410, "partitionId", newJString(partitionId))
  result = call_595409.call(path_595410, query_595411, nil, nil, nil)

var resetPartitionLoad* = Call_ResetPartitionLoad_595402(
    name: "resetPartitionLoad", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ResetLoad",
    validator: validate_ResetPartitionLoad_595403, base: "",
    url: url_ResetPartitionLoad_595404, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverServicePartitions_595412 = ref object of OpenApiRestCall_593438
proc url_RecoverServicePartitions_595414(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/$/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverServicePartitions_595413(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595415 = path.getOrDefault("serviceId")
  valid_595415 = validateParameter(valid_595415, JString, required = true,
                                 default = nil)
  if valid_595415 != nil:
    section.add "serviceId", valid_595415
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595416 = query.getOrDefault("timeout")
  valid_595416 = validateParameter(valid_595416, JInt, required = false,
                                 default = newJInt(60))
  if valid_595416 != nil:
    section.add "timeout", valid_595416
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595417 = query.getOrDefault("api-version")
  valid_595417 = validateParameter(valid_595417, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595417 != nil:
    section.add "api-version", valid_595417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595418: Call_RecoverServicePartitions_595412; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_595418.validator(path, query, header, formData, body)
  let scheme = call_595418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595418.url(scheme.get, call_595418.host, call_595418.base,
                         call_595418.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595418, url, valid)

proc call*(call_595419: Call_RecoverServicePartitions_595412; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## recoverServicePartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595420 = newJObject()
  var query_595421 = newJObject()
  add(query_595421, "timeout", newJInt(timeout))
  add(query_595421, "api-version", newJString(apiVersion))
  add(path_595420, "serviceId", newJString(serviceId))
  result = call_595419.call(path_595420, query_595421, nil, nil, nil)

var recoverServicePartitions* = Call_RecoverServicePartitions_595412(
    name: "recoverServicePartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Services/$/{serviceId}/$/GetPartitions/$/Recover",
    validator: validate_RecoverServicePartitions_595413, base: "",
    url: url_RecoverServicePartitions_595414, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteService_595422 = ref object of OpenApiRestCall_593438
proc url_DeleteService_595424(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteService_595423(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595425 = path.getOrDefault("serviceId")
  valid_595425 = validateParameter(valid_595425, JString, required = true,
                                 default = nil)
  if valid_595425 != nil:
    section.add "serviceId", valid_595425
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  var valid_595426 = query.getOrDefault("timeout")
  valid_595426 = validateParameter(valid_595426, JInt, required = false,
                                 default = newJInt(60))
  if valid_595426 != nil:
    section.add "timeout", valid_595426
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595427 = query.getOrDefault("api-version")
  valid_595427 = validateParameter(valid_595427, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595427 != nil:
    section.add "api-version", valid_595427
  var valid_595428 = query.getOrDefault("ForceRemove")
  valid_595428 = validateParameter(valid_595428, JBool, required = false, default = nil)
  if valid_595428 != nil:
    section.add "ForceRemove", valid_595428
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595429: Call_DeleteService_595422; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  let valid = call_595429.validator(path, query, header, formData, body)
  let scheme = call_595429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595429.url(scheme.get, call_595429.host, call_595429.base,
                         call_595429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595429, url, valid)

proc call*(call_595430: Call_DeleteService_595422; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ForceRemove: bool = false): Recallable =
  ## deleteService
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595431 = newJObject()
  var query_595432 = newJObject()
  add(query_595432, "timeout", newJInt(timeout))
  add(query_595432, "api-version", newJString(apiVersion))
  add(query_595432, "ForceRemove", newJBool(ForceRemove))
  add(path_595431, "serviceId", newJString(serviceId))
  result = call_595430.call(path_595431, query_595432, nil, nil, nil)

var deleteService* = Call_DeleteService_595422(name: "deleteService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Delete", validator: validate_DeleteService_595423,
    base: "", url: url_DeleteService_595424, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationNameInfo_595433 = ref object of OpenApiRestCall_593438
proc url_GetApplicationNameInfo_595435(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetApplicationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationNameInfo_595434(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595436 = path.getOrDefault("serviceId")
  valid_595436 = validateParameter(valid_595436, JString, required = true,
                                 default = nil)
  if valid_595436 != nil:
    section.add "serviceId", valid_595436
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595437 = query.getOrDefault("timeout")
  valid_595437 = validateParameter(valid_595437, JInt, required = false,
                                 default = newJInt(60))
  if valid_595437 != nil:
    section.add "timeout", valid_595437
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595438 = query.getOrDefault("api-version")
  valid_595438 = validateParameter(valid_595438, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595438 != nil:
    section.add "api-version", valid_595438
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595439: Call_GetApplicationNameInfo_595433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  let valid = call_595439.validator(path, query, header, formData, body)
  let scheme = call_595439.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595439.url(scheme.get, call_595439.host, call_595439.base,
                         call_595439.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595439, url, valid)

proc call*(call_595440: Call_GetApplicationNameInfo_595433; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getApplicationNameInfo
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595441 = newJObject()
  var query_595442 = newJObject()
  add(query_595442, "timeout", newJInt(timeout))
  add(query_595442, "api-version", newJString(apiVersion))
  add(path_595441, "serviceId", newJString(serviceId))
  result = call_595440.call(path_595441, query_595442, nil, nil, nil)

var getApplicationNameInfo* = Call_GetApplicationNameInfo_595433(
    name: "getApplicationNameInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetApplicationName",
    validator: validate_GetApplicationNameInfo_595434, base: "",
    url: url_GetApplicationNameInfo_595435, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceDescription_595443 = ref object of OpenApiRestCall_593438
proc url_GetServiceDescription_595445(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetDescription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceDescription_595444(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595446 = path.getOrDefault("serviceId")
  valid_595446 = validateParameter(valid_595446, JString, required = true,
                                 default = nil)
  if valid_595446 != nil:
    section.add "serviceId", valid_595446
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595447 = query.getOrDefault("timeout")
  valid_595447 = validateParameter(valid_595447, JInt, required = false,
                                 default = newJInt(60))
  if valid_595447 != nil:
    section.add "timeout", valid_595447
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595448 = query.getOrDefault("api-version")
  valid_595448 = validateParameter(valid_595448, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595448 != nil:
    section.add "api-version", valid_595448
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595449: Call_GetServiceDescription_595443; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  let valid = call_595449.validator(path, query, header, formData, body)
  let scheme = call_595449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595449.url(scheme.get, call_595449.host, call_595449.base,
                         call_595449.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595449, url, valid)

proc call*(call_595450: Call_GetServiceDescription_595443; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## getServiceDescription
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595451 = newJObject()
  var query_595452 = newJObject()
  add(query_595452, "timeout", newJInt(timeout))
  add(query_595452, "api-version", newJString(apiVersion))
  add(path_595451, "serviceId", newJString(serviceId))
  result = call_595450.call(path_595451, query_595452, nil, nil, nil)

var getServiceDescription* = Call_GetServiceDescription_595443(
    name: "getServiceDescription", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetDescription",
    validator: validate_GetServiceDescription_595444, base: "",
    url: url_GetServiceDescription_595445, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealthUsingPolicy_595466 = ref object of OpenApiRestCall_593438
proc url_GetServiceHealthUsingPolicy_595468(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealthUsingPolicy_595467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595469 = path.getOrDefault("serviceId")
  valid_595469 = validateParameter(valid_595469, JString, required = true,
                                 default = nil)
  if valid_595469 != nil:
    section.add "serviceId", valid_595469
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595470 = query.getOrDefault("timeout")
  valid_595470 = validateParameter(valid_595470, JInt, required = false,
                                 default = newJInt(60))
  if valid_595470 != nil:
    section.add "timeout", valid_595470
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595471 = query.getOrDefault("api-version")
  valid_595471 = validateParameter(valid_595471, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595471 != nil:
    section.add "api-version", valid_595471
  var valid_595472 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595472 = validateParameter(valid_595472, JBool, required = false,
                                 default = newJBool(false))
  if valid_595472 != nil:
    section.add "ExcludeHealthStatistics", valid_595472
  var valid_595473 = query.getOrDefault("EventsHealthStateFilter")
  valid_595473 = validateParameter(valid_595473, JInt, required = false,
                                 default = newJInt(0))
  if valid_595473 != nil:
    section.add "EventsHealthStateFilter", valid_595473
  var valid_595474 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_595474 = validateParameter(valid_595474, JInt, required = false,
                                 default = newJInt(0))
  if valid_595474 != nil:
    section.add "PartitionsHealthStateFilter", valid_595474
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595476: Call_GetServiceHealthUsingPolicy_595466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_595476.validator(path, query, header, formData, body)
  let scheme = call_595476.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595476.url(scheme.get, call_595476.host, call_595476.base,
                         call_595476.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595476, url, valid)

proc call*(call_595477: Call_GetServiceHealthUsingPolicy_595466; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ApplicationHealthPolicy: JsonNode = nil;
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          PartitionsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealthUsingPolicy
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_595478 = newJObject()
  var query_595479 = newJObject()
  var body_595480 = newJObject()
  add(query_595479, "timeout", newJInt(timeout))
  add(query_595479, "api-version", newJString(apiVersion))
  if ApplicationHealthPolicy != nil:
    body_595480 = ApplicationHealthPolicy
  add(query_595479, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595479, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595478, "serviceId", newJString(serviceId))
  add(query_595479, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  result = call_595477.call(path_595478, query_595479, nil, nil, body_595480)

var getServiceHealthUsingPolicy* = Call_GetServiceHealthUsingPolicy_595466(
    name: "getServiceHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealthUsingPolicy_595467, base: "",
    url: url_GetServiceHealthUsingPolicy_595468,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealth_595453 = ref object of OpenApiRestCall_593438
proc url_GetServiceHealth_595455(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealth_595454(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595456 = path.getOrDefault("serviceId")
  valid_595456 = validateParameter(valid_595456, JString, required = true,
                                 default = nil)
  if valid_595456 != nil:
    section.add "serviceId", valid_595456
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_595457 = query.getOrDefault("timeout")
  valid_595457 = validateParameter(valid_595457, JInt, required = false,
                                 default = newJInt(60))
  if valid_595457 != nil:
    section.add "timeout", valid_595457
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595458 = query.getOrDefault("api-version")
  valid_595458 = validateParameter(valid_595458, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595458 != nil:
    section.add "api-version", valid_595458
  var valid_595459 = query.getOrDefault("ExcludeHealthStatistics")
  valid_595459 = validateParameter(valid_595459, JBool, required = false,
                                 default = newJBool(false))
  if valid_595459 != nil:
    section.add "ExcludeHealthStatistics", valid_595459
  var valid_595460 = query.getOrDefault("EventsHealthStateFilter")
  valid_595460 = validateParameter(valid_595460, JInt, required = false,
                                 default = newJInt(0))
  if valid_595460 != nil:
    section.add "EventsHealthStateFilter", valid_595460
  var valid_595461 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_595461 = validateParameter(valid_595461, JInt, required = false,
                                 default = newJInt(0))
  if valid_595461 != nil:
    section.add "PartitionsHealthStateFilter", valid_595461
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595462: Call_GetServiceHealth_595453; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_595462.validator(path, query, header, formData, body)
  let scheme = call_595462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595462.url(scheme.get, call_595462.host, call_595462.base,
                         call_595462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595462, url, valid)

proc call*(call_595463: Call_GetServiceHealth_595453; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0";
          ExcludeHealthStatistics: bool = false; EventsHealthStateFilter: int = 0;
          PartitionsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealth
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_595464 = newJObject()
  var query_595465 = newJObject()
  add(query_595465, "timeout", newJInt(timeout))
  add(query_595465, "api-version", newJString(apiVersion))
  add(query_595465, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_595465, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_595464, "serviceId", newJString(serviceId))
  add(query_595465, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  result = call_595463.call(path_595464, query_595465, nil, nil, nil)

var getServiceHealth* = Call_GetServiceHealth_595453(name: "getServiceHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealth_595454, base: "",
    url: url_GetServiceHealth_595455, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfoList_595481 = ref object of OpenApiRestCall_593438
proc url_GetPartitionInfoList_595483(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfoList_595482(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595484 = path.getOrDefault("serviceId")
  valid_595484 = validateParameter(valid_595484, JString, required = true,
                                 default = nil)
  if valid_595484 != nil:
    section.add "serviceId", valid_595484
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  section = newJObject()
  var valid_595485 = query.getOrDefault("timeout")
  valid_595485 = validateParameter(valid_595485, JInt, required = false,
                                 default = newJInt(60))
  if valid_595485 != nil:
    section.add "timeout", valid_595485
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595486 = query.getOrDefault("api-version")
  valid_595486 = validateParameter(valid_595486, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595486 != nil:
    section.add "api-version", valid_595486
  var valid_595487 = query.getOrDefault("ContinuationToken")
  valid_595487 = validateParameter(valid_595487, JString, required = false,
                                 default = nil)
  if valid_595487 != nil:
    section.add "ContinuationToken", valid_595487
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595488: Call_GetPartitionInfoList_595481; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_595488.validator(path, query, header, formData, body)
  let scheme = call_595488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595488.url(scheme.get, call_595488.host, call_595488.base,
                         call_595488.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595488, url, valid)

proc call*(call_595489: Call_GetPartitionInfoList_595481; serviceId: string;
          timeout: int = 60; apiVersion: string = "6.0"; ContinuationToken: string = ""): Recallable =
  ## getPartitionInfoList
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  var path_595490 = newJObject()
  var query_595491 = newJObject()
  add(query_595491, "timeout", newJInt(timeout))
  add(query_595491, "api-version", newJString(apiVersion))
  add(path_595490, "serviceId", newJString(serviceId))
  add(query_595491, "ContinuationToken", newJString(ContinuationToken))
  result = call_595489.call(path_595490, query_595491, nil, nil, nil)

var getPartitionInfoList* = Call_GetPartitionInfoList_595481(
    name: "getPartitionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetPartitions",
    validator: validate_GetPartitionInfoList_595482, base: "",
    url: url_GetPartitionInfoList_595483, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportServiceHealth_595492 = ref object of OpenApiRestCall_593438
proc url_ReportServiceHealth_595494(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportServiceHealth_595493(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595495 = path.getOrDefault("serviceId")
  valid_595495 = validateParameter(valid_595495, JString, required = true,
                                 default = nil)
  if valid_595495 != nil:
    section.add "serviceId", valid_595495
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595496 = query.getOrDefault("Immediate")
  valid_595496 = validateParameter(valid_595496, JBool, required = false,
                                 default = newJBool(false))
  if valid_595496 != nil:
    section.add "Immediate", valid_595496
  var valid_595497 = query.getOrDefault("timeout")
  valid_595497 = validateParameter(valid_595497, JInt, required = false,
                                 default = newJInt(60))
  if valid_595497 != nil:
    section.add "timeout", valid_595497
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595498 = query.getOrDefault("api-version")
  valid_595498 = validateParameter(valid_595498, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595498 != nil:
    section.add "api-version", valid_595498
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595500: Call_ReportServiceHealth_595492; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_595500.validator(path, query, header, formData, body)
  let scheme = call_595500.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595500.url(scheme.get, call_595500.host, call_595500.base,
                         call_595500.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595500, url, valid)

proc call*(call_595501: Call_ReportServiceHealth_595492;
          HealthInformation: JsonNode; serviceId: string; Immediate: bool = false;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## reportServiceHealth
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595502 = newJObject()
  var query_595503 = newJObject()
  var body_595504 = newJObject()
  add(query_595503, "Immediate", newJBool(Immediate))
  add(query_595503, "timeout", newJInt(timeout))
  add(query_595503, "api-version", newJString(apiVersion))
  if HealthInformation != nil:
    body_595504 = HealthInformation
  add(path_595502, "serviceId", newJString(serviceId))
  result = call_595501.call(path_595502, query_595503, nil, nil, body_595504)

var reportServiceHealth* = Call_ReportServiceHealth_595492(
    name: "reportServiceHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/ReportHealth",
    validator: validate_ReportServiceHealth_595493, base: "",
    url: url_ReportServiceHealth_595494, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResolveService_595505 = ref object of OpenApiRestCall_593438
proc url_ResolveService_595507(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ResolvePartition")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResolveService_595506(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595508 = path.getOrDefault("serviceId")
  valid_595508 = validateParameter(valid_595508, JString, required = true,
                                 default = nil)
  if valid_595508 != nil:
    section.add "serviceId", valid_595508
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyValue: JString
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyType: JInt
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   PreviousRspVersion: JString
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  section = newJObject()
  var valid_595509 = query.getOrDefault("timeout")
  valid_595509 = validateParameter(valid_595509, JInt, required = false,
                                 default = newJInt(60))
  if valid_595509 != nil:
    section.add "timeout", valid_595509
  var valid_595510 = query.getOrDefault("PartitionKeyValue")
  valid_595510 = validateParameter(valid_595510, JString, required = false,
                                 default = nil)
  if valid_595510 != nil:
    section.add "PartitionKeyValue", valid_595510
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595511 = query.getOrDefault("api-version")
  valid_595511 = validateParameter(valid_595511, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595511 != nil:
    section.add "api-version", valid_595511
  var valid_595512 = query.getOrDefault("PartitionKeyType")
  valid_595512 = validateParameter(valid_595512, JInt, required = false, default = nil)
  if valid_595512 != nil:
    section.add "PartitionKeyType", valid_595512
  var valid_595513 = query.getOrDefault("PreviousRspVersion")
  valid_595513 = validateParameter(valid_595513, JString, required = false,
                                 default = nil)
  if valid_595513 != nil:
    section.add "PreviousRspVersion", valid_595513
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595514: Call_ResolveService_595505; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  let valid = call_595514.validator(path, query, header, formData, body)
  let scheme = call_595514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595514.url(scheme.get, call_595514.host, call_595514.base,
                         call_595514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595514, url, valid)

proc call*(call_595515: Call_ResolveService_595505; serviceId: string;
          timeout: int = 60; PartitionKeyValue: string = ""; apiVersion: string = "6.0";
          PartitionKeyType: int = 0; PreviousRspVersion: string = ""): Recallable =
  ## resolveService
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyValue: string
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyType: int
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PreviousRspVersion: string
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  var path_595516 = newJObject()
  var query_595517 = newJObject()
  add(query_595517, "timeout", newJInt(timeout))
  add(query_595517, "PartitionKeyValue", newJString(PartitionKeyValue))
  add(query_595517, "api-version", newJString(apiVersion))
  add(query_595517, "PartitionKeyType", newJInt(PartitionKeyType))
  add(path_595516, "serviceId", newJString(serviceId))
  add(query_595517, "PreviousRspVersion", newJString(PreviousRspVersion))
  result = call_595515.call(path_595516, query_595517, nil, nil, nil)

var resolveService* = Call_ResolveService_595505(name: "resolveService",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/ResolvePartition",
    validator: validate_ResolveService_595506, base: "", url: url_ResolveService_595507,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateService_595518 = ref object of OpenApiRestCall_593438
proc url_UpdateService_595520(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Update")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateService_595519(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the specified service using the given update description.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_595521 = path.getOrDefault("serviceId")
  valid_595521 = validateParameter(valid_595521, JString, required = true,
                                 default = nil)
  if valid_595521 != nil:
    section.add "serviceId", valid_595521
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595522 = query.getOrDefault("timeout")
  valid_595522 = validateParameter(valid_595522, JInt, required = false,
                                 default = newJInt(60))
  if valid_595522 != nil:
    section.add "timeout", valid_595522
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595523 = query.getOrDefault("api-version")
  valid_595523 = validateParameter(valid_595523, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595523 != nil:
    section.add "api-version", valid_595523
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595525: Call_UpdateService_595518; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the specified service using the given update description.
  ## 
  let valid = call_595525.validator(path, query, header, formData, body)
  let scheme = call_595525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595525.url(scheme.get, call_595525.host, call_595525.base,
                         call_595525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595525, url, valid)

proc call*(call_595526: Call_UpdateService_595518;
          ServiceUpdateDescription: JsonNode; serviceId: string; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## updateService
  ## Updates the specified service using the given update description.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_595527 = newJObject()
  var query_595528 = newJObject()
  var body_595529 = newJObject()
  add(query_595528, "timeout", newJInt(timeout))
  add(query_595528, "api-version", newJString(apiVersion))
  if ServiceUpdateDescription != nil:
    body_595529 = ServiceUpdateDescription
  add(path_595527, "serviceId", newJString(serviceId))
  result = call_595526.call(path_595527, query_595528, nil, nil, body_595529)

var updateService* = Call_UpdateService_595518(name: "updateService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Update", validator: validate_UpdateService_595519,
    base: "", url: url_UpdateService_595520, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetChaosReport_595530 = ref object of OpenApiRestCall_593438
proc url_GetChaosReport_595532(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetChaosReport_595531(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EndTimeUtc: JString
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   StartTimeUtc: JString
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  section = newJObject()
  var valid_595533 = query.getOrDefault("timeout")
  valid_595533 = validateParameter(valid_595533, JInt, required = false,
                                 default = newJInt(60))
  if valid_595533 != nil:
    section.add "timeout", valid_595533
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595534 = query.getOrDefault("api-version")
  valid_595534 = validateParameter(valid_595534, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595534 != nil:
    section.add "api-version", valid_595534
  var valid_595535 = query.getOrDefault("EndTimeUtc")
  valid_595535 = validateParameter(valid_595535, JString, required = false,
                                 default = nil)
  if valid_595535 != nil:
    section.add "EndTimeUtc", valid_595535
  var valid_595536 = query.getOrDefault("ContinuationToken")
  valid_595536 = validateParameter(valid_595536, JString, required = false,
                                 default = nil)
  if valid_595536 != nil:
    section.add "ContinuationToken", valid_595536
  var valid_595537 = query.getOrDefault("StartTimeUtc")
  valid_595537 = validateParameter(valid_595537, JString, required = false,
                                 default = nil)
  if valid_595537 != nil:
    section.add "StartTimeUtc", valid_595537
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595538: Call_GetChaosReport_595530; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  let valid = call_595538.validator(path, query, header, formData, body)
  let scheme = call_595538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595538.url(scheme.get, call_595538.host, call_595538.base,
                         call_595538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595538, url, valid)

proc call*(call_595539: Call_GetChaosReport_595530; timeout: int = 60;
          apiVersion: string = "6.0"; EndTimeUtc: string = "";
          ContinuationToken: string = ""; StartTimeUtc: string = ""): Recallable =
  ## getChaosReport
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   EndTimeUtc: string
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   StartTimeUtc: string
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  var query_595540 = newJObject()
  add(query_595540, "timeout", newJInt(timeout))
  add(query_595540, "api-version", newJString(apiVersion))
  add(query_595540, "EndTimeUtc", newJString(EndTimeUtc))
  add(query_595540, "ContinuationToken", newJString(ContinuationToken))
  add(query_595540, "StartTimeUtc", newJString(StartTimeUtc))
  result = call_595539.call(nil, query_595540, nil, nil, nil)

var getChaosReport* = Call_GetChaosReport_595530(name: "getChaosReport",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Tools/Chaos/$/Report", validator: validate_GetChaosReport_595531,
    base: "", url: url_GetChaosReport_595532, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartChaos_595541 = ref object of OpenApiRestCall_593438
proc url_StartChaos_595543(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartChaos_595542(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595544 = query.getOrDefault("timeout")
  valid_595544 = validateParameter(valid_595544, JInt, required = false,
                                 default = newJInt(60))
  if valid_595544 != nil:
    section.add "timeout", valid_595544
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595545 = query.getOrDefault("api-version")
  valid_595545 = validateParameter(valid_595545, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595545 != nil:
    section.add "api-version", valid_595545
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_595547: Call_StartChaos_595541; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  let valid = call_595547.validator(path, query, header, formData, body)
  let scheme = call_595547.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595547.url(scheme.get, call_595547.host, call_595547.base,
                         call_595547.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595547, url, valid)

proc call*(call_595548: Call_StartChaos_595541; ChaosParameters: JsonNode;
          timeout: int = 60; apiVersion: string = "6.0"): Recallable =
  ## startChaos
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  var query_595549 = newJObject()
  var body_595550 = newJObject()
  add(query_595549, "timeout", newJInt(timeout))
  add(query_595549, "api-version", newJString(apiVersion))
  if ChaosParameters != nil:
    body_595550 = ChaosParameters
  result = call_595548.call(nil, query_595549, nil, nil, body_595550)

var startChaos* = Call_StartChaos_595541(name: "startChaos",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Tools/Chaos/$/Start",
                                      validator: validate_StartChaos_595542,
                                      base: "", url: url_StartChaos_595543,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopChaos_595551 = ref object of OpenApiRestCall_593438
proc url_StopChaos_595553(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StopChaos_595552(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  var valid_595554 = query.getOrDefault("timeout")
  valid_595554 = validateParameter(valid_595554, JInt, required = false,
                                 default = newJInt(60))
  if valid_595554 != nil:
    section.add "timeout", valid_595554
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_595555 = query.getOrDefault("api-version")
  valid_595555 = validateParameter(valid_595555, JString, required = true,
                                 default = newJString("6.0"))
  if valid_595555 != nil:
    section.add "api-version", valid_595555
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595556: Call_StopChaos_595551; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  let valid = call_595556.validator(path, query, header, formData, body)
  let scheme = call_595556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595556.url(scheme.get, call_595556.host, call_595556.base,
                         call_595556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595556, url, valid)

proc call*(call_595557: Call_StopChaos_595551; timeout: int = 60;
          apiVersion: string = "6.0"): Recallable =
  ## stopChaos
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  var query_595558 = newJObject()
  add(query_595558, "timeout", newJInt(timeout))
  add(query_595558, "api-version", newJString(apiVersion))
  result = call_595557.call(nil, query_595558, nil, nil, nil)

var stopChaos* = Call_StopChaos_595551(name: "stopChaos", meth: HttpMethod.HttpPost,
                                    host: "azure.local:19080",
                                    route: "/Tools/Chaos/$/Stop",
                                    validator: validate_StopChaos_595552,
                                    base: "", url: url_StopChaos_595553,
                                    schemes: {Scheme.Https, Scheme.Http})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
