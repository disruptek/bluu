
import
  json, options, hashes, uri, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: Service Fabric Client APIs
## version: 6.0.0.1
## termsOfService: (not provided)
## license: (not provided)
## 
## Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
## 
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_563565 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_563565](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_563565): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  macServiceName = "servicefabric"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_CancelRepairTask_563787 = ref object of OpenApiRestCall_563565
proc url_CancelRepairTask_563789(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelRepairTask_563788(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_563963 = query.getOrDefault("api-version")
  valid_563963 = validateParameter(valid_563963, JString, required = true,
                                 default = newJString("6.0"))
  if valid_563963 != nil:
    section.add "api-version", valid_563963
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_563987: Call_CancelRepairTask_563787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_563987.validator(path, query, header, formData, body)
  let scheme = call_563987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_563987.url(scheme.get, call_563987.host, call_563987.base,
                         call_563987.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_563987, url, valid)

proc call*(call_564058: Call_CancelRepairTask_563787;
          RepairTaskCancelDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## cancelRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskCancelDescription: JObject (required)
  ##                              : Describes the repair task to be cancelled.
  var query_564059 = newJObject()
  var body_564061 = newJObject()
  add(query_564059, "api-version", newJString(apiVersion))
  if RepairTaskCancelDescription != nil:
    body_564061 = RepairTaskCancelDescription
  result = call_564058.call(nil, query_564059, nil, nil, body_564061)

var cancelRepairTask* = Call_CancelRepairTask_563787(name: "cancelRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CancelRepairTask", validator: validate_CancelRepairTask_563788,
    base: "", url: url_CancelRepairTask_563789, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateRepairTask_564100 = ref object of OpenApiRestCall_563565
proc url_CreateRepairTask_564102(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateRepairTask_564101(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564103 = query.getOrDefault("api-version")
  valid_564103 = validateParameter(valid_564103, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564103 != nil:
    section.add "api-version", valid_564103
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564105: Call_CreateRepairTask_564100; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564105.validator(path, query, header, formData, body)
  let scheme = call_564105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564105.url(scheme.get, call_564105.host, call_564105.base,
                         call_564105.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564105, url, valid)

proc call*(call_564106: Call_CreateRepairTask_564100; RepairTask: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## createRepairTask
  ## For clusters that have the Repair Manager Service configured,
  ## this API provides a way to create repair tasks that run automatically or manually.
  ## For repair tasks that run automatically, an appropriate repair executor
  ## must be running for each repair action to run automatically.
  ## These are currently only available in specially-configured Azure Cloud Services.
  ## 
  ## To create a manual repair task, provide the set of impacted node names and the
  ## expected impact. When the state of the created repair task changes to approved,
  ## you can safely perform repair actions on those nodes.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  var query_564107 = newJObject()
  var body_564108 = newJObject()
  add(query_564107, "api-version", newJString(apiVersion))
  if RepairTask != nil:
    body_564108 = RepairTask
  result = call_564106.call(nil, query_564107, nil, nil, body_564108)

var createRepairTask* = Call_CreateRepairTask_564100(name: "createRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/CreateRepairTask", validator: validate_CreateRepairTask_564101,
    base: "", url: url_CreateRepairTask_564102, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteRepairTask_564109 = ref object of OpenApiRestCall_563565
proc url_DeleteRepairTask_564111(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_DeleteRepairTask_564110(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564112 = query.getOrDefault("api-version")
  valid_564112 = validateParameter(valid_564112, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564112 != nil:
    section.add "api-version", valid_564112
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564114: Call_DeleteRepairTask_564109; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564114.validator(path, query, header, formData, body)
  let scheme = call_564114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564114.url(scheme.get, call_564114.host, call_564114.base,
                         call_564114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564114, url, valid)

proc call*(call_564115: Call_DeleteRepairTask_564109;
          RepairTaskDeleteDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## deleteRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskDeleteDescription: JObject (required)
  ##                              : Describes the repair task to be deleted.
  var query_564116 = newJObject()
  var body_564117 = newJObject()
  add(query_564116, "api-version", newJString(apiVersion))
  if RepairTaskDeleteDescription != nil:
    body_564117 = RepairTaskDeleteDescription
  result = call_564115.call(nil, query_564116, nil, nil, body_564117)

var deleteRepairTask* = Call_DeleteRepairTask_564109(name: "deleteRepairTask",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/DeleteRepairTask", validator: validate_DeleteRepairTask_564110,
    base: "", url: url_DeleteRepairTask_564111, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ForceApproveRepairTask_564118 = ref object of OpenApiRestCall_563565
proc url_ForceApproveRepairTask_564120(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ForceApproveRepairTask_564119(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564121 = query.getOrDefault("api-version")
  valid_564121 = validateParameter(valid_564121, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564121 != nil:
    section.add "api-version", valid_564121
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564123: Call_ForceApproveRepairTask_564118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564123.validator(path, query, header, formData, body)
  let scheme = call_564123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564123.url(scheme.get, call_564123.host, call_564123.base,
                         call_564123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564123, url, valid)

proc call*(call_564124: Call_ForceApproveRepairTask_564118;
          RepairTaskApproveDescription: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## forceApproveRepairTask
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskApproveDescription: JObject (required)
  ##                               : Describes the repair task to be approved.
  var query_564125 = newJObject()
  var body_564126 = newJObject()
  add(query_564125, "api-version", newJString(apiVersion))
  if RepairTaskApproveDescription != nil:
    body_564126 = RepairTaskApproveDescription
  result = call_564124.call(nil, query_564125, nil, nil, body_564126)

var forceApproveRepairTask* = Call_ForceApproveRepairTask_564118(
    name: "forceApproveRepairTask", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ForceApproveRepairTask",
    validator: validate_ForceApproveRepairTask_564119, base: "",
    url: url_ForceApproveRepairTask_564120, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAadMetadata_564127 = ref object of OpenApiRestCall_563565
proc url_GetAadMetadata_564129(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAadMetadata_564128(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564130 = query.getOrDefault("api-version")
  valid_564130 = validateParameter(valid_564130, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564130 != nil:
    section.add "api-version", valid_564130
  var valid_564132 = query.getOrDefault("timeout")
  valid_564132 = validateParameter(valid_564132, JInt, required = false,
                                 default = newJInt(60))
  if valid_564132 != nil:
    section.add "timeout", valid_564132
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564133: Call_GetAadMetadata_564127; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ## 
  let valid = call_564133.validator(path, query, header, formData, body)
  let scheme = call_564133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564133.url(scheme.get, call_564133.host, call_564133.base,
                         call_564133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564133, url, valid)

proc call*(call_564134: Call_GetAadMetadata_564127; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getAadMetadata
  ## Gets the Azure Active Directory metadata used for secured connection to cluster.
  ## This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory secured connection with a Service Fabric cluster.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564135 = newJObject()
  add(query_564135, "api-version", newJString(apiVersion))
  add(query_564135, "timeout", newJInt(timeout))
  result = call_564134.call(nil, query_564135, nil, nil, nil)

var getAadMetadata* = Call_GetAadMetadata_564127(name: "getAadMetadata",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/$/GetAadMetadata",
    validator: validate_GetAadMetadata_564128, base: "", url: url_GetAadMetadata_564129,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfiguration_564136 = ref object of OpenApiRestCall_563565
proc url_GetClusterConfiguration_564138(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfiguration_564137(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ConfigurationApiVersion: JString (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ConfigurationApiVersion` field"
  var valid_564139 = query.getOrDefault("ConfigurationApiVersion")
  valid_564139 = validateParameter(valid_564139, JString, required = true,
                                 default = nil)
  if valid_564139 != nil:
    section.add "ConfigurationApiVersion", valid_564139
  var valid_564140 = query.getOrDefault("api-version")
  valid_564140 = validateParameter(valid_564140, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564140 != nil:
    section.add "api-version", valid_564140
  var valid_564141 = query.getOrDefault("timeout")
  valid_564141 = validateParameter(valid_564141, JInt, required = false,
                                 default = newJInt(60))
  if valid_564141 != nil:
    section.add "timeout", valid_564141
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564142: Call_GetClusterConfiguration_564136; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## 
  let valid = call_564142.validator(path, query, header, formData, body)
  let scheme = call_564142.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564142.url(scheme.get, call_564142.host, call_564142.base,
                         call_564142.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564142, url, valid)

proc call*(call_564143: Call_GetClusterConfiguration_564136;
          ConfigurationApiVersion: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getClusterConfiguration
  ## Get the Service Fabric standalone cluster configuration. The cluster configuration contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ##   ConfigurationApiVersion: string (required)
  ##                          : The API version of the Standalone cluster json configuration.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564144 = newJObject()
  add(query_564144, "ConfigurationApiVersion", newJString(ConfigurationApiVersion))
  add(query_564144, "api-version", newJString(apiVersion))
  add(query_564144, "timeout", newJInt(timeout))
  result = call_564143.call(nil, query_564144, nil, nil, nil)

var getClusterConfiguration* = Call_GetClusterConfiguration_564136(
    name: "getClusterConfiguration", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfiguration",
    validator: validate_GetClusterConfiguration_564137, base: "",
    url: url_GetClusterConfiguration_564138, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterConfigurationUpgradeStatus_564145 = ref object of OpenApiRestCall_563565
proc url_GetClusterConfigurationUpgradeStatus_564147(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterConfigurationUpgradeStatus_564146(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564148 = query.getOrDefault("api-version")
  valid_564148 = validateParameter(valid_564148, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564148 != nil:
    section.add "api-version", valid_564148
  var valid_564149 = query.getOrDefault("timeout")
  valid_564149 = validateParameter(valid_564149, JInt, required = false,
                                 default = newJInt(60))
  if valid_564149 != nil:
    section.add "timeout", valid_564149
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564150: Call_GetClusterConfigurationUpgradeStatus_564145;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ## 
  let valid = call_564150.validator(path, query, header, formData, body)
  let scheme = call_564150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564150.url(scheme.get, call_564150.host, call_564150.base,
                         call_564150.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564150, url, valid)

proc call*(call_564151: Call_GetClusterConfigurationUpgradeStatus_564145;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getClusterConfigurationUpgradeStatus
  ## Get the cluster configuration upgrade status of a Service Fabric standalone cluster.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564152 = newJObject()
  add(query_564152, "api-version", newJString(apiVersion))
  add(query_564152, "timeout", newJInt(timeout))
  result = call_564151.call(nil, query_564152, nil, nil, nil)

var getClusterConfigurationUpgradeStatus* = Call_GetClusterConfigurationUpgradeStatus_564145(
    name: "getClusterConfigurationUpgradeStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterConfigurationUpgradeStatus",
    validator: validate_GetClusterConfigurationUpgradeStatus_564146, base: "",
    url: url_GetClusterConfigurationUpgradeStatus_564147,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthUsingPolicy_564166 = ref object of OpenApiRestCall_563565
proc url_GetClusterHealthUsingPolicy_564168(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthUsingPolicy_564167(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_564186 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_564186 = validateParameter(valid_564186, JBool, required = false,
                                 default = newJBool(false))
  if valid_564186 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_564186
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564187 = query.getOrDefault("api-version")
  valid_564187 = validateParameter(valid_564187, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564187 != nil:
    section.add "api-version", valid_564187
  var valid_564188 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_564188 = validateParameter(valid_564188, JInt, required = false,
                                 default = newJInt(0))
  if valid_564188 != nil:
    section.add "ApplicationsHealthStateFilter", valid_564188
  var valid_564189 = query.getOrDefault("ExcludeHealthStatistics")
  valid_564189 = validateParameter(valid_564189, JBool, required = false,
                                 default = newJBool(false))
  if valid_564189 != nil:
    section.add "ExcludeHealthStatistics", valid_564189
  var valid_564190 = query.getOrDefault("timeout")
  valid_564190 = validateParameter(valid_564190, JInt, required = false,
                                 default = newJInt(60))
  if valid_564190 != nil:
    section.add "timeout", valid_564190
  var valid_564191 = query.getOrDefault("EventsHealthStateFilter")
  valid_564191 = validateParameter(valid_564191, JInt, required = false,
                                 default = newJInt(0))
  if valid_564191 != nil:
    section.add "EventsHealthStateFilter", valid_564191
  var valid_564192 = query.getOrDefault("NodesHealthStateFilter")
  valid_564192 = validateParameter(valid_564192, JInt, required = false,
                                 default = newJInt(0))
  if valid_564192 != nil:
    section.add "NodesHealthStateFilter", valid_564192
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564194: Call_GetClusterHealthUsingPolicy_564166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ## 
  let valid = call_564194.validator(path, query, header, formData, body)
  let scheme = call_564194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564194.url(scheme.get, call_564194.host, call_564194.base,
                         call_564194.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564194, url, valid)

proc call*(call_564195: Call_GetClusterHealthUsingPolicy_564166;
          ClusterHealthPolicies: JsonNode = nil;
          IncludeSystemApplicationHealthStatistics: bool = false;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0; NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealthUsingPolicy
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  ##   ClusterHealthPolicies: JObject
  ##                        : Describes the health policies used to evaluate the cluster health.
  ## If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_564196 = newJObject()
  var body_564197 = newJObject()
  if ClusterHealthPolicies != nil:
    body_564197 = ClusterHealthPolicies
  add(query_564196, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  add(query_564196, "api-version", newJString(apiVersion))
  add(query_564196, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_564196, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_564196, "timeout", newJInt(timeout))
  add(query_564196, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_564196, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_564195.call(nil, query_564196, nil, nil, body_564197)

var getClusterHealthUsingPolicy* = Call_GetClusterHealthUsingPolicy_564166(
    name: "getClusterHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/GetClusterHealth",
    validator: validate_GetClusterHealthUsingPolicy_564167, base: "",
    url: url_GetClusterHealthUsingPolicy_564168,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealth_564153 = ref object of OpenApiRestCall_563565
proc url_GetClusterHealth_564155(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealth_564154(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   IncludeSystemApplicationHealthStatistics: JBool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: JInt
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: JInt
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  var valid_564156 = query.getOrDefault("IncludeSystemApplicationHealthStatistics")
  valid_564156 = validateParameter(valid_564156, JBool, required = false,
                                 default = newJBool(false))
  if valid_564156 != nil:
    section.add "IncludeSystemApplicationHealthStatistics", valid_564156
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564157 = query.getOrDefault("api-version")
  valid_564157 = validateParameter(valid_564157, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564157 != nil:
    section.add "api-version", valid_564157
  var valid_564158 = query.getOrDefault("ApplicationsHealthStateFilter")
  valid_564158 = validateParameter(valid_564158, JInt, required = false,
                                 default = newJInt(0))
  if valid_564158 != nil:
    section.add "ApplicationsHealthStateFilter", valid_564158
  var valid_564159 = query.getOrDefault("ExcludeHealthStatistics")
  valid_564159 = validateParameter(valid_564159, JBool, required = false,
                                 default = newJBool(false))
  if valid_564159 != nil:
    section.add "ExcludeHealthStatistics", valid_564159
  var valid_564160 = query.getOrDefault("timeout")
  valid_564160 = validateParameter(valid_564160, JInt, required = false,
                                 default = newJInt(60))
  if valid_564160 != nil:
    section.add "timeout", valid_564160
  var valid_564161 = query.getOrDefault("EventsHealthStateFilter")
  valid_564161 = validateParameter(valid_564161, JInt, required = false,
                                 default = newJInt(0))
  if valid_564161 != nil:
    section.add "EventsHealthStateFilter", valid_564161
  var valid_564162 = query.getOrDefault("NodesHealthStateFilter")
  valid_564162 = validateParameter(valid_564162, JInt, required = false,
                                 default = newJInt(0))
  if valid_564162 != nil:
    section.add "NodesHealthStateFilter", valid_564162
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564163: Call_GetClusterHealth_564153; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ## 
  let valid = call_564163.validator(path, query, header, formData, body)
  let scheme = call_564163.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564163.url(scheme.get, call_564163.host, call_564163.base,
                         call_564163.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564163, url, valid)

proc call*(call_564164: Call_GetClusterHealth_564153;
          IncludeSystemApplicationHealthStatistics: bool = false;
          apiVersion: string = "6.0"; ApplicationsHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0; NodesHealthStateFilter: int = 0): Recallable =
  ## getClusterHealth
  ## Gets the health of a Service Fabric cluster.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and applications returned based on their aggregated health state.
  ## 
  ##   IncludeSystemApplicationHealthStatistics: bool
  ##                                           : Indicates whether the health statistics should include the fabric:/System application health statistics. False by default.
  ## If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that belong to the fabric:/System application.
  ## Otherwise, the query result includes health statistics only for user applications.
  ## The health statistics must be included in the query result for this parameter to be applied.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationsHealthStateFilter: int
  ##                                : Allows filtering of the application health state objects returned in the result of cluster health
  ## query based on their health state.
  ## The possible values for this parameter include integer value obtained from members or bitwise operations
  ## on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
  ## All applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   NodesHealthStateFilter: int
  ##                         : Allows filtering of the node health state objects returned in the result of cluster health query
  ## based on their health state. The possible values for this parameter include integer value of one of the
  ## following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these values obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var query_564165 = newJObject()
  add(query_564165, "IncludeSystemApplicationHealthStatistics",
      newJBool(IncludeSystemApplicationHealthStatistics))
  add(query_564165, "api-version", newJString(apiVersion))
  add(query_564165, "ApplicationsHealthStateFilter",
      newJInt(ApplicationsHealthStateFilter))
  add(query_564165, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_564165, "timeout", newJInt(timeout))
  add(query_564165, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_564165, "NodesHealthStateFilter", newJInt(NodesHealthStateFilter))
  result = call_564164.call(nil, query_564165, nil, nil, nil)

var getClusterHealth* = Call_GetClusterHealth_564153(name: "getClusterHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterHealth", validator: validate_GetClusterHealth_564154,
    base: "", url: url_GetClusterHealth_564155, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564206 = ref object of OpenApiRestCall_563565
proc url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564208(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564207(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564209 = query.getOrDefault("api-version")
  valid_564209 = validateParameter(valid_564209, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564209 != nil:
    section.add "api-version", valid_564209
  var valid_564210 = query.getOrDefault("timeout")
  valid_564210 = validateParameter(valid_564210, JInt, required = false,
                                 default = newJInt(60))
  if valid_564210 != nil:
    section.add "timeout", valid_564210
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564212: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564206;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ## 
  let valid = call_564212.validator(path, query, header, formData, body)
  let scheme = call_564212.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564212.url(scheme.get, call_564212.host, call_564212.base,
                         call_564212.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564212, url, valid)

proc call*(call_564213: Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564206;
          apiVersion: string = "6.0";
          ClusterHealthChunkQueryDescription: JsonNode = nil; timeout: int = 60): Recallable =
  ## getClusterHealthChunkUsingPolicyAndAdvancedFilters
  ## Gets the health of a Service Fabric cluster using health chunks. The health evaluation is done based on the input cluster health chunk query description.
  ## The query description allows users to specify health policies for evaluating the cluster and its children.
  ## Users can specify very flexible filters to select which cluster entities to return. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterHealthChunkQueryDescription: JObject
  ##                                     : Describes the cluster and application health policies used to evaluate the cluster health and the filters to select which cluster entities to be returned.
  ## If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the default cluster health policy.
  ## By default, each application is evaluated using its specific application health policy, defined in the application manifest, or the default health policy, if no policy is defined in manifest.
  ## If the application health policy map is specified, and it has an entry for an application, the specified application health policy
  ## is used to evaluate the application health.
  ## Users can specify very flexible filters to select which cluster entities to include in response. The selection can be done based on the entities health state and based on the hierarchy.
  ## The query can return multi-level children of the entities based on the specified filters. For example, it can return one application with a specified name, and for this application, return
  ## only services that are in Error or Warning, and all partitions and replicas for one of these services.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564214 = newJObject()
  var body_564215 = newJObject()
  add(query_564214, "api-version", newJString(apiVersion))
  if ClusterHealthChunkQueryDescription != nil:
    body_564215 = ClusterHealthChunkQueryDescription
  add(query_564214, "timeout", newJInt(timeout))
  result = call_564213.call(nil, query_564214, nil, nil, body_564215)

var getClusterHealthChunkUsingPolicyAndAdvancedFilters* = Call_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564206(
    name: "getClusterHealthChunkUsingPolicyAndAdvancedFilters",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564207,
    base: "", url: url_GetClusterHealthChunkUsingPolicyAndAdvancedFilters_564208,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterHealthChunk_564198 = ref object of OpenApiRestCall_563565
proc url_GetClusterHealthChunk_564200(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterHealthChunk_564199(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564201 = query.getOrDefault("api-version")
  valid_564201 = validateParameter(valid_564201, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564201 != nil:
    section.add "api-version", valid_564201
  var valid_564202 = query.getOrDefault("timeout")
  valid_564202 = validateParameter(valid_564202, JInt, required = false,
                                 default = newJInt(60))
  if valid_564202 != nil:
    section.add "timeout", valid_564202
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564203: Call_GetClusterHealthChunk_564198; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ## 
  let valid = call_564203.validator(path, query, header, formData, body)
  let scheme = call_564203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564203.url(scheme.get, call_564203.host, call_564203.base,
                         call_564203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564203, url, valid)

proc call*(call_564204: Call_GetClusterHealthChunk_564198;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getClusterHealthChunk
  ## Gets the health of a Service Fabric cluster using health chunks. Includes the aggregated health state of the cluster, but none of the cluster entities.
  ## To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify the cluster health chunk query description.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564205 = newJObject()
  add(query_564205, "api-version", newJString(apiVersion))
  add(query_564205, "timeout", newJInt(timeout))
  result = call_564204.call(nil, query_564205, nil, nil, nil)

var getClusterHealthChunk* = Call_GetClusterHealthChunk_564198(
    name: "getClusterHealthChunk", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetClusterHealthChunk",
    validator: validate_GetClusterHealthChunk_564199, base: "",
    url: url_GetClusterHealthChunk_564200, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterManifest_564216 = ref object of OpenApiRestCall_563565
proc url_GetClusterManifest_564218(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterManifest_564217(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564219 = query.getOrDefault("api-version")
  valid_564219 = validateParameter(valid_564219, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564219 != nil:
    section.add "api-version", valid_564219
  var valid_564220 = query.getOrDefault("timeout")
  valid_564220 = validateParameter(valid_564220, JInt, required = false,
                                 default = newJInt(60))
  if valid_564220 != nil:
    section.add "timeout", valid_564220
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564221: Call_GetClusterManifest_564216; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ## 
  let valid = call_564221.validator(path, query, header, formData, body)
  let scheme = call_564221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564221.url(scheme.get, call_564221.host, call_564221.base,
                         call_564221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564221, url, valid)

proc call*(call_564222: Call_GetClusterManifest_564216; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getClusterManifest
  ## Get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster that include different node types on the cluster,
  ## security configurations, fault and upgrade domain topologies etc.
  ## 
  ## These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster. However, most of the information in the cluster manifest
  ## is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when using azuer portal).
  ## 
  ## The contents of the cluster manifest are for informational purposes only and users are not expected to take a dependency on the format of the file contents or its interpretation.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564223 = newJObject()
  add(query_564223, "api-version", newJString(apiVersion))
  add(query_564223, "timeout", newJInt(timeout))
  result = call_564222.call(nil, query_564223, nil, nil, nil)

var getClusterManifest* = Call_GetClusterManifest_564216(
    name: "getClusterManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetClusterManifest", validator: validate_GetClusterManifest_564217,
    base: "", url: url_GetClusterManifest_564218,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricCodeVersionInfoList_564224 = ref object of OpenApiRestCall_563565
proc url_GetProvisionedFabricCodeVersionInfoList_564226(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricCodeVersionInfoList_564225(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: JString
  ##              : The product version of Service Fabric.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564227 = query.getOrDefault("api-version")
  valid_564227 = validateParameter(valid_564227, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564227 != nil:
    section.add "api-version", valid_564227
  var valid_564228 = query.getOrDefault("timeout")
  valid_564228 = validateParameter(valid_564228, JInt, required = false,
                                 default = newJInt(60))
  if valid_564228 != nil:
    section.add "timeout", valid_564228
  var valid_564229 = query.getOrDefault("CodeVersion")
  valid_564229 = validateParameter(valid_564229, JString, required = false,
                                 default = nil)
  if valid_564229 != nil:
    section.add "CodeVersion", valid_564229
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564230: Call_GetProvisionedFabricCodeVersionInfoList_564224;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_564230.validator(path, query, header, formData, body)
  let scheme = call_564230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564230.url(scheme.get, call_564230.host, call_564230.base,
                         call_564230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564230, url, valid)

proc call*(call_564231: Call_GetProvisionedFabricCodeVersionInfoList_564224;
          apiVersion: string = "6.0"; timeout: int = 60; CodeVersion: string = ""): Recallable =
  ## getProvisionedFabricCodeVersionInfoList
  ## Gets a list of information about fabric code versions that are provisioned in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular version.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodeVersion: string
  ##              : The product version of Service Fabric.
  var query_564232 = newJObject()
  add(query_564232, "api-version", newJString(apiVersion))
  add(query_564232, "timeout", newJInt(timeout))
  add(query_564232, "CodeVersion", newJString(CodeVersion))
  result = call_564231.call(nil, query_564232, nil, nil, nil)

var getProvisionedFabricCodeVersionInfoList* = Call_GetProvisionedFabricCodeVersionInfoList_564224(
    name: "getProvisionedFabricCodeVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedCodeVersions",
    validator: validate_GetProvisionedFabricCodeVersionInfoList_564225, base: "",
    url: url_GetProvisionedFabricCodeVersionInfoList_564226,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetProvisionedFabricConfigVersionInfoList_564233 = ref object of OpenApiRestCall_563565
proc url_GetProvisionedFabricConfigVersionInfoList_564235(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetProvisionedFabricConfigVersionInfoList_564234(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: JString
  ##                : The config version of Service Fabric.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564236 = query.getOrDefault("api-version")
  valid_564236 = validateParameter(valid_564236, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564236 != nil:
    section.add "api-version", valid_564236
  var valid_564237 = query.getOrDefault("ConfigVersion")
  valid_564237 = validateParameter(valid_564237, JString, required = false,
                                 default = nil)
  if valid_564237 != nil:
    section.add "ConfigVersion", valid_564237
  var valid_564238 = query.getOrDefault("timeout")
  valid_564238 = validateParameter(valid_564238, JInt, required = false,
                                 default = newJInt(60))
  if valid_564238 != nil:
    section.add "timeout", valid_564238
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564239: Call_GetProvisionedFabricConfigVersionInfoList_564233;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ## 
  let valid = call_564239.validator(path, query, header, formData, body)
  let scheme = call_564239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564239.url(scheme.get, call_564239.host, call_564239.base,
                         call_564239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564239, url, valid)

proc call*(call_564240: Call_GetProvisionedFabricConfigVersionInfoList_564233;
          apiVersion: string = "6.0"; ConfigVersion: string = ""; timeout: int = 60): Recallable =
  ## getProvisionedFabricConfigVersionInfoList
  ## Gets a list of information about fabric config versions that are provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that particular version.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ConfigVersion: string
  ##                : The config version of Service Fabric.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564241 = newJObject()
  add(query_564241, "api-version", newJString(apiVersion))
  add(query_564241, "ConfigVersion", newJString(ConfigVersion))
  add(query_564241, "timeout", newJInt(timeout))
  result = call_564240.call(nil, query_564241, nil, nil, nil)

var getProvisionedFabricConfigVersionInfoList* = Call_GetProvisionedFabricConfigVersionInfoList_564233(
    name: "getProvisionedFabricConfigVersionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetProvisionedConfigVersions",
    validator: validate_GetProvisionedFabricConfigVersionInfoList_564234,
    base: "", url: url_GetProvisionedFabricConfigVersionInfoList_564235,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRepairTaskList_564242 = ref object of OpenApiRestCall_563565
proc url_GetRepairTaskList_564244(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRepairTaskList_564243(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ExecutorFilter: JString
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StateFilter: JInt
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  ##   TaskIdFilter: JString
  ##               : The repair task ID prefix to be matched.
  section = newJObject()
  var valid_564245 = query.getOrDefault("ExecutorFilter")
  valid_564245 = validateParameter(valid_564245, JString, required = false,
                                 default = nil)
  if valid_564245 != nil:
    section.add "ExecutorFilter", valid_564245
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564246 = query.getOrDefault("api-version")
  valid_564246 = validateParameter(valid_564246, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564246 != nil:
    section.add "api-version", valid_564246
  var valid_564247 = query.getOrDefault("StateFilter")
  valid_564247 = validateParameter(valid_564247, JInt, required = false, default = nil)
  if valid_564247 != nil:
    section.add "StateFilter", valid_564247
  var valid_564248 = query.getOrDefault("TaskIdFilter")
  valid_564248 = validateParameter(valid_564248, JString, required = false,
                                 default = nil)
  if valid_564248 != nil:
    section.add "TaskIdFilter", valid_564248
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564249: Call_GetRepairTaskList_564242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564249.validator(path, query, header, formData, body)
  let scheme = call_564249.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564249.url(scheme.get, call_564249.host, call_564249.base,
                         call_564249.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564249, url, valid)

proc call*(call_564250: Call_GetRepairTaskList_564242; ExecutorFilter: string = "";
          apiVersion: string = "6.0"; StateFilter: int = 0; TaskIdFilter: string = ""): Recallable =
  ## getRepairTaskList
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   ExecutorFilter: string
  ##                 : The name of the repair executor whose claimed tasks should be included in the list.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StateFilter: int
  ##              : A bitwise-OR of the following values, specifying which task states should be included in the result list.
  ## - 1 - Created
  ## - 2 - Claimed
  ## - 4 - Preparing
  ## - 8 - Approved
  ## - 16 - Executing
  ## - 32 - Restoring
  ## - 64 - Completed
  ## 
  ##   TaskIdFilter: string
  ##               : The repair task ID prefix to be matched.
  var query_564251 = newJObject()
  add(query_564251, "ExecutorFilter", newJString(ExecutorFilter))
  add(query_564251, "api-version", newJString(apiVersion))
  add(query_564251, "StateFilter", newJInt(StateFilter))
  add(query_564251, "TaskIdFilter", newJString(TaskIdFilter))
  result = call_564250.call(nil, query_564251, nil, nil, nil)

var getRepairTaskList* = Call_GetRepairTaskList_564242(name: "getRepairTaskList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/$/GetRepairTaskList", validator: validate_GetRepairTaskList_564243,
    base: "", url: url_GetRepairTaskList_564244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetClusterUpgradeProgress_564252 = ref object of OpenApiRestCall_563565
proc url_GetClusterUpgradeProgress_564254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetClusterUpgradeProgress_564253(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564255 = query.getOrDefault("api-version")
  valid_564255 = validateParameter(valid_564255, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564255 != nil:
    section.add "api-version", valid_564255
  var valid_564256 = query.getOrDefault("timeout")
  valid_564256 = validateParameter(valid_564256, JInt, required = false,
                                 default = newJInt(60))
  if valid_564256 != nil:
    section.add "timeout", valid_564256
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564257: Call_GetClusterUpgradeProgress_564252; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ## 
  let valid = call_564257.validator(path, query, header, formData, body)
  let scheme = call_564257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564257.url(scheme.get, call_564257.host, call_564257.base,
                         call_564257.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564257, url, valid)

proc call*(call_564258: Call_GetClusterUpgradeProgress_564252;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getClusterUpgradeProgress
  ## Gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in progress, gets the last state of the previous cluster upgrade.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564259 = newJObject()
  add(query_564259, "api-version", newJString(apiVersion))
  add(query_564259, "timeout", newJInt(timeout))
  result = call_564258.call(nil, query_564259, nil, nil, nil)

var getClusterUpgradeProgress* = Call_GetClusterUpgradeProgress_564252(
    name: "getClusterUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/GetUpgradeProgress",
    validator: validate_GetClusterUpgradeProgress_564253, base: "",
    url: url_GetClusterUpgradeProgress_564254,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureCommand_564260 = ref object of OpenApiRestCall_563565
proc url_InvokeInfrastructureCommand_564262(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureCommand_564261(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564263 = query.getOrDefault("api-version")
  valid_564263 = validateParameter(valid_564263, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564263 != nil:
    section.add "api-version", valid_564263
  var valid_564264 = query.getOrDefault("timeout")
  valid_564264 = validateParameter(valid_564264, JInt, required = false,
                                 default = newJInt(60))
  if valid_564264 != nil:
    section.add "timeout", valid_564264
  var valid_564265 = query.getOrDefault("ServiceId")
  valid_564265 = validateParameter(valid_564265, JString, required = false,
                                 default = nil)
  if valid_564265 != nil:
    section.add "ServiceId", valid_564265
  var valid_564266 = query.getOrDefault("Command")
  valid_564266 = validateParameter(valid_564266, JString, required = true,
                                 default = nil)
  if valid_564266 != nil:
    section.add "Command", valid_564266
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564267: Call_InvokeInfrastructureCommand_564260; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564267.validator(path, query, header, formData, body)
  let scheme = call_564267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564267.url(scheme.get, call_564267.host, call_564267.base,
                         call_564267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564267, url, valid)

proc call*(call_564268: Call_InvokeInfrastructureCommand_564260; Command: string;
          apiVersion: string = "6.0"; timeout: int = 60; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureCommand
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific commands to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_564269 = newJObject()
  add(query_564269, "api-version", newJString(apiVersion))
  add(query_564269, "timeout", newJInt(timeout))
  add(query_564269, "ServiceId", newJString(ServiceId))
  add(query_564269, "Command", newJString(Command))
  result = call_564268.call(nil, query_564269, nil, nil, nil)

var invokeInfrastructureCommand* = Call_InvokeInfrastructureCommand_564260(
    name: "invokeInfrastructureCommand", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureCommand",
    validator: validate_InvokeInfrastructureCommand_564261, base: "",
    url: url_InvokeInfrastructureCommand_564262,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_InvokeInfrastructureQuery_564270 = ref object of OpenApiRestCall_563565
proc url_InvokeInfrastructureQuery_564272(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_InvokeInfrastructureQuery_564271(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceId: JString
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: JString (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564273 = query.getOrDefault("api-version")
  valid_564273 = validateParameter(valid_564273, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564273 != nil:
    section.add "api-version", valid_564273
  var valid_564274 = query.getOrDefault("timeout")
  valid_564274 = validateParameter(valid_564274, JInt, required = false,
                                 default = newJInt(60))
  if valid_564274 != nil:
    section.add "timeout", valid_564274
  var valid_564275 = query.getOrDefault("ServiceId")
  valid_564275 = validateParameter(valid_564275, JString, required = false,
                                 default = nil)
  if valid_564275 != nil:
    section.add "ServiceId", valid_564275
  var valid_564276 = query.getOrDefault("Command")
  valid_564276 = validateParameter(valid_564276, JString, required = true,
                                 default = nil)
  if valid_564276 != nil:
    section.add "Command", valid_564276
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564277: Call_InvokeInfrastructureQuery_564270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564277.validator(path, query, header, formData, body)
  let scheme = call_564277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564277.url(scheme.get, call_564277.host, call_564277.base,
                         call_564277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564277, url, valid)

proc call*(call_564278: Call_InvokeInfrastructureQuery_564270; Command: string;
          apiVersion: string = "6.0"; timeout: int = 60; ServiceId: string = ""): Recallable =
  ## invokeInfrastructureQuery
  ## For clusters that have one or more instances of the Infrastructure Service configured,
  ## this API provides a way to send infrastructure-specific queries to a particular
  ## instance of the Infrastructure Service.
  ## 
  ## Available commands and their corresponding response formats vary depending upon
  ## the infrastructure on which the cluster is running.
  ## 
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceId: string
  ##            : The identity of the infrastructure service. This is  the full name of the infrastructure service without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one instance of infrastructure service running.
  ##   Command: string (required)
  ##          : The text of the command to be invoked. The content of the command is infrastructure-specific.
  var query_564279 = newJObject()
  add(query_564279, "api-version", newJString(apiVersion))
  add(query_564279, "timeout", newJInt(timeout))
  add(query_564279, "ServiceId", newJString(ServiceId))
  add(query_564279, "Command", newJString(Command))
  result = call_564278.call(nil, query_564279, nil, nil, nil)

var invokeInfrastructureQuery* = Call_InvokeInfrastructureQuery_564270(
    name: "invokeInfrastructureQuery", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/$/InvokeInfrastructureQuery",
    validator: validate_InvokeInfrastructureQuery_564271, base: "",
    url: url_InvokeInfrastructureQuery_564272,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeClusterUpgrade_564280 = ref object of OpenApiRestCall_563565
proc url_ResumeClusterUpgrade_564282(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ResumeClusterUpgrade_564281(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564283 = query.getOrDefault("api-version")
  valid_564283 = validateParameter(valid_564283, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564283 != nil:
    section.add "api-version", valid_564283
  var valid_564284 = query.getOrDefault("timeout")
  valid_564284 = validateParameter(valid_564284, JInt, required = false,
                                 default = newJInt(60))
  if valid_564284 != nil:
    section.add "timeout", valid_564284
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564286: Call_ResumeClusterUpgrade_564280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Make the cluster upgrade move on to the next upgrade domain.
  ## 
  let valid = call_564286.validator(path, query, header, formData, body)
  let scheme = call_564286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564286.url(scheme.get, call_564286.host, call_564286.base,
                         call_564286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564286, url, valid)

proc call*(call_564287: Call_ResumeClusterUpgrade_564280;
          ResumeClusterUpgradeDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## resumeClusterUpgrade
  ## Make the cluster upgrade move on to the next upgrade domain.
  ##   ResumeClusterUpgradeDescription: JObject (required)
  ##                                  : Describes the parameters for resuming a cluster upgrade.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564288 = newJObject()
  var body_564289 = newJObject()
  if ResumeClusterUpgradeDescription != nil:
    body_564289 = ResumeClusterUpgradeDescription
  add(query_564288, "api-version", newJString(apiVersion))
  add(query_564288, "timeout", newJInt(timeout))
  result = call_564287.call(nil, query_564288, nil, nil, body_564289)

var resumeClusterUpgrade* = Call_ResumeClusterUpgrade_564280(
    name: "resumeClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeClusterUpgrade_564281, base: "",
    url: url_ResumeClusterUpgrade_564282, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionCluster_564290 = ref object of OpenApiRestCall_563565
proc url_ProvisionCluster_564292(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionCluster_564291(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564293 = query.getOrDefault("api-version")
  valid_564293 = validateParameter(valid_564293, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564293 != nil:
    section.add "api-version", valid_564293
  var valid_564294 = query.getOrDefault("timeout")
  valid_564294 = validateParameter(valid_564294, JInt, required = false,
                                 default = newJInt(60))
  if valid_564294 != nil:
    section.add "timeout", valid_564294
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564296: Call_ProvisionCluster_564290; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_564296.validator(path, query, header, formData, body)
  let scheme = call_564296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564296.url(scheme.get, call_564296.host, call_564296.base,
                         call_564296.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564296, url, valid)

proc call*(call_564297: Call_ProvisionCluster_564290;
          ProvisionFabricDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## provisionCluster
  ## Validate and provision the code or configuration packages of a Service Fabric cluster.
  ##   ProvisionFabricDescription: JObject (required)
  ##                             : Describes the parameters for provisioning a cluster.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564298 = newJObject()
  var body_564299 = newJObject()
  if ProvisionFabricDescription != nil:
    body_564299 = ProvisionFabricDescription
  add(query_564298, "api-version", newJString(apiVersion))
  add(query_564298, "timeout", newJInt(timeout))
  result = call_564297.call(nil, query_564298, nil, nil, body_564299)

var provisionCluster* = Call_ProvisionCluster_564290(name: "provisionCluster",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/$/Provision",
    validator: validate_ProvisionCluster_564291, base: "",
    url: url_ProvisionCluster_564292, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverAllPartitions_564300 = ref object of OpenApiRestCall_563565
proc url_RecoverAllPartitions_564302(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverAllPartitions_564301(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564303 = query.getOrDefault("api-version")
  valid_564303 = validateParameter(valid_564303, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564303 != nil:
    section.add "api-version", valid_564303
  var valid_564304 = query.getOrDefault("timeout")
  valid_564304 = validateParameter(valid_564304, JInt, required = false,
                                 default = newJInt(60))
  if valid_564304 != nil:
    section.add "timeout", valid_564304
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564305: Call_RecoverAllPartitions_564300; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_564305.validator(path, query, header, formData, body)
  let scheme = call_564305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564305.url(scheme.get, call_564305.host, call_564305.base,
                         call_564305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564305, url, valid)

proc call*(call_564306: Call_RecoverAllPartitions_564300;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## recoverAllPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover any services (including system services) which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564307 = newJObject()
  add(query_564307, "api-version", newJString(apiVersion))
  add(query_564307, "timeout", newJInt(timeout))
  result = call_564306.call(nil, query_564307, nil, nil, nil)

var recoverAllPartitions* = Call_RecoverAllPartitions_564300(
    name: "recoverAllPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverAllPartitions",
    validator: validate_RecoverAllPartitions_564301, base: "",
    url: url_RecoverAllPartitions_564302, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverSystemPartitions_564308 = ref object of OpenApiRestCall_563565
proc url_RecoverSystemPartitions_564310(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RecoverSystemPartitions_564309(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564311 = query.getOrDefault("api-version")
  valid_564311 = validateParameter(valid_564311, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564311 != nil:
    section.add "api-version", valid_564311
  var valid_564312 = query.getOrDefault("timeout")
  valid_564312 = validateParameter(valid_564312, JInt, required = false,
                                 default = newJInt(60))
  if valid_564312 != nil:
    section.add "timeout", valid_564312
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564313: Call_RecoverSystemPartitions_564308; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_564313.validator(path, query, header, formData, body)
  let scheme = call_564313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564313.url(scheme.get, call_564313.host, call_564313.base,
                         call_564313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564313, url, valid)

proc call*(call_564314: Call_RecoverSystemPartitions_564308;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## recoverSystemPartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the system services which are currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564315 = newJObject()
  add(query_564315, "api-version", newJString(apiVersion))
  add(query_564315, "timeout", newJInt(timeout))
  result = call_564314.call(nil, query_564315, nil, nil, nil)

var recoverSystemPartitions* = Call_RecoverSystemPartitions_564308(
    name: "recoverSystemPartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RecoverSystemPartitions",
    validator: validate_RecoverSystemPartitions_564309, base: "",
    url: url_RecoverSystemPartitions_564310, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportClusterHealth_564316 = ref object of OpenApiRestCall_563565
proc url_ReportClusterHealth_564318(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ReportClusterHealth_564317(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_564319 = query.getOrDefault("Immediate")
  valid_564319 = validateParameter(valid_564319, JBool, required = false,
                                 default = newJBool(false))
  if valid_564319 != nil:
    section.add "Immediate", valid_564319
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564320 = query.getOrDefault("api-version")
  valid_564320 = validateParameter(valid_564320, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564320 != nil:
    section.add "api-version", valid_564320
  var valid_564321 = query.getOrDefault("timeout")
  valid_564321 = validateParameter(valid_564321, JInt, required = false,
                                 default = newJInt(60))
  if valid_564321 != nil:
    section.add "timeout", valid_564321
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564323: Call_ReportClusterHealth_564316; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_564323.validator(path, query, header, formData, body)
  let scheme = call_564323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564323.url(scheme.get, call_564323.host, call_564323.base,
                         call_564323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564323, url, valid)

proc call*(call_564324: Call_ReportClusterHealth_564316;
          HealthInformation: JsonNode; Immediate: bool = false;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## reportClusterHealth
  ## Sends a health report on a Service Fabric cluster. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564325 = newJObject()
  var body_564326 = newJObject()
  add(query_564325, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_564326 = HealthInformation
  add(query_564325, "api-version", newJString(apiVersion))
  add(query_564325, "timeout", newJInt(timeout))
  result = call_564324.call(nil, query_564325, nil, nil, body_564326)

var reportClusterHealth* = Call_ReportClusterHealth_564316(
    name: "reportClusterHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/ReportClusterHealth",
    validator: validate_ReportClusterHealth_564317, base: "",
    url: url_ReportClusterHealth_564318, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackClusterUpgrade_564327 = ref object of OpenApiRestCall_563565
proc url_RollbackClusterUpgrade_564329(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_RollbackClusterUpgrade_564328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564330 = query.getOrDefault("api-version")
  valid_564330 = validateParameter(valid_564330, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564330 != nil:
    section.add "api-version", valid_564330
  var valid_564331 = query.getOrDefault("timeout")
  valid_564331 = validateParameter(valid_564331, JInt, required = false,
                                 default = newJInt(60))
  if valid_564331 != nil:
    section.add "timeout", valid_564331
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564332: Call_RollbackClusterUpgrade_564327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rollback the upgrade of a Service Fabric cluster.
  ## 
  let valid = call_564332.validator(path, query, header, formData, body)
  let scheme = call_564332.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564332.url(scheme.get, call_564332.host, call_564332.base,
                         call_564332.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564332, url, valid)

proc call*(call_564333: Call_RollbackClusterUpgrade_564327;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## rollbackClusterUpgrade
  ## Rollback the upgrade of a Service Fabric cluster.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564334 = newJObject()
  add(query_564334, "api-version", newJString(apiVersion))
  add(query_564334, "timeout", newJInt(timeout))
  result = call_564333.call(nil, query_564334, nil, nil, nil)

var rollbackClusterUpgrade* = Call_RollbackClusterUpgrade_564327(
    name: "rollbackClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/RollbackUpgrade",
    validator: validate_RollbackClusterUpgrade_564328, base: "",
    url: url_RollbackClusterUpgrade_564329, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterConfigurationUpgrade_564335 = ref object of OpenApiRestCall_563565
proc url_StartClusterConfigurationUpgrade_564337(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterConfigurationUpgrade_564336(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564338 = query.getOrDefault("api-version")
  valid_564338 = validateParameter(valid_564338, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564338 != nil:
    section.add "api-version", valid_564338
  var valid_564339 = query.getOrDefault("timeout")
  valid_564339 = validateParameter(valid_564339, JInt, required = false,
                                 default = newJInt(60))
  if valid_564339 != nil:
    section.add "timeout", valid_564339
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564341: Call_StartClusterConfigurationUpgrade_564335;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ## 
  let valid = call_564341.validator(path, query, header, formData, body)
  let scheme = call_564341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564341.url(scheme.get, call_564341.host, call_564341.base,
                         call_564341.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564341, url, valid)

proc call*(call_564342: Call_StartClusterConfigurationUpgrade_564335;
          ClusterConfigurationUpgradeDescription: JsonNode;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## startClusterConfigurationUpgrade
  ## Validate the supplied configuration upgrade parameters and start upgrading the cluster configuration if the parameters are valid.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterConfigurationUpgradeDescription: JObject (required)
  ##                                         : Parameters for a standalone cluster configuration upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564343 = newJObject()
  var body_564344 = newJObject()
  add(query_564343, "api-version", newJString(apiVersion))
  if ClusterConfigurationUpgradeDescription != nil:
    body_564344 = ClusterConfigurationUpgradeDescription
  add(query_564343, "timeout", newJInt(timeout))
  result = call_564342.call(nil, query_564343, nil, nil, body_564344)

var startClusterConfigurationUpgrade* = Call_StartClusterConfigurationUpgrade_564335(
    name: "startClusterConfigurationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/StartClusterConfigurationUpgrade",
    validator: validate_StartClusterConfigurationUpgrade_564336, base: "",
    url: url_StartClusterConfigurationUpgrade_564337,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionCluster_564345 = ref object of OpenApiRestCall_563565
proc url_UnprovisionCluster_564347(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UnprovisionCluster_564346(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564348 = query.getOrDefault("api-version")
  valid_564348 = validateParameter(valid_564348, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564348 != nil:
    section.add "api-version", valid_564348
  var valid_564349 = query.getOrDefault("timeout")
  valid_564349 = validateParameter(valid_564349, JInt, required = false,
                                 default = newJInt(60))
  if valid_564349 != nil:
    section.add "timeout", valid_564349
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564351: Call_UnprovisionCluster_564345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ## 
  let valid = call_564351.validator(path, query, header, formData, body)
  let scheme = call_564351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564351.url(scheme.get, call_564351.host, call_564351.base,
                         call_564351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564351, url, valid)

proc call*(call_564352: Call_UnprovisionCluster_564345;
          UnprovisionFabricDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## unprovisionCluster
  ## Unprovision the code or configuration packages of a Service Fabric cluster.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UnprovisionFabricDescription: JObject (required)
  ##                               : Describes the parameters for unprovisioning a cluster.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564353 = newJObject()
  var body_564354 = newJObject()
  add(query_564353, "api-version", newJString(apiVersion))
  if UnprovisionFabricDescription != nil:
    body_564354 = UnprovisionFabricDescription
  add(query_564353, "timeout", newJInt(timeout))
  result = call_564352.call(nil, query_564353, nil, nil, body_564354)

var unprovisionCluster* = Call_UnprovisionCluster_564345(
    name: "unprovisionCluster", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Unprovision",
    validator: validate_UnprovisionCluster_564346, base: "",
    url: url_UnprovisionCluster_564347, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairExecutionState_564355 = ref object of OpenApiRestCall_563565
proc url_UpdateRepairExecutionState_564357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairExecutionState_564356(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564358 = query.getOrDefault("api-version")
  valid_564358 = validateParameter(valid_564358, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564358 != nil:
    section.add "api-version", valid_564358
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564360: Call_UpdateRepairExecutionState_564355; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564360.validator(path, query, header, formData, body)
  let scheme = call_564360.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564360.url(scheme.get, call_564360.host, call_564360.base,
                         call_564360.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564360, url, valid)

proc call*(call_564361: Call_UpdateRepairExecutionState_564355;
          RepairTask: JsonNode; apiVersion: string = "6.0"): Recallable =
  ## updateRepairExecutionState
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTask: JObject (required)
  ##             : Describes the repair task to be created or updated.
  var query_564362 = newJObject()
  var body_564363 = newJObject()
  add(query_564362, "api-version", newJString(apiVersion))
  if RepairTask != nil:
    body_564363 = RepairTask
  result = call_564361.call(nil, query_564362, nil, nil, body_564363)

var updateRepairExecutionState* = Call_UpdateRepairExecutionState_564355(
    name: "updateRepairExecutionState", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairExecutionState",
    validator: validate_UpdateRepairExecutionState_564356, base: "",
    url: url_UpdateRepairExecutionState_564357,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateRepairTaskHealthPolicy_564364 = ref object of OpenApiRestCall_563565
proc url_UpdateRepairTaskHealthPolicy_564366(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateRepairTaskHealthPolicy_564365(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564367 = query.getOrDefault("api-version")
  valid_564367 = validateParameter(valid_564367, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564367 != nil:
    section.add "api-version", valid_564367
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564369: Call_UpdateRepairTaskHealthPolicy_564364; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ## 
  let valid = call_564369.validator(path, query, header, formData, body)
  let scheme = call_564369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564369.url(scheme.get, call_564369.host, call_564369.base,
                         call_564369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564369, url, valid)

proc call*(call_564370: Call_UpdateRepairTaskHealthPolicy_564364;
          RepairTaskUpdateHealthPolicyDescription: JsonNode;
          apiVersion: string = "6.0"): Recallable =
  ## updateRepairTaskHealthPolicy
  ## This API supports the Service Fabric platform; it is not meant to be used directly from your code.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RepairTaskUpdateHealthPolicyDescription: JObject (required)
  ##                                          : Describes the repair task healthy policy to be updated.
  var query_564371 = newJObject()
  var body_564372 = newJObject()
  add(query_564371, "api-version", newJString(apiVersion))
  if RepairTaskUpdateHealthPolicyDescription != nil:
    body_564372 = RepairTaskUpdateHealthPolicyDescription
  result = call_564370.call(nil, query_564371, nil, nil, body_564372)

var updateRepairTaskHealthPolicy* = Call_UpdateRepairTaskHealthPolicy_564364(
    name: "updateRepairTaskHealthPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateRepairTaskHealthPolicy",
    validator: validate_UpdateRepairTaskHealthPolicy_564365, base: "",
    url: url_UpdateRepairTaskHealthPolicy_564366,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateClusterUpgrade_564373 = ref object of OpenApiRestCall_563565
proc url_UpdateClusterUpgrade_564375(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_UpdateClusterUpgrade_564374(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564376 = query.getOrDefault("api-version")
  valid_564376 = validateParameter(valid_564376, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564376 != nil:
    section.add "api-version", valid_564376
  var valid_564377 = query.getOrDefault("timeout")
  valid_564377 = validateParameter(valid_564377, JInt, required = false,
                                 default = newJInt(60))
  if valid_564377 != nil:
    section.add "timeout", valid_564377
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564379: Call_UpdateClusterUpgrade_564373; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ## 
  let valid = call_564379.validator(path, query, header, formData, body)
  let scheme = call_564379.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564379.url(scheme.get, call_564379.host, call_564379.base,
                         call_564379.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564379, url, valid)

proc call*(call_564380: Call_UpdateClusterUpgrade_564373;
          UpdateClusterUpgradeDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## updateClusterUpgrade
  ## Update the upgrade parameters of a Service Fabric cluster upgrade.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   UpdateClusterUpgradeDescription: JObject (required)
  ##                                  : Parameters for updating a cluster upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564381 = newJObject()
  var body_564382 = newJObject()
  add(query_564381, "api-version", newJString(apiVersion))
  if UpdateClusterUpgradeDescription != nil:
    body_564382 = UpdateClusterUpgradeDescription
  add(query_564381, "timeout", newJInt(timeout))
  result = call_564380.call(nil, query_564381, nil, nil, body_564382)

var updateClusterUpgrade* = Call_UpdateClusterUpgrade_564373(
    name: "updateClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/UpdateUpgrade",
    validator: validate_UpdateClusterUpgrade_564374, base: "",
    url: url_UpdateClusterUpgrade_564375, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartClusterUpgrade_564383 = ref object of OpenApiRestCall_563565
proc url_StartClusterUpgrade_564385(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartClusterUpgrade_564384(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564386 = query.getOrDefault("api-version")
  valid_564386 = validateParameter(valid_564386, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564386 != nil:
    section.add "api-version", valid_564386
  var valid_564387 = query.getOrDefault("timeout")
  valid_564387 = validateParameter(valid_564387, JInt, required = false,
                                 default = newJInt(60))
  if valid_564387 != nil:
    section.add "timeout", valid_564387
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564389: Call_StartClusterUpgrade_564383; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ## 
  let valid = call_564389.validator(path, query, header, formData, body)
  let scheme = call_564389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564389.url(scheme.get, call_564389.host, call_564389.base,
                         call_564389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564389, url, valid)

proc call*(call_564390: Call_StartClusterUpgrade_564383;
          StartClusterUpgradeDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## startClusterUpgrade
  ## Validate the supplied upgrade parameters and start upgrading the code or configuration version of a Service Fabric cluster if the parameters are valid.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   StartClusterUpgradeDescription: JObject (required)
  ##                                 : Describes the parameters for starting a cluster upgrade.
  var query_564391 = newJObject()
  var body_564392 = newJObject()
  add(query_564391, "api-version", newJString(apiVersion))
  add(query_564391, "timeout", newJInt(timeout))
  if StartClusterUpgradeDescription != nil:
    body_564392 = StartClusterUpgradeDescription
  result = call_564390.call(nil, query_564391, nil, nil, body_564392)

var startClusterUpgrade* = Call_StartClusterUpgrade_564383(
    name: "startClusterUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/$/Upgrade",
    validator: validate_StartClusterUpgrade_564384, base: "",
    url: url_StartClusterUpgrade_564385, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoList_564393 = ref object of OpenApiRestCall_563565
proc url_GetApplicationTypeInfoList_564395(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationTypeInfoList_564394(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ApplicationTypeDefinitionKindFilter: JInt
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_564396 = query.getOrDefault("ContinuationToken")
  valid_564396 = validateParameter(valid_564396, JString, required = false,
                                 default = nil)
  if valid_564396 != nil:
    section.add "ContinuationToken", valid_564396
  var valid_564397 = query.getOrDefault("MaxResults")
  valid_564397 = validateParameter(valid_564397, JInt, required = false,
                                 default = newJInt(0))
  if valid_564397 != nil:
    section.add "MaxResults", valid_564397
  var valid_564398 = query.getOrDefault("ApplicationTypeDefinitionKindFilter")
  valid_564398 = validateParameter(valid_564398, JInt, required = false,
                                 default = newJInt(0))
  if valid_564398 != nil:
    section.add "ApplicationTypeDefinitionKindFilter", valid_564398
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564399 = query.getOrDefault("api-version")
  valid_564399 = validateParameter(valid_564399, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564399 != nil:
    section.add "api-version", valid_564399
  var valid_564400 = query.getOrDefault("timeout")
  valid_564400 = validateParameter(valid_564400, JInt, required = false,
                                 default = newJInt(60))
  if valid_564400 != nil:
    section.add "timeout", valid_564400
  var valid_564401 = query.getOrDefault("ExcludeApplicationParameters")
  valid_564401 = validateParameter(valid_564401, JBool, required = false,
                                 default = newJBool(false))
  if valid_564401 != nil:
    section.add "ExcludeApplicationParameters", valid_564401
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564402: Call_GetApplicationTypeInfoList_564393; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_564402.validator(path, query, header, formData, body)
  let scheme = call_564402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564402.url(scheme.get, call_564402.host, call_564402.base,
                         call_564402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564402, url, valid)

proc call*(call_564403: Call_GetApplicationTypeInfoList_564393;
          ContinuationToken: string = ""; MaxResults: int = 0;
          ApplicationTypeDefinitionKindFilter: int = 0; apiVersion: string = "6.0";
          timeout: int = 60; ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoList
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   ApplicationTypeDefinitionKindFilter: int
  ##                                      : Used to filter on ApplicationTypeDefinitionKind for application type query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
  ## - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_564404 = newJObject()
  add(query_564404, "ContinuationToken", newJString(ContinuationToken))
  add(query_564404, "MaxResults", newJInt(MaxResults))
  add(query_564404, "ApplicationTypeDefinitionKindFilter",
      newJInt(ApplicationTypeDefinitionKindFilter))
  add(query_564404, "api-version", newJString(apiVersion))
  add(query_564404, "timeout", newJInt(timeout))
  add(query_564404, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_564403.call(nil, query_564404, nil, nil, nil)

var getApplicationTypeInfoList* = Call_GetApplicationTypeInfoList_564393(
    name: "getApplicationTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes",
    validator: validate_GetApplicationTypeInfoList_564394, base: "",
    url: url_GetApplicationTypeInfoList_564395,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ProvisionApplicationType_564405 = ref object of OpenApiRestCall_563565
proc url_ProvisionApplicationType_564407(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_ProvisionApplicationType_564406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564408 = query.getOrDefault("api-version")
  valid_564408 = validateParameter(valid_564408, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564408 != nil:
    section.add "api-version", valid_564408
  var valid_564409 = query.getOrDefault("timeout")
  valid_564409 = validateParameter(valid_564409, JInt, required = false,
                                 default = newJInt(60))
  if valid_564409 != nil:
    section.add "timeout", valid_564409
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564411: Call_ProvisionApplicationType_564405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ## 
  let valid = call_564411.validator(path, query, header, formData, body)
  let scheme = call_564411.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564411.url(scheme.get, call_564411.host, call_564411.base,
                         call_564411.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564411, url, valid)

proc call*(call_564412: Call_ProvisionApplicationType_564405;
          ApplicationTypeImageStorePath: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## provisionApplicationType
  ## Provisions or registers a Service Fabric application type with the cluster. This is required before any new applications can be instantiated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeImageStorePath: JObject (required)
  ##                                : The relative path for the application package in the image store specified during the prior copy operation.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564413 = newJObject()
  var body_564414 = newJObject()
  add(query_564413, "api-version", newJString(apiVersion))
  if ApplicationTypeImageStorePath != nil:
    body_564414 = ApplicationTypeImageStorePath
  add(query_564413, "timeout", newJInt(timeout))
  result = call_564412.call(nil, query_564413, nil, nil, body_564414)

var provisionApplicationType* = Call_ProvisionApplicationType_564405(
    name: "provisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ApplicationTypes/$/Provision",
    validator: validate_ProvisionApplicationType_564406, base: "",
    url: url_ProvisionApplicationType_564407, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationTypeInfoListByName_564415 = ref object of OpenApiRestCall_563565
proc url_GetApplicationTypeInfoListByName_564417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationTypeInfoListByName_564416(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_564432 = path.getOrDefault("applicationTypeName")
  valid_564432 = validateParameter(valid_564432, JString, required = true,
                                 default = nil)
  if valid_564432 != nil:
    section.add "applicationTypeName", valid_564432
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString
  ##                         : The version of the application type.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_564433 = query.getOrDefault("ContinuationToken")
  valid_564433 = validateParameter(valid_564433, JString, required = false,
                                 default = nil)
  if valid_564433 != nil:
    section.add "ContinuationToken", valid_564433
  var valid_564434 = query.getOrDefault("MaxResults")
  valid_564434 = validateParameter(valid_564434, JInt, required = false,
                                 default = newJInt(0))
  if valid_564434 != nil:
    section.add "MaxResults", valid_564434
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564435 = query.getOrDefault("api-version")
  valid_564435 = validateParameter(valid_564435, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564435 != nil:
    section.add "api-version", valid_564435
  var valid_564436 = query.getOrDefault("ApplicationTypeVersion")
  valid_564436 = validateParameter(valid_564436, JString, required = false,
                                 default = nil)
  if valid_564436 != nil:
    section.add "ApplicationTypeVersion", valid_564436
  var valid_564437 = query.getOrDefault("timeout")
  valid_564437 = validateParameter(valid_564437, JInt, required = false,
                                 default = newJInt(60))
  if valid_564437 != nil:
    section.add "timeout", valid_564437
  var valid_564438 = query.getOrDefault("ExcludeApplicationParameters")
  valid_564438 = validateParameter(valid_564438, JBool, required = false,
                                 default = newJBool(false))
  if valid_564438 != nil:
    section.add "ExcludeApplicationParameters", valid_564438
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564439: Call_GetApplicationTypeInfoListByName_564415;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ## 
  let valid = call_564439.validator(path, query, header, formData, body)
  let scheme = call_564439.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564439.url(scheme.get, call_564439.host, call_564439.base,
                         call_564439.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564439, url, valid)

proc call*(call_564440: Call_GetApplicationTypeInfoListByName_564415;
          applicationTypeName: string; ContinuationToken: string = "";
          MaxResults: int = 0; apiVersion: string = "6.0";
          ApplicationTypeVersion: string = ""; timeout: int = 60;
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationTypeInfoListByName
  ## Returns the information about the application types that are provisioned or in the process of being provisioned in the Service Fabric cluster. These results are of application types whose name match exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the application type matching the application type name are returned, with each version returned as one application type. The response includes the name, version, status and other details about the application type. This is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. For example, if there are 10 application types but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty continuation token is returned if there are no subsequent pages.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: string
  ##                         : The version of the application type.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var path_564441 = newJObject()
  var query_564442 = newJObject()
  add(query_564442, "ContinuationToken", newJString(ContinuationToken))
  add(query_564442, "MaxResults", newJInt(MaxResults))
  add(query_564442, "api-version", newJString(apiVersion))
  add(query_564442, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_564442, "timeout", newJInt(timeout))
  add(path_564441, "applicationTypeName", newJString(applicationTypeName))
  add(query_564442, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_564440.call(path_564441, query_564442, nil, nil, nil)

var getApplicationTypeInfoListByName* = Call_GetApplicationTypeInfoListByName_564415(
    name: "getApplicationTypeInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ApplicationTypes/{applicationTypeName}",
    validator: validate_GetApplicationTypeInfoListByName_564416, base: "",
    url: url_GetApplicationTypeInfoListByName_564417,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationManifest_564443 = ref object of OpenApiRestCall_563565
proc url_GetApplicationManifest_564445(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetApplicationManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationManifest_564444(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_564446 = path.getOrDefault("applicationTypeName")
  valid_564446 = validateParameter(valid_564446, JString, required = true,
                                 default = nil)
  if valid_564446 != nil:
    section.add "applicationTypeName", valid_564446
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564447 = query.getOrDefault("api-version")
  valid_564447 = validateParameter(valid_564447, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564447 != nil:
    section.add "api-version", valid_564447
  var valid_564448 = query.getOrDefault("ApplicationTypeVersion")
  valid_564448 = validateParameter(valid_564448, JString, required = true,
                                 default = nil)
  if valid_564448 != nil:
    section.add "ApplicationTypeVersion", valid_564448
  var valid_564449 = query.getOrDefault("timeout")
  valid_564449 = validateParameter(valid_564449, JInt, required = false,
                                 default = newJInt(60))
  if valid_564449 != nil:
    section.add "timeout", valid_564449
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564450: Call_GetApplicationManifest_564443; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ## 
  let valid = call_564450.validator(path, query, header, formData, body)
  let scheme = call_564450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564450.url(scheme.get, call_564450.host, call_564450.base,
                         call_564450.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564450, url, valid)

proc call*(call_564451: Call_GetApplicationManifest_564443;
          ApplicationTypeVersion: string; applicationTypeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getApplicationManifest
  ## Gets the manifest describing an application type. The response contains the application manifest XML as a string.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  var path_564452 = newJObject()
  var query_564453 = newJObject()
  add(query_564453, "api-version", newJString(apiVersion))
  add(query_564453, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_564453, "timeout", newJInt(timeout))
  add(path_564452, "applicationTypeName", newJString(applicationTypeName))
  result = call_564451.call(path_564452, query_564453, nil, nil, nil)

var getApplicationManifest* = Call_GetApplicationManifest_564443(
    name: "getApplicationManifest", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest",
    validator: validate_GetApplicationManifest_564444, base: "",
    url: url_GetApplicationManifest_564445, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceManifest_564454 = ref object of OpenApiRestCall_563565
proc url_GetServiceManifest_564456(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceManifest")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceManifest_564455(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_564457 = path.getOrDefault("applicationTypeName")
  valid_564457 = validateParameter(valid_564457, JString, required = true,
                                 default = nil)
  if valid_564457 != nil:
    section.add "applicationTypeName", valid_564457
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceManifestName: JString (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564458 = query.getOrDefault("api-version")
  valid_564458 = validateParameter(valid_564458, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564458 != nil:
    section.add "api-version", valid_564458
  var valid_564459 = query.getOrDefault("ApplicationTypeVersion")
  valid_564459 = validateParameter(valid_564459, JString, required = true,
                                 default = nil)
  if valid_564459 != nil:
    section.add "ApplicationTypeVersion", valid_564459
  var valid_564460 = query.getOrDefault("timeout")
  valid_564460 = validateParameter(valid_564460, JInt, required = false,
                                 default = newJInt(60))
  if valid_564460 != nil:
    section.add "timeout", valid_564460
  var valid_564461 = query.getOrDefault("ServiceManifestName")
  valid_564461 = validateParameter(valid_564461, JString, required = true,
                                 default = nil)
  if valid_564461 != nil:
    section.add "ServiceManifestName", valid_564461
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564462: Call_GetServiceManifest_564454; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ## 
  let valid = call_564462.validator(path, query, header, formData, body)
  let scheme = call_564462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564462.url(scheme.get, call_564462.host, call_564462.base,
                         call_564462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564462, url, valid)

proc call*(call_564463: Call_GetServiceManifest_564454;
          ApplicationTypeVersion: string; applicationTypeName: string;
          ServiceManifestName: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceManifest
  ## Gets the manifest describing a service type. The response contains the service manifest XML as a string.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ServiceManifestName: string (required)
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  var path_564464 = newJObject()
  var query_564465 = newJObject()
  add(query_564465, "api-version", newJString(apiVersion))
  add(query_564465, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_564465, "timeout", newJInt(timeout))
  add(path_564464, "applicationTypeName", newJString(applicationTypeName))
  add(query_564465, "ServiceManifestName", newJString(ServiceManifestName))
  result = call_564463.call(path_564464, query_564465, nil, nil, nil)

var getServiceManifest* = Call_GetServiceManifest_564454(
    name: "getServiceManifest", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceManifest",
    validator: validate_GetServiceManifest_564455, base: "",
    url: url_GetServiceManifest_564456, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceTypeInfoList_564466 = ref object of OpenApiRestCall_563565
proc url_GetServiceTypeInfoList_564468(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceTypeInfoList_564467(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_564469 = path.getOrDefault("applicationTypeName")
  valid_564469 = validateParameter(valid_564469, JString, required = true,
                                 default = nil)
  if valid_564469 != nil:
    section.add "applicationTypeName", valid_564469
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: JString (required)
  ##                         : The version of the application type.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564470 = query.getOrDefault("api-version")
  valid_564470 = validateParameter(valid_564470, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564470 != nil:
    section.add "api-version", valid_564470
  var valid_564471 = query.getOrDefault("ApplicationTypeVersion")
  valid_564471 = validateParameter(valid_564471, JString, required = true,
                                 default = nil)
  if valid_564471 != nil:
    section.add "ApplicationTypeVersion", valid_564471
  var valid_564472 = query.getOrDefault("timeout")
  valid_564472 = validateParameter(valid_564472, JInt, required = false,
                                 default = newJInt(60))
  if valid_564472 != nil:
    section.add "timeout", valid_564472
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564473: Call_GetServiceTypeInfoList_564466; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ## 
  let valid = call_564473.validator(path, query, header, formData, body)
  let scheme = call_564473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564473.url(scheme.get, call_564473.host, call_564473.base,
                         call_564473.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564473, url, valid)

proc call*(call_564474: Call_GetServiceTypeInfoList_564466;
          ApplicationTypeVersion: string; applicationTypeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceTypeInfoList
  ## Gets the list containing the information about service types that are supported by a provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type and other information about it.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationTypeVersion: string (required)
  ##                         : The version of the application type.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  var path_564475 = newJObject()
  var query_564476 = newJObject()
  add(query_564476, "api-version", newJString(apiVersion))
  add(query_564476, "ApplicationTypeVersion", newJString(ApplicationTypeVersion))
  add(query_564476, "timeout", newJInt(timeout))
  add(path_564475, "applicationTypeName", newJString(applicationTypeName))
  result = call_564474.call(path_564475, query_564476, nil, nil, nil)

var getServiceTypeInfoList* = Call_GetServiceTypeInfoList_564466(
    name: "getServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/GetServiceTypes",
    validator: validate_GetServiceTypeInfoList_564467, base: "",
    url: url_GetServiceTypeInfoList_564468, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UnprovisionApplicationType_564477 = ref object of OpenApiRestCall_563565
proc url_UnprovisionApplicationType_564479(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationTypeName" in path,
        "`applicationTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ApplicationTypes/"),
               (kind: VariableSegment, value: "applicationTypeName"),
               (kind: ConstantSegment, value: "/$/Unprovision")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UnprovisionApplicationType_564478(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationTypeName: JString (required)
  ##                      : The name of the application type.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `applicationTypeName` field"
  var valid_564480 = path.getOrDefault("applicationTypeName")
  valid_564480 = validateParameter(valid_564480, JString, required = true,
                                 default = nil)
  if valid_564480 != nil:
    section.add "applicationTypeName", valid_564480
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564481 = query.getOrDefault("api-version")
  valid_564481 = validateParameter(valid_564481, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564481 != nil:
    section.add "api-version", valid_564481
  var valid_564482 = query.getOrDefault("timeout")
  valid_564482 = validateParameter(valid_564482, JInt, required = false,
                                 default = newJInt(60))
  if valid_564482 != nil:
    section.add "timeout", valid_564482
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564484: Call_UnprovisionApplicationType_564477; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ## 
  let valid = call_564484.validator(path, query, header, formData, body)
  let scheme = call_564484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564484.url(scheme.get, call_564484.host, call_564484.base,
                         call_564484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564484, url, valid)

proc call*(call_564485: Call_UnprovisionApplicationType_564477;
          applicationTypeName: string; ApplicationTypeImageStoreVersion: JsonNode;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## unprovisionApplicationType
  ## Removes or unregisters a Service Fabric application type from the cluster. This operation can only be performed if all application instance of the application type has been deleted. Once the application type is unregistered, no new application instance can be created for this particular application type.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationTypeName: string (required)
  ##                      : The name of the application type.
  ##   ApplicationTypeImageStoreVersion: JObject (required)
  ##                                   : The version of the application type in the image store.
  var path_564486 = newJObject()
  var query_564487 = newJObject()
  var body_564488 = newJObject()
  add(query_564487, "api-version", newJString(apiVersion))
  add(query_564487, "timeout", newJInt(timeout))
  add(path_564486, "applicationTypeName", newJString(applicationTypeName))
  if ApplicationTypeImageStoreVersion != nil:
    body_564488 = ApplicationTypeImageStoreVersion
  result = call_564485.call(path_564486, query_564487, nil, nil, body_564488)

var unprovisionApplicationType* = Call_UnprovisionApplicationType_564477(
    name: "unprovisionApplicationType", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ApplicationTypes/{applicationTypeName}/$/Unprovision",
    validator: validate_UnprovisionApplicationType_564478, base: "",
    url: url_UnprovisionApplicationType_564479,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfoList_564489 = ref object of OpenApiRestCall_563565
proc url_GetApplicationInfoList_564491(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetApplicationInfoList_564490(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationDefinitionKindFilter: JInt
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationTypeName: JString
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  var valid_564492 = query.getOrDefault("ContinuationToken")
  valid_564492 = validateParameter(valid_564492, JString, required = false,
                                 default = nil)
  if valid_564492 != nil:
    section.add "ContinuationToken", valid_564492
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564493 = query.getOrDefault("api-version")
  valid_564493 = validateParameter(valid_564493, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564493 != nil:
    section.add "api-version", valid_564493
  var valid_564494 = query.getOrDefault("ApplicationDefinitionKindFilter")
  valid_564494 = validateParameter(valid_564494, JInt, required = false,
                                 default = newJInt(0))
  if valid_564494 != nil:
    section.add "ApplicationDefinitionKindFilter", valid_564494
  var valid_564495 = query.getOrDefault("timeout")
  valid_564495 = validateParameter(valid_564495, JInt, required = false,
                                 default = newJInt(60))
  if valid_564495 != nil:
    section.add "timeout", valid_564495
  var valid_564496 = query.getOrDefault("ApplicationTypeName")
  valid_564496 = validateParameter(valid_564496, JString, required = false,
                                 default = nil)
  if valid_564496 != nil:
    section.add "ApplicationTypeName", valid_564496
  var valid_564497 = query.getOrDefault("ExcludeApplicationParameters")
  valid_564497 = validateParameter(valid_564497, JBool, required = false,
                                 default = newJBool(false))
  if valid_564497 != nil:
    section.add "ExcludeApplicationParameters", valid_564497
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564498: Call_GetApplicationInfoList_564489; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ## 
  let valid = call_564498.validator(path, query, header, formData, body)
  let scheme = call_564498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564498.url(scheme.get, call_564498.host, call_564498.base,
                         call_564498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564498, url, valid)

proc call*(call_564499: Call_GetApplicationInfoList_564489;
          ContinuationToken: string = ""; apiVersion: string = "6.0";
          ApplicationDefinitionKindFilter: int = 0; timeout: int = 60;
          ApplicationTypeName: string = "";
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfoList
  ## Gets the information about the applications that were created or in the process of being created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name, type, status, parameters and other details about the application. If the applications do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Filters ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationDefinitionKindFilter: int
  ##                                  : Used to filter on ApplicationDefinitionKind for application query operations.
  ## - Default - Default value, which performs the same function as selecting "All". The value is 0.
  ## - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
  ## - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
  ## - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationTypeName: string
  ##                      : The application type name used to filter the applications to query for. This value should not contain the application type version.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  var query_564500 = newJObject()
  add(query_564500, "ContinuationToken", newJString(ContinuationToken))
  add(query_564500, "api-version", newJString(apiVersion))
  add(query_564500, "ApplicationDefinitionKindFilter",
      newJInt(ApplicationDefinitionKindFilter))
  add(query_564500, "timeout", newJInt(timeout))
  add(query_564500, "ApplicationTypeName", newJString(ApplicationTypeName))
  add(query_564500, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  result = call_564499.call(nil, query_564500, nil, nil, nil)

var getApplicationInfoList* = Call_GetApplicationInfoList_564489(
    name: "getApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications",
    validator: validate_GetApplicationInfoList_564490, base: "",
    url: url_GetApplicationInfoList_564491, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateApplication_564501 = ref object of OpenApiRestCall_563565
proc url_CreateApplication_564503(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateApplication_564502(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Creates a Service Fabric application using the specified description.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564504 = query.getOrDefault("api-version")
  valid_564504 = validateParameter(valid_564504, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564504 != nil:
    section.add "api-version", valid_564504
  var valid_564505 = query.getOrDefault("timeout")
  valid_564505 = validateParameter(valid_564505, JInt, required = false,
                                 default = newJInt(60))
  if valid_564505 != nil:
    section.add "timeout", valid_564505
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564507: Call_CreateApplication_564501; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric application using the specified description.
  ## 
  let valid = call_564507.validator(path, query, header, formData, body)
  let scheme = call_564507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564507.url(scheme.get, call_564507.host, call_564507.base,
                         call_564507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564507, url, valid)

proc call*(call_564508: Call_CreateApplication_564501;
          ApplicationDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## createApplication
  ## Creates a Service Fabric application using the specified description.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationDescription: JObject (required)
  ##                         : Description for creating an application.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564509 = newJObject()
  var body_564510 = newJObject()
  add(query_564509, "api-version", newJString(apiVersion))
  if ApplicationDescription != nil:
    body_564510 = ApplicationDescription
  add(query_564509, "timeout", newJInt(timeout))
  result = call_564508.call(nil, query_564509, nil, nil, body_564510)

var createApplication* = Call_CreateApplication_564501(name: "createApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/$/Create", validator: validate_CreateApplication_564502,
    base: "", url: url_CreateApplication_564503,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationInfo_564511 = ref object of OpenApiRestCall_563565
proc url_GetApplicationInfo_564513(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationInfo_564512(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564514 = path.getOrDefault("applicationId")
  valid_564514 = validateParameter(valid_564514, JString, required = true,
                                 default = nil)
  if valid_564514 != nil:
    section.add "applicationId", valid_564514
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ExcludeApplicationParameters: JBool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564515 = query.getOrDefault("api-version")
  valid_564515 = validateParameter(valid_564515, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564515 != nil:
    section.add "api-version", valid_564515
  var valid_564516 = query.getOrDefault("timeout")
  valid_564516 = validateParameter(valid_564516, JInt, required = false,
                                 default = newJInt(60))
  if valid_564516 != nil:
    section.add "timeout", valid_564516
  var valid_564517 = query.getOrDefault("ExcludeApplicationParameters")
  valid_564517 = validateParameter(valid_564517, JBool, required = false,
                                 default = newJBool(false))
  if valid_564517 != nil:
    section.add "ExcludeApplicationParameters", valid_564517
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564518: Call_GetApplicationInfo_564511; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ## 
  let valid = call_564518.validator(path, query, header, formData, body)
  let scheme = call_564518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564518.url(scheme.get, call_564518.host, call_564518.base,
                         call_564518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564518, url, valid)

proc call*(call_564519: Call_GetApplicationInfo_564511; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          ExcludeApplicationParameters: bool = false): Recallable =
  ## getApplicationInfo
  ## Returns the information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, type, status, parameters and other details about the application.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ExcludeApplicationParameters: bool
  ##                               : The flag that specifies whether application parameters will be excluded from the result.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564520 = newJObject()
  var query_564521 = newJObject()
  add(query_564521, "api-version", newJString(apiVersion))
  add(query_564521, "timeout", newJInt(timeout))
  add(query_564521, "ExcludeApplicationParameters",
      newJBool(ExcludeApplicationParameters))
  add(path_564520, "applicationId", newJString(applicationId))
  result = call_564519.call(path_564520, query_564521, nil, nil, nil)

var getApplicationInfo* = Call_GetApplicationInfo_564511(
    name: "getApplicationInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}",
    validator: validate_GetApplicationInfo_564512, base: "",
    url: url_GetApplicationInfo_564513, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteApplication_564522 = ref object of OpenApiRestCall_563565
proc url_DeleteApplication_564524(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteApplication_564523(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564525 = path.getOrDefault("applicationId")
  valid_564525 = validateParameter(valid_564525, JString, required = true,
                                 default = nil)
  if valid_564525 != nil:
    section.add "applicationId", valid_564525
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564526 = query.getOrDefault("api-version")
  valid_564526 = validateParameter(valid_564526, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564526 != nil:
    section.add "api-version", valid_564526
  var valid_564527 = query.getOrDefault("timeout")
  valid_564527 = validateParameter(valid_564527, JInt, required = false,
                                 default = newJInt(60))
  if valid_564527 != nil:
    section.add "timeout", valid_564527
  var valid_564528 = query.getOrDefault("ForceRemove")
  valid_564528 = validateParameter(valid_564528, JBool, required = false, default = nil)
  if valid_564528 != nil:
    section.add "ForceRemove", valid_564528
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564529: Call_DeleteApplication_564522; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ## 
  let valid = call_564529.validator(path, query, header, formData, body)
  let scheme = call_564529.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564529.url(scheme.get, call_564529.host, call_564529.base,
                         call_564529.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564529, url, valid)

proc call*(call_564530: Call_DeleteApplication_564522; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60; ForceRemove: bool = false): Recallable =
  ## deleteApplication
  ## Deletes an existing Service Fabric application. An application must be created before it can be deleted. Deleting an application will delete all services that are part of that application. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the its services.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564531 = newJObject()
  var query_564532 = newJObject()
  add(query_564532, "api-version", newJString(apiVersion))
  add(query_564532, "timeout", newJInt(timeout))
  add(query_564532, "ForceRemove", newJBool(ForceRemove))
  add(path_564531, "applicationId", newJString(applicationId))
  result = call_564530.call(path_564531, query_564532, nil, nil, nil)

var deleteApplication* = Call_DeleteApplication_564522(name: "deleteApplication",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/Delete",
    validator: validate_DeleteApplication_564523, base: "",
    url: url_DeleteApplication_564524, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealthUsingPolicy_564547 = ref object of OpenApiRestCall_563565
proc url_GetApplicationHealthUsingPolicy_564549(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealthUsingPolicy_564548(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564550 = path.getOrDefault("applicationId")
  valid_564550 = validateParameter(valid_564550, JString, required = true,
                                 default = nil)
  if valid_564550 != nil:
    section.add "applicationId", valid_564550
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564551 = query.getOrDefault("api-version")
  valid_564551 = validateParameter(valid_564551, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564551 != nil:
    section.add "api-version", valid_564551
  var valid_564552 = query.getOrDefault("ExcludeHealthStatistics")
  valid_564552 = validateParameter(valid_564552, JBool, required = false,
                                 default = newJBool(false))
  if valid_564552 != nil:
    section.add "ExcludeHealthStatistics", valid_564552
  var valid_564553 = query.getOrDefault("timeout")
  valid_564553 = validateParameter(valid_564553, JInt, required = false,
                                 default = newJInt(60))
  if valid_564553 != nil:
    section.add "timeout", valid_564553
  var valid_564554 = query.getOrDefault("ServicesHealthStateFilter")
  valid_564554 = validateParameter(valid_564554, JInt, required = false,
                                 default = newJInt(0))
  if valid_564554 != nil:
    section.add "ServicesHealthStateFilter", valid_564554
  var valid_564555 = query.getOrDefault("EventsHealthStateFilter")
  valid_564555 = validateParameter(valid_564555, JInt, required = false,
                                 default = newJInt(0))
  if valid_564555 != nil:
    section.add "EventsHealthStateFilter", valid_564555
  var valid_564556 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_564556 = validateParameter(valid_564556, JInt, required = false,
                                 default = newJInt(0))
  if valid_564556 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_564556
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564558: Call_GetApplicationHealthUsingPolicy_564547;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ## 
  let valid = call_564558.validator(path, query, header, formData, body)
  let scheme = call_564558.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564558.url(scheme.get, call_564558.host, call_564558.base,
                         call_564558.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564558, url, valid)

proc call*(call_564559: Call_GetApplicationHealthUsingPolicy_564547;
          applicationId: string; ApplicationHealthPolicy: JsonNode = nil;
          apiVersion: string = "6.0"; ExcludeHealthStatistics: bool = false;
          timeout: int = 60; ServicesHealthStateFilter: int = 0;
          EventsHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealthUsingPolicy
  ## Gets the health of a Service Fabric application. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to override the health policies used to evaluate the health.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_564560 = newJObject()
  var query_564561 = newJObject()
  var body_564562 = newJObject()
  add(path_564560, "applicationId", newJString(applicationId))
  if ApplicationHealthPolicy != nil:
    body_564562 = ApplicationHealthPolicy
  add(query_564561, "api-version", newJString(apiVersion))
  add(query_564561, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_564561, "timeout", newJInt(timeout))
  add(query_564561, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_564561, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_564561, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_564559.call(path_564560, query_564561, nil, nil, body_564562)

var getApplicationHealthUsingPolicy* = Call_GetApplicationHealthUsingPolicy_564547(
    name: "getApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealthUsingPolicy_564548, base: "",
    url: url_GetApplicationHealthUsingPolicy_564549,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationHealth_564533 = ref object of OpenApiRestCall_563565
proc url_GetApplicationHealth_564535(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationHealth_564534(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564536 = path.getOrDefault("applicationId")
  valid_564536 = validateParameter(valid_564536, JString, required = true,
                                 default = nil)
  if valid_564536 != nil:
    section.add "applicationId", valid_564536
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServicesHealthStateFilter: JInt
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: JInt
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564537 = query.getOrDefault("api-version")
  valid_564537 = validateParameter(valid_564537, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564537 != nil:
    section.add "api-version", valid_564537
  var valid_564538 = query.getOrDefault("ExcludeHealthStatistics")
  valid_564538 = validateParameter(valid_564538, JBool, required = false,
                                 default = newJBool(false))
  if valid_564538 != nil:
    section.add "ExcludeHealthStatistics", valid_564538
  var valid_564539 = query.getOrDefault("timeout")
  valid_564539 = validateParameter(valid_564539, JInt, required = false,
                                 default = newJInt(60))
  if valid_564539 != nil:
    section.add "timeout", valid_564539
  var valid_564540 = query.getOrDefault("ServicesHealthStateFilter")
  valid_564540 = validateParameter(valid_564540, JInt, required = false,
                                 default = newJInt(0))
  if valid_564540 != nil:
    section.add "ServicesHealthStateFilter", valid_564540
  var valid_564541 = query.getOrDefault("EventsHealthStateFilter")
  valid_564541 = validateParameter(valid_564541, JInt, required = false,
                                 default = newJInt(0))
  if valid_564541 != nil:
    section.add "EventsHealthStateFilter", valid_564541
  var valid_564542 = query.getOrDefault("DeployedApplicationsHealthStateFilter")
  valid_564542 = validateParameter(valid_564542, JInt, required = false,
                                 default = newJInt(0))
  if valid_564542 != nil:
    section.add "DeployedApplicationsHealthStateFilter", valid_564542
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564543: Call_GetApplicationHealth_564533; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ## 
  let valid = call_564543.validator(path, query, header, formData, body)
  let scheme = call_564543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564543.url(scheme.get, call_564543.host, call_564543.base,
                         call_564543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564543, url, valid)

proc call*(call_564544: Call_GetApplicationHealth_564533; applicationId: string;
          apiVersion: string = "6.0"; ExcludeHealthStatistics: bool = false;
          timeout: int = 60; ServicesHealthStateFilter: int = 0;
          EventsHealthStateFilter: int = 0;
          DeployedApplicationsHealthStateFilter: int = 0): Recallable =
  ## getApplicationHealth
  ## Returns the heath state of the service fabric application. The response reports either Ok, Error or Warning health state. If the entity is not found in the helath store, it will return Error.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServicesHealthStateFilter: int
  ##                            : Allows filtering of the services health state objects returned in the result of services health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only services that match the filter are returned. All services are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   DeployedApplicationsHealthStateFilter: int
  ##                                        : Allows filtering of the deployed applications health state objects returned in the result of application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states. Only deployed applications that match the filter will be returned.\
  ## All deployed applications are used to evaluate the aggregated health state. If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of deployed applications with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_564545 = newJObject()
  var query_564546 = newJObject()
  add(path_564545, "applicationId", newJString(applicationId))
  add(query_564546, "api-version", newJString(apiVersion))
  add(query_564546, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_564546, "timeout", newJInt(timeout))
  add(query_564546, "ServicesHealthStateFilter",
      newJInt(ServicesHealthStateFilter))
  add(query_564546, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_564546, "DeployedApplicationsHealthStateFilter",
      newJInt(DeployedApplicationsHealthStateFilter))
  result = call_564544.call(path_564545, query_564546, nil, nil, nil)

var getApplicationHealth* = Call_GetApplicationHealth_564533(
    name: "getApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/GetHealth",
    validator: validate_GetApplicationHealth_564534, base: "",
    url: url_GetApplicationHealth_564535, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationLoadInfo_564563 = ref object of OpenApiRestCall_563565
proc url_GetApplicationLoadInfo_564565(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationLoadInfo_564564(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564566 = path.getOrDefault("applicationId")
  valid_564566 = validateParameter(valid_564566, JString, required = true,
                                 default = nil)
  if valid_564566 != nil:
    section.add "applicationId", valid_564566
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564567 = query.getOrDefault("api-version")
  valid_564567 = validateParameter(valid_564567, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564567 != nil:
    section.add "api-version", valid_564567
  var valid_564568 = query.getOrDefault("timeout")
  valid_564568 = validateParameter(valid_564568, JInt, required = false,
                                 default = newJInt(60))
  if valid_564568 != nil:
    section.add "timeout", valid_564568
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564569: Call_GetApplicationLoadInfo_564563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ## 
  let valid = call_564569.validator(path, query, header, formData, body)
  let scheme = call_564569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564569.url(scheme.get, call_564569.host, call_564569.base,
                         call_564569.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564569, url, valid)

proc call*(call_564570: Call_GetApplicationLoadInfo_564563; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getApplicationLoadInfo
  ## Returns the load information about the application that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application load metric information about the application.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564571 = newJObject()
  var query_564572 = newJObject()
  add(query_564572, "api-version", newJString(apiVersion))
  add(query_564572, "timeout", newJInt(timeout))
  add(path_564571, "applicationId", newJString(applicationId))
  result = call_564570.call(path_564571, query_564572, nil, nil, nil)

var getApplicationLoadInfo* = Call_GetApplicationLoadInfo_564563(
    name: "getApplicationLoadInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetLoadInformation",
    validator: validate_GetApplicationLoadInfo_564564, base: "",
    url: url_GetApplicationLoadInfo_564565, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfoList_564573 = ref object of OpenApiRestCall_563565
proc url_GetServiceInfoList_564575(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfoList_564574(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564576 = path.getOrDefault("applicationId")
  valid_564576 = validateParameter(valid_564576, JString, required = true,
                                 default = nil)
  if valid_564576 != nil:
    section.add "applicationId", valid_564576
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: JString
  ##                  : The service type name used to filter the services to query for.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_564577 = query.getOrDefault("ContinuationToken")
  valid_564577 = validateParameter(valid_564577, JString, required = false,
                                 default = nil)
  if valid_564577 != nil:
    section.add "ContinuationToken", valid_564577
  var valid_564578 = query.getOrDefault("ServiceTypeName")
  valid_564578 = validateParameter(valid_564578, JString, required = false,
                                 default = nil)
  if valid_564578 != nil:
    section.add "ServiceTypeName", valid_564578
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564579 = query.getOrDefault("api-version")
  valid_564579 = validateParameter(valid_564579, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564579 != nil:
    section.add "api-version", valid_564579
  var valid_564580 = query.getOrDefault("timeout")
  valid_564580 = validateParameter(valid_564580, JInt, required = false,
                                 default = newJInt(60))
  if valid_564580 != nil:
    section.add "timeout", valid_564580
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564581: Call_GetServiceInfoList_564573; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about all services belonging to the application specified by the application id.
  ## 
  let valid = call_564581.validator(path, query, header, formData, body)
  let scheme = call_564581.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564581.url(scheme.get, call_564581.host, call_564581.base,
                         call_564581.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564581, url, valid)

proc call*(call_564582: Call_GetServiceInfoList_564573; applicationId: string;
          ContinuationToken: string = ""; ServiceTypeName: string = "";
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceInfoList
  ## Returns the information about all services belonging to the application specified by the application id.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   ServiceTypeName: string
  ##                  : The service type name used to filter the services to query for.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564583 = newJObject()
  var query_564584 = newJObject()
  add(query_564584, "ContinuationToken", newJString(ContinuationToken))
  add(query_564584, "ServiceTypeName", newJString(ServiceTypeName))
  add(query_564584, "api-version", newJString(apiVersion))
  add(query_564584, "timeout", newJInt(timeout))
  add(path_564583, "applicationId", newJString(applicationId))
  result = call_564582.call(path_564583, query_564584, nil, nil, nil)

var getServiceInfoList* = Call_GetServiceInfoList_564573(
    name: "getServiceInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices",
    validator: validate_GetServiceInfoList_564574, base: "",
    url: url_GetServiceInfoList_564575, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateService_564585 = ref object of OpenApiRestCall_563565
proc url_CreateService_564587(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/$/Create")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateService_564586(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564588 = path.getOrDefault("applicationId")
  valid_564588 = validateParameter(valid_564588, JString, required = true,
                                 default = nil)
  if valid_564588 != nil:
    section.add "applicationId", valid_564588
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564589 = query.getOrDefault("api-version")
  valid_564589 = validateParameter(valid_564589, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564589 != nil:
    section.add "api-version", valid_564589
  var valid_564590 = query.getOrDefault("timeout")
  valid_564590 = validateParameter(valid_564590, JInt, required = false,
                                 default = newJInt(60))
  if valid_564590 != nil:
    section.add "timeout", valid_564590
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564592: Call_CreateService_564585; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified service.
  ## 
  let valid = call_564592.validator(path, query, header, formData, body)
  let scheme = call_564592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564592.url(scheme.get, call_564592.host, call_564592.base,
                         call_564592.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564592, url, valid)

proc call*(call_564593: Call_CreateService_564585; ServiceDescription: JsonNode;
          applicationId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## createService
  ## Creates the specified service.
  ##   ServiceDescription: JObject (required)
  ##                     : The information necessary to create a service.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564594 = newJObject()
  var query_564595 = newJObject()
  var body_564596 = newJObject()
  if ServiceDescription != nil:
    body_564596 = ServiceDescription
  add(query_564595, "api-version", newJString(apiVersion))
  add(query_564595, "timeout", newJInt(timeout))
  add(path_564594, "applicationId", newJString(applicationId))
  result = call_564593.call(path_564594, query_564595, nil, nil, body_564596)

var createService* = Call_CreateService_564585(name: "createService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/Create",
    validator: validate_CreateService_564586, base: "", url: url_CreateService_564587,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateServiceFromTemplate_564597 = ref object of OpenApiRestCall_563565
proc url_CreateServiceFromTemplate_564599(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"), (
        kind: ConstantSegment, value: "/$/GetServices/$/CreateFromTemplate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_CreateServiceFromTemplate_564598(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564600 = path.getOrDefault("applicationId")
  valid_564600 = validateParameter(valid_564600, JString, required = true,
                                 default = nil)
  if valid_564600 != nil:
    section.add "applicationId", valid_564600
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564601 = query.getOrDefault("api-version")
  valid_564601 = validateParameter(valid_564601, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564601 != nil:
    section.add "api-version", valid_564601
  var valid_564602 = query.getOrDefault("timeout")
  valid_564602 = validateParameter(valid_564602, JInt, required = false,
                                 default = newJInt(60))
  if valid_564602 != nil:
    section.add "timeout", valid_564602
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564604: Call_CreateServiceFromTemplate_564597; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ## 
  let valid = call_564604.validator(path, query, header, formData, body)
  let scheme = call_564604.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564604.url(scheme.get, call_564604.host, call_564604.base,
                         call_564604.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564604, url, valid)

proc call*(call_564605: Call_CreateServiceFromTemplate_564597;
          ServiceFromTemplateDescription: JsonNode; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## createServiceFromTemplate
  ## Creates a Service Fabric service from the service template defined in the application manifest.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceFromTemplateDescription: JObject (required)
  ##                                 : Describes the service that needs to be created from the template defined in the application manifest.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564606 = newJObject()
  var query_564607 = newJObject()
  var body_564608 = newJObject()
  add(query_564607, "api-version", newJString(apiVersion))
  if ServiceFromTemplateDescription != nil:
    body_564608 = ServiceFromTemplateDescription
  add(query_564607, "timeout", newJInt(timeout))
  add(path_564606, "applicationId", newJString(applicationId))
  result = call_564605.call(path_564606, query_564607, nil, nil, body_564608)

var createServiceFromTemplate* = Call_CreateServiceFromTemplate_564597(
    name: "createServiceFromTemplate", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/$/CreateFromTemplate",
    validator: validate_CreateServiceFromTemplate_564598, base: "",
    url: url_CreateServiceFromTemplate_564599,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceInfo_564609 = ref object of OpenApiRestCall_563565
proc url_GetServiceInfo_564611(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServices/"),
               (kind: VariableSegment, value: "serviceId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceInfo_564610(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_564612 = path.getOrDefault("serviceId")
  valid_564612 = validateParameter(valid_564612, JString, required = true,
                                 default = nil)
  if valid_564612 != nil:
    section.add "serviceId", valid_564612
  var valid_564613 = path.getOrDefault("applicationId")
  valid_564613 = validateParameter(valid_564613, JString, required = true,
                                 default = nil)
  if valid_564613 != nil:
    section.add "applicationId", valid_564613
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564614 = query.getOrDefault("api-version")
  valid_564614 = validateParameter(valid_564614, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564614 != nil:
    section.add "api-version", valid_564614
  var valid_564615 = query.getOrDefault("timeout")
  valid_564615 = validateParameter(valid_564615, JInt, required = false,
                                 default = newJInt(60))
  if valid_564615 != nil:
    section.add "timeout", valid_564615
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564616: Call_GetServiceInfo_564609; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ## 
  let valid = call_564616.validator(path, query, header, formData, body)
  let scheme = call_564616.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564616.url(scheme.get, call_564616.host, call_564616.base,
                         call_564616.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564616, url, valid)

proc call*(call_564617: Call_GetServiceInfo_564609; serviceId: string;
          applicationId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceInfo
  ## Returns the information about specified service belonging to the specified Service Fabric application.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564618 = newJObject()
  var query_564619 = newJObject()
  add(query_564619, "api-version", newJString(apiVersion))
  add(query_564619, "timeout", newJInt(timeout))
  add(path_564618, "serviceId", newJString(serviceId))
  add(path_564618, "applicationId", newJString(applicationId))
  result = call_564617.call(path_564618, query_564619, nil, nil, nil)

var getServiceInfo* = Call_GetServiceInfo_564609(name: "getServiceInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetServices/{serviceId}",
    validator: validate_GetServiceInfo_564610, base: "", url: url_GetServiceInfo_564611,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationUpgrade_564620 = ref object of OpenApiRestCall_563565
proc url_GetApplicationUpgrade_564622(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationUpgrade_564621(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564623 = path.getOrDefault("applicationId")
  valid_564623 = validateParameter(valid_564623, JString, required = true,
                                 default = nil)
  if valid_564623 != nil:
    section.add "applicationId", valid_564623
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564624 = query.getOrDefault("api-version")
  valid_564624 = validateParameter(valid_564624, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564624 != nil:
    section.add "api-version", valid_564624
  var valid_564625 = query.getOrDefault("timeout")
  valid_564625 = validateParameter(valid_564625, JInt, required = false,
                                 default = newJInt(60))
  if valid_564625 != nil:
    section.add "timeout", valid_564625
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564626: Call_GetApplicationUpgrade_564620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_564626.validator(path, query, header, formData, body)
  let scheme = call_564626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564626.url(scheme.get, call_564626.host, call_564626.base,
                         call_564626.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564626, url, valid)

proc call*(call_564627: Call_GetApplicationUpgrade_564620; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getApplicationUpgrade
  ## Returns information about the state of the latest application upgrade along with details to aid debugging application health issues.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564628 = newJObject()
  var query_564629 = newJObject()
  add(query_564629, "api-version", newJString(apiVersion))
  add(query_564629, "timeout", newJInt(timeout))
  add(path_564628, "applicationId", newJString(applicationId))
  result = call_564627.call(path_564628, query_564629, nil, nil, nil)

var getApplicationUpgrade* = Call_GetApplicationUpgrade_564620(
    name: "getApplicationUpgrade", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/GetUpgradeProgress",
    validator: validate_GetApplicationUpgrade_564621, base: "",
    url: url_GetApplicationUpgrade_564622, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResumeApplicationUpgrade_564630 = ref object of OpenApiRestCall_563565
proc url_ResumeApplicationUpgrade_564632(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/MoveToNextUpgradeDomain")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResumeApplicationUpgrade_564631(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564633 = path.getOrDefault("applicationId")
  valid_564633 = validateParameter(valid_564633, JString, required = true,
                                 default = nil)
  if valid_564633 != nil:
    section.add "applicationId", valid_564633
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564634 = query.getOrDefault("api-version")
  valid_564634 = validateParameter(valid_564634, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564634 != nil:
    section.add "api-version", valid_564634
  var valid_564635 = query.getOrDefault("timeout")
  valid_564635 = validateParameter(valid_564635, JInt, required = false,
                                 default = newJInt(60))
  if valid_564635 != nil:
    section.add "timeout", valid_564635
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564637: Call_ResumeApplicationUpgrade_564630; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ## 
  let valid = call_564637.validator(path, query, header, formData, body)
  let scheme = call_564637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564637.url(scheme.get, call_564637.host, call_564637.base,
                         call_564637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564637, url, valid)

proc call*(call_564638: Call_ResumeApplicationUpgrade_564630;
          ResumeApplicationUpgradeDescription: JsonNode; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## resumeApplicationUpgrade
  ## Resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it waits for you to call this API before proceeding to the next upgrade domain.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ResumeApplicationUpgradeDescription: JObject (required)
  ##                                      : Describes the parameters for resuming an application upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564639 = newJObject()
  var query_564640 = newJObject()
  var body_564641 = newJObject()
  add(query_564640, "api-version", newJString(apiVersion))
  if ResumeApplicationUpgradeDescription != nil:
    body_564641 = ResumeApplicationUpgradeDescription
  add(query_564640, "timeout", newJInt(timeout))
  add(path_564639, "applicationId", newJString(applicationId))
  result = call_564638.call(path_564639, query_564640, nil, nil, body_564641)

var resumeApplicationUpgrade* = Call_ResumeApplicationUpgrade_564630(
    name: "resumeApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/MoveToNextUpgradeDomain",
    validator: validate_ResumeApplicationUpgrade_564631, base: "",
    url: url_ResumeApplicationUpgrade_564632, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportApplicationHealth_564642 = ref object of OpenApiRestCall_563565
proc url_ReportApplicationHealth_564644(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportApplicationHealth_564643(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564645 = path.getOrDefault("applicationId")
  valid_564645 = validateParameter(valid_564645, JString, required = true,
                                 default = nil)
  if valid_564645 != nil:
    section.add "applicationId", valid_564645
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_564646 = query.getOrDefault("Immediate")
  valid_564646 = validateParameter(valid_564646, JBool, required = false,
                                 default = newJBool(false))
  if valid_564646 != nil:
    section.add "Immediate", valid_564646
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564647 = query.getOrDefault("api-version")
  valid_564647 = validateParameter(valid_564647, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564647 != nil:
    section.add "api-version", valid_564647
  var valid_564648 = query.getOrDefault("timeout")
  valid_564648 = validateParameter(valid_564648, JInt, required = false,
                                 default = newJInt(60))
  if valid_564648 != nil:
    section.add "timeout", valid_564648
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564650: Call_ReportApplicationHealth_564642; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_564650.validator(path, query, header, formData, body)
  let scheme = call_564650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564650.url(scheme.get, call_564650.host, call_564650.base,
                         call_564650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564650, url, valid)

proc call*(call_564651: Call_ReportApplicationHealth_564642;
          HealthInformation: JsonNode; applicationId: string;
          Immediate: bool = false; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## reportApplicationHealth
  ## Reports health state of the specified Service Fabric application. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564652 = newJObject()
  var query_564653 = newJObject()
  var body_564654 = newJObject()
  add(query_564653, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_564654 = HealthInformation
  add(query_564653, "api-version", newJString(apiVersion))
  add(query_564653, "timeout", newJInt(timeout))
  add(path_564652, "applicationId", newJString(applicationId))
  result = call_564651.call(path_564652, query_564653, nil, nil, body_564654)

var reportApplicationHealth* = Call_ReportApplicationHealth_564642(
    name: "reportApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/ReportHealth",
    validator: validate_ReportApplicationHealth_564643, base: "",
    url: url_ReportApplicationHealth_564644, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RollbackApplicationUpgrade_564655 = ref object of OpenApiRestCall_563565
proc url_RollbackApplicationUpgrade_564657(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/RollbackUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RollbackApplicationUpgrade_564656(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564658 = path.getOrDefault("applicationId")
  valid_564658 = validateParameter(valid_564658, JString, required = true,
                                 default = nil)
  if valid_564658 != nil:
    section.add "applicationId", valid_564658
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564659 = query.getOrDefault("api-version")
  valid_564659 = validateParameter(valid_564659, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564659 != nil:
    section.add "api-version", valid_564659
  var valid_564660 = query.getOrDefault("timeout")
  valid_564660 = validateParameter(valid_564660, JInt, required = false,
                                 default = newJInt(60))
  if valid_564660 != nil:
    section.add "timeout", valid_564660
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564661: Call_RollbackApplicationUpgrade_564655; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ## 
  let valid = call_564661.validator(path, query, header, formData, body)
  let scheme = call_564661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564661.url(scheme.get, call_564661.host, call_564661.base,
                         call_564661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564661, url, valid)

proc call*(call_564662: Call_RollbackApplicationUpgrade_564655;
          applicationId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## rollbackApplicationUpgrade
  ## Starts rolling back the current application upgrade to the previous version. This API can only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling back to a previous version.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564663 = newJObject()
  var query_564664 = newJObject()
  add(query_564664, "api-version", newJString(apiVersion))
  add(query_564664, "timeout", newJInt(timeout))
  add(path_564663, "applicationId", newJString(applicationId))
  result = call_564662.call(path_564663, query_564664, nil, nil, nil)

var rollbackApplicationUpgrade* = Call_RollbackApplicationUpgrade_564655(
    name: "rollbackApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/RollbackUpgrade",
    validator: validate_RollbackApplicationUpgrade_564656, base: "",
    url: url_RollbackApplicationUpgrade_564657,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateApplicationUpgrade_564665 = ref object of OpenApiRestCall_563565
proc url_UpdateApplicationUpgrade_564667(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/UpdateUpgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateApplicationUpgrade_564666(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564668 = path.getOrDefault("applicationId")
  valid_564668 = validateParameter(valid_564668, JString, required = true,
                                 default = nil)
  if valid_564668 != nil:
    section.add "applicationId", valid_564668
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564669 = query.getOrDefault("api-version")
  valid_564669 = validateParameter(valid_564669, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564669 != nil:
    section.add "api-version", valid_564669
  var valid_564670 = query.getOrDefault("timeout")
  valid_564670 = validateParameter(valid_564670, JInt, required = false,
                                 default = newJInt(60))
  if valid_564670 != nil:
    section.add "timeout", valid_564670
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564672: Call_UpdateApplicationUpgrade_564665; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ## 
  let valid = call_564672.validator(path, query, header, formData, body)
  let scheme = call_564672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564672.url(scheme.get, call_564672.host, call_564672.base,
                         call_564672.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564672, url, valid)

proc call*(call_564673: Call_UpdateApplicationUpgrade_564665;
          ApplicationUpgradeUpdateDescription: JsonNode; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## updateApplicationUpgrade
  ## Updates the parameters of an ongoing application upgrade from the ones specified at the time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to incorrect parameters or issues in the application to make progress.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ApplicationUpgradeUpdateDescription: JObject (required)
  ##                                      : Parameters for updating an existing application upgrade.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564674 = newJObject()
  var query_564675 = newJObject()
  var body_564676 = newJObject()
  add(query_564675, "api-version", newJString(apiVersion))
  if ApplicationUpgradeUpdateDescription != nil:
    body_564676 = ApplicationUpgradeUpdateDescription
  add(query_564675, "timeout", newJInt(timeout))
  add(path_564674, "applicationId", newJString(applicationId))
  result = call_564673.call(path_564674, query_564675, nil, nil, body_564676)

var updateApplicationUpgrade* = Call_UpdateApplicationUpgrade_564665(
    name: "updateApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Applications/{applicationId}/$/UpdateUpgrade",
    validator: validate_UpdateApplicationUpgrade_564666, base: "",
    url: url_UpdateApplicationUpgrade_564667, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartApplicationUpgrade_564677 = ref object of OpenApiRestCall_563565
proc url_StartApplicationUpgrade_564679(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Applications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartApplicationUpgrade_564678(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `applicationId` field"
  var valid_564680 = path.getOrDefault("applicationId")
  valid_564680 = validateParameter(valid_564680, JString, required = true,
                                 default = nil)
  if valid_564680 != nil:
    section.add "applicationId", valid_564680
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564681 = query.getOrDefault("api-version")
  valid_564681 = validateParameter(valid_564681, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564681 != nil:
    section.add "api-version", valid_564681
  var valid_564682 = query.getOrDefault("timeout")
  valid_564682 = validateParameter(valid_564682, JInt, required = false,
                                 default = newJInt(60))
  if valid_564682 != nil:
    section.add "timeout", valid_564682
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564684: Call_StartApplicationUpgrade_564677; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ## 
  let valid = call_564684.validator(path, query, header, formData, body)
  let scheme = call_564684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564684.url(scheme.get, call_564684.host, call_564684.base,
                         call_564684.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564684, url, valid)

proc call*(call_564685: Call_StartApplicationUpgrade_564677;
          ApplicationUpgradeDescription: JsonNode; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## startApplicationUpgrade
  ## Validates the supplied application upgrade parameters and starts upgrading the application if the parameters are valid.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ApplicationUpgradeDescription: JObject (required)
  ##                                : Parameters for an application upgrade.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_564686 = newJObject()
  var query_564687 = newJObject()
  var body_564688 = newJObject()
  add(query_564687, "api-version", newJString(apiVersion))
  add(query_564687, "timeout", newJInt(timeout))
  if ApplicationUpgradeDescription != nil:
    body_564688 = ApplicationUpgradeDescription
  add(path_564686, "applicationId", newJString(applicationId))
  result = call_564685.call(path_564686, query_564687, nil, nil, body_564688)

var startApplicationUpgrade* = Call_StartApplicationUpgrade_564677(
    name: "startApplicationUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Applications/{applicationId}/$/Upgrade",
    validator: validate_StartApplicationUpgrade_564678, base: "",
    url: url_StartApplicationUpgrade_564679, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatusList_564689 = ref object of OpenApiRestCall_563565
proc url_GetComposeDeploymentStatusList_564691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetComposeDeploymentStatusList_564690(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: JInt
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_564692 = query.getOrDefault("ContinuationToken")
  valid_564692 = validateParameter(valid_564692, JString, required = false,
                                 default = nil)
  if valid_564692 != nil:
    section.add "ContinuationToken", valid_564692
  var valid_564693 = query.getOrDefault("MaxResults")
  valid_564693 = validateParameter(valid_564693, JInt, required = false,
                                 default = newJInt(0))
  if valid_564693 != nil:
    section.add "MaxResults", valid_564693
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564694 = query.getOrDefault("api-version")
  valid_564694 = validateParameter(valid_564694, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564694 != nil:
    section.add "api-version", valid_564694
  var valid_564695 = query.getOrDefault("timeout")
  valid_564695 = validateParameter(valid_564695, JInt, required = false,
                                 default = newJInt(60))
  if valid_564695 != nil:
    section.add "timeout", valid_564695
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564696: Call_GetComposeDeploymentStatusList_564689; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ## 
  let valid = call_564696.validator(path, query, header, formData, body)
  let scheme = call_564696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564696.url(scheme.get, call_564696.host, call_564696.base,
                         call_564696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564696, url, valid)

proc call*(call_564697: Call_GetComposeDeploymentStatusList_564689;
          ContinuationToken: string = ""; MaxResults: int = 0;
          apiVersion: string = "6.0-preview"; timeout: int = 60): Recallable =
  ## getComposeDeploymentStatusList
  ## Gets the status about the compose deployments that were created or in the process of being created in the Service Fabric cluster. The response includes the name, status and other details about the compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   MaxResults: int
  ##             : The maximum number of results to be returned as part of the paged queries. This parameter defines the upper bound on the number of results returned. The results returned can be less than the specified maximum results if they do not fit in the message as per the max message size restrictions defined in the configuration. If this parameter is zero or not specified, the paged queries includes as much results as possible that fit in the return message.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564698 = newJObject()
  add(query_564698, "ContinuationToken", newJString(ContinuationToken))
  add(query_564698, "MaxResults", newJInt(MaxResults))
  add(query_564698, "api-version", newJString(apiVersion))
  add(query_564698, "timeout", newJInt(timeout))
  result = call_564697.call(nil, query_564698, nil, nil, nil)

var getComposeDeploymentStatusList* = Call_GetComposeDeploymentStatusList_564689(
    name: "getComposeDeploymentStatusList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments",
    validator: validate_GetComposeDeploymentStatusList_564690, base: "",
    url: url_GetComposeDeploymentStatusList_564691,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateComposeDeployment_564699 = ref object of OpenApiRestCall_563565
proc url_CreateComposeDeployment_564701(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateComposeDeployment_564700(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564702 = query.getOrDefault("api-version")
  valid_564702 = validateParameter(valid_564702, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564702 != nil:
    section.add "api-version", valid_564702
  var valid_564703 = query.getOrDefault("timeout")
  valid_564703 = validateParameter(valid_564703, JInt, required = false,
                                 default = newJInt(60))
  if valid_564703 != nil:
    section.add "timeout", valid_564703
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564705: Call_CreateComposeDeployment_564699; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a Service Fabric compose deployment.
  ## 
  let valid = call_564705.validator(path, query, header, formData, body)
  let scheme = call_564705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564705.url(scheme.get, call_564705.host, call_564705.base,
                         call_564705.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564705, url, valid)

proc call*(call_564706: Call_CreateComposeDeployment_564699;
          CreateComposeDeploymentDescription: JsonNode;
          apiVersion: string = "6.0-preview"; timeout: int = 60): Recallable =
  ## createComposeDeployment
  ## Creates a Service Fabric compose deployment.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   CreateComposeDeploymentDescription: JObject (required)
  ##                                     : Describes the compose deployment that needs to be created.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564707 = newJObject()
  var body_564708 = newJObject()
  add(query_564707, "api-version", newJString(apiVersion))
  if CreateComposeDeploymentDescription != nil:
    body_564708 = CreateComposeDeploymentDescription
  add(query_564707, "timeout", newJInt(timeout))
  result = call_564706.call(nil, query_564707, nil, nil, body_564708)

var createComposeDeployment* = Call_CreateComposeDeployment_564699(
    name: "createComposeDeployment", meth: HttpMethod.HttpPut,
    host: "azure.local:19080", route: "/ComposeDeployments/$/Create",
    validator: validate_CreateComposeDeployment_564700, base: "",
    url: url_CreateComposeDeployment_564701, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentStatus_564709 = ref object of OpenApiRestCall_563565
proc url_GetComposeDeploymentStatus_564711(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentStatus_564710(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_564712 = path.getOrDefault("deploymentName")
  valid_564712 = validateParameter(valid_564712, JString, required = true,
                                 default = nil)
  if valid_564712 != nil:
    section.add "deploymentName", valid_564712
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564713 = query.getOrDefault("api-version")
  valid_564713 = validateParameter(valid_564713, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564713 != nil:
    section.add "api-version", valid_564713
  var valid_564714 = query.getOrDefault("timeout")
  valid_564714 = validateParameter(valid_564714, JInt, required = false,
                                 default = newJInt(60))
  if valid_564714 != nil:
    section.add "timeout", valid_564714
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564715: Call_GetComposeDeploymentStatus_564709; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ## 
  let valid = call_564715.validator(path, query, header, formData, body)
  let scheme = call_564715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564715.url(scheme.get, call_564715.host, call_564715.base,
                         call_564715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564715, url, valid)

proc call*(call_564716: Call_GetComposeDeploymentStatus_564709;
          deploymentName: string; apiVersion: string = "6.0-preview";
          timeout: int = 60): Recallable =
  ## getComposeDeploymentStatus
  ## Returns the status of the compose deployment that was created or in the process of being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the name, status and other details about the deployment.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564717 = newJObject()
  var query_564718 = newJObject()
  add(query_564718, "api-version", newJString(apiVersion))
  add(path_564717, "deploymentName", newJString(deploymentName))
  add(query_564718, "timeout", newJInt(timeout))
  result = call_564716.call(path_564717, query_564718, nil, nil, nil)

var getComposeDeploymentStatus* = Call_GetComposeDeploymentStatus_564709(
    name: "getComposeDeploymentStatus", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ComposeDeployments/{deploymentName}",
    validator: validate_GetComposeDeploymentStatus_564710, base: "",
    url: url_GetComposeDeploymentStatus_564711,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveComposeDeployment_564719 = ref object of OpenApiRestCall_563565
proc url_RemoveComposeDeployment_564721(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveComposeDeployment_564720(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_564722 = path.getOrDefault("deploymentName")
  valid_564722 = validateParameter(valid_564722, JString, required = true,
                                 default = nil)
  if valid_564722 != nil:
    section.add "deploymentName", valid_564722
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564723 = query.getOrDefault("api-version")
  valid_564723 = validateParameter(valid_564723, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564723 != nil:
    section.add "api-version", valid_564723
  var valid_564724 = query.getOrDefault("timeout")
  valid_564724 = validateParameter(valid_564724, JInt, required = false,
                                 default = newJInt(60))
  if valid_564724 != nil:
    section.add "timeout", valid_564724
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564725: Call_RemoveComposeDeployment_564719; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric compose deployment.
  ## 
  let valid = call_564725.validator(path, query, header, formData, body)
  let scheme = call_564725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564725.url(scheme.get, call_564725.host, call_564725.base,
                         call_564725.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564725, url, valid)

proc call*(call_564726: Call_RemoveComposeDeployment_564719;
          deploymentName: string; apiVersion: string = "6.0-preview";
          timeout: int = 60): Recallable =
  ## removeComposeDeployment
  ## Deletes an existing Service Fabric compose deployment.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564727 = newJObject()
  var query_564728 = newJObject()
  add(query_564728, "api-version", newJString(apiVersion))
  add(path_564727, "deploymentName", newJString(deploymentName))
  add(query_564728, "timeout", newJInt(timeout))
  result = call_564726.call(path_564727, query_564728, nil, nil, nil)

var removeComposeDeployment* = Call_RemoveComposeDeployment_564719(
    name: "removeComposeDeployment", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Delete",
    validator: validate_RemoveComposeDeployment_564720, base: "",
    url: url_RemoveComposeDeployment_564721, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetComposeDeploymentUpgradeProgress_564729 = ref object of OpenApiRestCall_563565
proc url_GetComposeDeploymentUpgradeProgress_564731(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/GetUpgradeProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetComposeDeploymentUpgradeProgress_564730(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_564732 = path.getOrDefault("deploymentName")
  valid_564732 = validateParameter(valid_564732, JString, required = true,
                                 default = nil)
  if valid_564732 != nil:
    section.add "deploymentName", valid_564732
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564733 = query.getOrDefault("api-version")
  valid_564733 = validateParameter(valid_564733, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564733 != nil:
    section.add "api-version", valid_564733
  var valid_564734 = query.getOrDefault("timeout")
  valid_564734 = validateParameter(valid_564734, JInt, required = false,
                                 default = newJInt(60))
  if valid_564734 != nil:
    section.add "timeout", valid_564734
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564735: Call_GetComposeDeploymentUpgradeProgress_564729;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ## 
  let valid = call_564735.validator(path, query, header, formData, body)
  let scheme = call_564735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564735.url(scheme.get, call_564735.host, call_564735.base,
                         call_564735.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564735, url, valid)

proc call*(call_564736: Call_GetComposeDeploymentUpgradeProgress_564729;
          deploymentName: string; apiVersion: string = "6.0-preview";
          timeout: int = 60): Recallable =
  ## getComposeDeploymentUpgradeProgress
  ## Returns the information about the state of the compose deployment upgrade along with details to aid debugging application health issues.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564737 = newJObject()
  var query_564738 = newJObject()
  add(query_564738, "api-version", newJString(apiVersion))
  add(path_564737, "deploymentName", newJString(deploymentName))
  add(query_564738, "timeout", newJInt(timeout))
  result = call_564736.call(path_564737, query_564738, nil, nil, nil)

var getComposeDeploymentUpgradeProgress* = Call_GetComposeDeploymentUpgradeProgress_564729(
    name: "getComposeDeploymentUpgradeProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/GetUpgradeProgress",
    validator: validate_GetComposeDeploymentUpgradeProgress_564730, base: "",
    url: url_GetComposeDeploymentUpgradeProgress_564731,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartComposeDeploymentUpgrade_564739 = ref object of OpenApiRestCall_563565
proc url_StartComposeDeploymentUpgrade_564741(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "deploymentName" in path, "`deploymentName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ComposeDeployments/"),
               (kind: VariableSegment, value: "deploymentName"),
               (kind: ConstantSegment, value: "/$/Upgrade")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartComposeDeploymentUpgrade_564740(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   deploymentName: JString (required)
  ##                 : The identity of the deployment.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `deploymentName` field"
  var valid_564742 = path.getOrDefault("deploymentName")
  valid_564742 = validateParameter(valid_564742, JString, required = true,
                                 default = nil)
  if valid_564742 != nil:
    section.add "deploymentName", valid_564742
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564743 = query.getOrDefault("api-version")
  valid_564743 = validateParameter(valid_564743, JString, required = true,
                                 default = newJString("6.0-preview"))
  if valid_564743 != nil:
    section.add "api-version", valid_564743
  var valid_564744 = query.getOrDefault("timeout")
  valid_564744 = validateParameter(valid_564744, JInt, required = false,
                                 default = newJInt(60))
  if valid_564744 != nil:
    section.add "timeout", valid_564744
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564746: Call_StartComposeDeploymentUpgrade_564739; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ## 
  let valid = call_564746.validator(path, query, header, formData, body)
  let scheme = call_564746.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564746.url(scheme.get, call_564746.host, call_564746.base,
                         call_564746.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564746, url, valid)

proc call*(call_564747: Call_StartComposeDeploymentUpgrade_564739;
          deploymentName: string; ComposeDeploymentUpgradeDescription: JsonNode;
          apiVersion: string = "6.0-preview"; timeout: int = 60): Recallable =
  ## startComposeDeploymentUpgrade
  ## Validates the supplied upgrade parameters and starts upgrading the deployment if the parameters are valid.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and its value must be "6.0-preview".
  ##   deploymentName: string (required)
  ##                 : The identity of the deployment.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ComposeDeploymentUpgradeDescription: JObject (required)
  ##                                      : Parameters for upgrading compose deployment.
  var path_564748 = newJObject()
  var query_564749 = newJObject()
  var body_564750 = newJObject()
  add(query_564749, "api-version", newJString(apiVersion))
  add(path_564748, "deploymentName", newJString(deploymentName))
  add(query_564749, "timeout", newJInt(timeout))
  if ComposeDeploymentUpgradeDescription != nil:
    body_564750 = ComposeDeploymentUpgradeDescription
  result = call_564747.call(path_564748, query_564749, nil, nil, body_564750)

var startComposeDeploymentUpgrade* = Call_StartComposeDeploymentUpgrade_564739(
    name: "startComposeDeploymentUpgrade", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/ComposeDeployments/{deploymentName}/$/Upgrade",
    validator: validate_StartComposeDeploymentUpgrade_564740, base: "",
    url: url_StartComposeDeploymentUpgrade_564741,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetFaultOperationList_564751 = ref object of OpenApiRestCall_563565
proc url_GetFaultOperationList_564753(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetFaultOperationList_564752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   TypeFilter: JInt (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: JInt (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564754 = query.getOrDefault("api-version")
  valid_564754 = validateParameter(valid_564754, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564754 != nil:
    section.add "api-version", valid_564754
  var valid_564755 = query.getOrDefault("timeout")
  valid_564755 = validateParameter(valid_564755, JInt, required = false,
                                 default = newJInt(60))
  if valid_564755 != nil:
    section.add "timeout", valid_564755
  var valid_564756 = query.getOrDefault("TypeFilter")
  valid_564756 = validateParameter(valid_564756, JInt, required = true,
                                 default = newJInt(65535))
  if valid_564756 != nil:
    section.add "TypeFilter", valid_564756
  var valid_564757 = query.getOrDefault("StateFilter")
  valid_564757 = validateParameter(valid_564757, JInt, required = true,
                                 default = newJInt(65535))
  if valid_564757 != nil:
    section.add "StateFilter", valid_564757
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564758: Call_GetFaultOperationList_564751; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ## 
  let valid = call_564758.validator(path, query, header, formData, body)
  let scheme = call_564758.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564758.url(scheme.get, call_564758.host, call_564758.base,
                         call_564758.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564758, url, valid)

proc call*(call_564759: Call_GetFaultOperationList_564751;
          apiVersion: string = "6.0"; timeout: int = 60; TypeFilter: int = 65535;
          StateFilter: int = 65535): Recallable =
  ## getFaultOperationList
  ## Gets the a list of user-induced fault operations filtered by provided input.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   TypeFilter: int (required)
  ##             : Used to filter on OperationType for user-induced operations.
  ## 65535 - select all
  ## 1     - select PartitionDataLoss.
  ## 2     - select PartitionQuorumLoss.
  ## 4     - select PartitionRestart.
  ## 8     - select NodeTransition.
  ## 
  ##   StateFilter: int (required)
  ##              : Used to filter on OperationState's for user-induced operations.
  ## 65535 - select All
  ## 1     - select Running
  ## 2     - select RollingBack
  ## 8     - select Completed
  ## 16    - select Faulted
  ## 32    - select Cancelled
  ## 64    - select ForceCancelled
  ## 
  var query_564760 = newJObject()
  add(query_564760, "api-version", newJString(apiVersion))
  add(query_564760, "timeout", newJInt(timeout))
  add(query_564760, "TypeFilter", newJInt(TypeFilter))
  add(query_564760, "StateFilter", newJInt(StateFilter))
  result = call_564759.call(nil, query_564760, nil, nil, nil)

var getFaultOperationList* = Call_GetFaultOperationList_564751(
    name: "getFaultOperationList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/",
    validator: validate_GetFaultOperationList_564752, base: "",
    url: url_GetFaultOperationList_564753, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CancelOperation_564761 = ref object of OpenApiRestCall_563565
proc url_CancelOperation_564763(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CancelOperation_564762(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Force: JBool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564764 = query.getOrDefault("OperationId")
  valid_564764 = validateParameter(valid_564764, JString, required = true,
                                 default = nil)
  if valid_564764 != nil:
    section.add "OperationId", valid_564764
  var valid_564765 = query.getOrDefault("api-version")
  valid_564765 = validateParameter(valid_564765, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564765 != nil:
    section.add "api-version", valid_564765
  var valid_564766 = query.getOrDefault("Force")
  valid_564766 = validateParameter(valid_564766, JBool, required = true,
                                 default = newJBool(false))
  if valid_564766 != nil:
    section.add "Force", valid_564766
  var valid_564767 = query.getOrDefault("timeout")
  valid_564767 = validateParameter(valid_564767, JInt, required = false,
                                 default = newJInt(60))
  if valid_564767 != nil:
    section.add "timeout", valid_564767
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564768: Call_CancelOperation_564761; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ## 
  let valid = call_564768.validator(path, query, header, formData, body)
  let scheme = call_564768.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564768.url(scheme.get, call_564768.host, call_564768.base,
                         call_564768.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564768, url, valid)

proc call*(call_564769: Call_CancelOperation_564761; OperationId: string;
          apiVersion: string = "6.0"; Force: bool = false; timeout: int = 60): Recallable =
  ## cancelOperation
  ## The following is a list of APIs that start fault operations that may be cancelled using CancelOperation -
  ## - StartDataLoss
  ## - StartQuorumLoss
  ## - StartPartitionRestart
  ## - StartNodeTransition
  ## 
  ## If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is true, the command will be aborted, and some internal state
  ## may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is not allowed until this API has already
  ## been called on the same test command with force set to false first, or unless the test command already has an OperationState of OperationState.RollingBack.
  ## Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused by executing the command.  It will not restore data if the
  ## test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will only clean up internal state from running the command.
  ## It will not restore the target partition's data, if the command progressed far enough to cause data loss.
  ## 
  ## Important note:  if this API is invoked with force==true, internal state may be left behind.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   Force: bool (required)
  ##        : Indicates whether to gracefully rollback and clean up internal system state modified by executing the user-induced operation.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564770 = newJObject()
  add(query_564770, "OperationId", newJString(OperationId))
  add(query_564770, "api-version", newJString(apiVersion))
  add(query_564770, "Force", newJBool(Force))
  add(query_564770, "timeout", newJInt(timeout))
  result = call_564769.call(nil, query_564770, nil, nil, nil)

var cancelOperation* = Call_CancelOperation_564761(name: "cancelOperation",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/$/Cancel",
    validator: validate_CancelOperation_564762, base: "", url: url_CancelOperation_564763,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeTransitionProgress_564771 = ref object of OpenApiRestCall_563565
proc url_GetNodeTransitionProgress_564773(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetTransitionProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeTransitionProgress_564772(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_564774 = path.getOrDefault("nodeName")
  valid_564774 = validateParameter(valid_564774, JString, required = true,
                                 default = nil)
  if valid_564774 != nil:
    section.add "nodeName", valid_564774
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564775 = query.getOrDefault("OperationId")
  valid_564775 = validateParameter(valid_564775, JString, required = true,
                                 default = nil)
  if valid_564775 != nil:
    section.add "OperationId", valid_564775
  var valid_564776 = query.getOrDefault("api-version")
  valid_564776 = validateParameter(valid_564776, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564776 != nil:
    section.add "api-version", valid_564776
  var valid_564777 = query.getOrDefault("timeout")
  valid_564777 = validateParameter(valid_564777, JInt, required = false,
                                 default = newJInt(60))
  if valid_564777 != nil:
    section.add "timeout", valid_564777
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564778: Call_GetNodeTransitionProgress_564771; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ## 
  let valid = call_564778.validator(path, query, header, formData, body)
  let scheme = call_564778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564778.url(scheme.get, call_564778.host, call_564778.base,
                         call_564778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564778, url, valid)

proc call*(call_564779: Call_GetNodeTransitionProgress_564771; OperationId: string;
          nodeName: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getNodeTransitionProgress
  ## Gets the progress of an operation started with StartNodeTransition using the provided OperationId.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_564780 = newJObject()
  var query_564781 = newJObject()
  add(query_564781, "OperationId", newJString(OperationId))
  add(query_564781, "api-version", newJString(apiVersion))
  add(query_564781, "timeout", newJInt(timeout))
  add(path_564780, "nodeName", newJString(nodeName))
  result = call_564779.call(path_564780, query_564781, nil, nil, nil)

var getNodeTransitionProgress* = Call_GetNodeTransitionProgress_564771(
    name: "getNodeTransitionProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/GetTransitionProgress",
    validator: validate_GetNodeTransitionProgress_564772, base: "",
    url: url_GetNodeTransitionProgress_564773,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartNodeTransition_564782 = ref object of OpenApiRestCall_563565
proc url_StartNodeTransition_564784(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/StartTransition/")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartNodeTransition_564783(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_564785 = path.getOrDefault("nodeName")
  valid_564785 = validateParameter(valid_564785, JString, required = true,
                                 default = nil)
  if valid_564785 != nil:
    section.add "nodeName", valid_564785
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   NodeInstanceId: JString (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StopDurationInSeconds: JInt (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   NodeTransitionType: JString (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564786 = query.getOrDefault("OperationId")
  valid_564786 = validateParameter(valid_564786, JString, required = true,
                                 default = nil)
  if valid_564786 != nil:
    section.add "OperationId", valid_564786
  var valid_564787 = query.getOrDefault("NodeInstanceId")
  valid_564787 = validateParameter(valid_564787, JString, required = true,
                                 default = nil)
  if valid_564787 != nil:
    section.add "NodeInstanceId", valid_564787
  var valid_564788 = query.getOrDefault("api-version")
  valid_564788 = validateParameter(valid_564788, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564788 != nil:
    section.add "api-version", valid_564788
  var valid_564789 = query.getOrDefault("StopDurationInSeconds")
  valid_564789 = validateParameter(valid_564789, JInt, required = true, default = nil)
  if valid_564789 != nil:
    section.add "StopDurationInSeconds", valid_564789
  var valid_564790 = query.getOrDefault("timeout")
  valid_564790 = validateParameter(valid_564790, JInt, required = false,
                                 default = newJInt(60))
  if valid_564790 != nil:
    section.add "timeout", valid_564790
  var valid_564791 = query.getOrDefault("NodeTransitionType")
  valid_564791 = validateParameter(valid_564791, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_564791 != nil:
    section.add "NodeTransitionType", valid_564791
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564792: Call_StartNodeTransition_564782; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ## 
  let valid = call_564792.validator(path, query, header, formData, body)
  let scheme = call_564792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564792.url(scheme.get, call_564792.host, call_564792.base,
                         call_564792.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564792, url, valid)

proc call*(call_564793: Call_StartNodeTransition_564782; OperationId: string;
          NodeInstanceId: string; StopDurationInSeconds: int; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          NodeTransitionType: string = "Invalid"): Recallable =
  ## startNodeTransition
  ## Starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To start a node, pass in "Start" for the NodeTransitionType parameter.
  ## To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API returns the node may not have finished transitioning yet.
  ## Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   NodeInstanceId: string (required)
  ##                 : The node instance ID of the target node.  This can be determined through GetNodeInfo API.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   StopDurationInSeconds: int (required)
  ##                        : The duration, in seconds, to keep the node stopped.  The minimum value is 600, the maximum is 14400.  After this time expires, the node will automatically come back up.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   NodeTransitionType: string (required)
  ##                     : Indicates the type of transition to perform.  NodeTransitionType.Start will start a stopped node.  NodeTransitionType.Stop will stop a node that is up.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - Start - Transition a stopped node to up.
  ##   - Stop - Transition an up node to stopped.
  ## 
  var path_564794 = newJObject()
  var query_564795 = newJObject()
  add(query_564795, "OperationId", newJString(OperationId))
  add(query_564795, "NodeInstanceId", newJString(NodeInstanceId))
  add(query_564795, "api-version", newJString(apiVersion))
  add(query_564795, "StopDurationInSeconds", newJInt(StopDurationInSeconds))
  add(query_564795, "timeout", newJInt(timeout))
  add(path_564794, "nodeName", newJString(nodeName))
  add(query_564795, "NodeTransitionType", newJString(NodeTransitionType))
  result = call_564793.call(path_564794, query_564795, nil, nil, nil)

var startNodeTransition* = Call_StartNodeTransition_564782(
    name: "startNodeTransition", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Faults/Nodes/{nodeName}/$/StartTransition/",
    validator: validate_StartNodeTransition_564783, base: "",
    url: url_StartNodeTransition_564784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDataLossProgress_564796 = ref object of OpenApiRestCall_563565
proc url_GetDataLossProgress_564798(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetDataLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDataLossProgress_564797(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564799 = path.getOrDefault("partitionId")
  valid_564799 = validateParameter(valid_564799, JString, required = true,
                                 default = nil)
  if valid_564799 != nil:
    section.add "partitionId", valid_564799
  var valid_564800 = path.getOrDefault("serviceId")
  valid_564800 = validateParameter(valid_564800, JString, required = true,
                                 default = nil)
  if valid_564800 != nil:
    section.add "serviceId", valid_564800
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564801 = query.getOrDefault("OperationId")
  valid_564801 = validateParameter(valid_564801, JString, required = true,
                                 default = nil)
  if valid_564801 != nil:
    section.add "OperationId", valid_564801
  var valid_564802 = query.getOrDefault("api-version")
  valid_564802 = validateParameter(valid_564802, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564802 != nil:
    section.add "api-version", valid_564802
  var valid_564803 = query.getOrDefault("timeout")
  valid_564803 = validateParameter(valid_564803, JInt, required = false,
                                 default = newJInt(60))
  if valid_564803 != nil:
    section.add "timeout", valid_564803
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564804: Call_GetDataLossProgress_564796; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ## 
  let valid = call_564804.validator(path, query, header, formData, body)
  let scheme = call_564804.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564804.url(scheme.get, call_564804.host, call_564804.base,
                         call_564804.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564804, url, valid)

proc call*(call_564805: Call_GetDataLossProgress_564796; OperationId: string;
          partitionId: string; serviceId: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getDataLossProgress
  ## Gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_564806 = newJObject()
  var query_564807 = newJObject()
  add(query_564807, "OperationId", newJString(OperationId))
  add(query_564807, "api-version", newJString(apiVersion))
  add(query_564807, "timeout", newJInt(timeout))
  add(path_564806, "partitionId", newJString(partitionId))
  add(path_564806, "serviceId", newJString(serviceId))
  result = call_564805.call(path_564806, query_564807, nil, nil, nil)

var getDataLossProgress* = Call_GetDataLossProgress_564796(
    name: "getDataLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress",
    validator: validate_GetDataLossProgress_564797, base: "",
    url: url_GetDataLossProgress_564798, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetQuorumLossProgress_564808 = ref object of OpenApiRestCall_563565
proc url_GetQuorumLossProgress_564810(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetQuorumLossProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetQuorumLossProgress_564809(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564811 = path.getOrDefault("partitionId")
  valid_564811 = validateParameter(valid_564811, JString, required = true,
                                 default = nil)
  if valid_564811 != nil:
    section.add "partitionId", valid_564811
  var valid_564812 = path.getOrDefault("serviceId")
  valid_564812 = validateParameter(valid_564812, JString, required = true,
                                 default = nil)
  if valid_564812 != nil:
    section.add "serviceId", valid_564812
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564813 = query.getOrDefault("OperationId")
  valid_564813 = validateParameter(valid_564813, JString, required = true,
                                 default = nil)
  if valid_564813 != nil:
    section.add "OperationId", valid_564813
  var valid_564814 = query.getOrDefault("api-version")
  valid_564814 = validateParameter(valid_564814, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564814 != nil:
    section.add "api-version", valid_564814
  var valid_564815 = query.getOrDefault("timeout")
  valid_564815 = validateParameter(valid_564815, JInt, required = false,
                                 default = newJInt(60))
  if valid_564815 != nil:
    section.add "timeout", valid_564815
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564816: Call_GetQuorumLossProgress_564808; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ## 
  let valid = call_564816.validator(path, query, header, formData, body)
  let scheme = call_564816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564816.url(scheme.get, call_564816.host, call_564816.base,
                         call_564816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564816, url, valid)

proc call*(call_564817: Call_GetQuorumLossProgress_564808; OperationId: string;
          partitionId: string; serviceId: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getQuorumLossProgress
  ## Gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided OperationId.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_564818 = newJObject()
  var query_564819 = newJObject()
  add(query_564819, "OperationId", newJString(OperationId))
  add(query_564819, "api-version", newJString(apiVersion))
  add(query_564819, "timeout", newJInt(timeout))
  add(path_564818, "partitionId", newJString(partitionId))
  add(path_564818, "serviceId", newJString(serviceId))
  result = call_564817.call(path_564818, query_564819, nil, nil, nil)

var getQuorumLossProgress* = Call_GetQuorumLossProgress_564808(
    name: "getQuorumLossProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress",
    validator: validate_GetQuorumLossProgress_564809, base: "",
    url: url_GetQuorumLossProgress_564810, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionRestartProgress_564820 = ref object of OpenApiRestCall_563565
proc url_GetPartitionRestartProgress_564822(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetRestartProgress")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionRestartProgress_564821(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564823 = path.getOrDefault("partitionId")
  valid_564823 = validateParameter(valid_564823, JString, required = true,
                                 default = nil)
  if valid_564823 != nil:
    section.add "partitionId", valid_564823
  var valid_564824 = path.getOrDefault("serviceId")
  valid_564824 = validateParameter(valid_564824, JString, required = true,
                                 default = nil)
  if valid_564824 != nil:
    section.add "serviceId", valid_564824
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564825 = query.getOrDefault("OperationId")
  valid_564825 = validateParameter(valid_564825, JString, required = true,
                                 default = nil)
  if valid_564825 != nil:
    section.add "OperationId", valid_564825
  var valid_564826 = query.getOrDefault("api-version")
  valid_564826 = validateParameter(valid_564826, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564826 != nil:
    section.add "api-version", valid_564826
  var valid_564827 = query.getOrDefault("timeout")
  valid_564827 = validateParameter(valid_564827, JInt, required = false,
                                 default = newJInt(60))
  if valid_564827 != nil:
    section.add "timeout", valid_564827
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564828: Call_GetPartitionRestartProgress_564820; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ## 
  let valid = call_564828.validator(path, query, header, formData, body)
  let scheme = call_564828.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564828.url(scheme.get, call_564828.host, call_564828.base,
                         call_564828.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564828, url, valid)

proc call*(call_564829: Call_GetPartitionRestartProgress_564820;
          OperationId: string; partitionId: string; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getPartitionRestartProgress
  ## Gets the progress of a PartitionRestart started with StartPartitionRestart using the provided OperationId.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_564830 = newJObject()
  var query_564831 = newJObject()
  add(query_564831, "OperationId", newJString(OperationId))
  add(query_564831, "api-version", newJString(apiVersion))
  add(query_564831, "timeout", newJInt(timeout))
  add(path_564830, "partitionId", newJString(partitionId))
  add(path_564830, "serviceId", newJString(serviceId))
  result = call_564829.call(path_564830, query_564831, nil, nil, nil)

var getPartitionRestartProgress* = Call_GetPartitionRestartProgress_564820(
    name: "getPartitionRestartProgress", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress",
    validator: validate_GetPartitionRestartProgress_564821, base: "",
    url: url_GetPartitionRestartProgress_564822,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartDataLoss_564832 = ref object of OpenApiRestCall_563565
proc url_StartDataLoss_564834(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartDataLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartDataLoss_564833(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564835 = path.getOrDefault("partitionId")
  valid_564835 = validateParameter(valid_564835, JString, required = true,
                                 default = nil)
  if valid_564835 != nil:
    section.add "partitionId", valid_564835
  var valid_564836 = path.getOrDefault("serviceId")
  valid_564836 = validateParameter(valid_564836, JString, required = true,
                                 default = nil)
  if valid_564836 != nil:
    section.add "serviceId", valid_564836
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   DataLossMode: JString (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564837 = query.getOrDefault("OperationId")
  valid_564837 = validateParameter(valid_564837, JString, required = true,
                                 default = nil)
  if valid_564837 != nil:
    section.add "OperationId", valid_564837
  var valid_564838 = query.getOrDefault("DataLossMode")
  valid_564838 = validateParameter(valid_564838, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_564838 != nil:
    section.add "DataLossMode", valid_564838
  var valid_564839 = query.getOrDefault("api-version")
  valid_564839 = validateParameter(valid_564839, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564839 != nil:
    section.add "api-version", valid_564839
  var valid_564840 = query.getOrDefault("timeout")
  valid_564840 = validateParameter(valid_564840, JInt, required = false,
                                 default = newJInt(60))
  if valid_564840 != nil:
    section.add "timeout", valid_564840
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564841: Call_StartDataLoss_564832; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## 
  let valid = call_564841.validator(path, query, header, formData, body)
  let scheme = call_564841.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564841.url(scheme.get, call_564841.host, call_564841.base,
                         call_564841.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564841, url, valid)

proc call*(call_564842: Call_StartDataLoss_564832; OperationId: string;
          partitionId: string; serviceId: string; DataLossMode: string = "Invalid";
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## startDataLoss
  ## This API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss API of the partition.
  ## Actual data loss will depend on the specified DataLossMode
  ## PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual data loss depends on the presence of in-flight replication.
  ## FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
  ## 
  ## This API should only be called with a stateful service as the target.
  ## 
  ## Calling this API with a system service as the target is not advised.
  ## 
  ## Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and clean up internal system state.
  ## It will not restore data if the command has progressed far enough to cause data loss.
  ## 
  ## Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   DataLossMode: string (required)
  ##               : This enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
  ## - Invalid - Reserved.  Do not pass into API.
  ## - PartialDataLoss - PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss event in the system for the given partition.
  ## - FullDataLoss - FullDataLoss option will drop all the replicas which means that all the data will be lost.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_564843 = newJObject()
  var query_564844 = newJObject()
  add(query_564844, "OperationId", newJString(OperationId))
  add(query_564844, "DataLossMode", newJString(DataLossMode))
  add(query_564844, "api-version", newJString(apiVersion))
  add(query_564844, "timeout", newJInt(timeout))
  add(path_564843, "partitionId", newJString(partitionId))
  add(path_564843, "serviceId", newJString(serviceId))
  result = call_564842.call(path_564843, query_564844, nil, nil, nil)

var startDataLoss* = Call_StartDataLoss_564832(name: "startDataLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss",
    validator: validate_StartDataLoss_564833, base: "", url: url_StartDataLoss_564834,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartQuorumLoss_564845 = ref object of OpenApiRestCall_563565
proc url_StartQuorumLoss_564847(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartQuorumLoss")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartQuorumLoss_564846(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564848 = path.getOrDefault("partitionId")
  valid_564848 = validateParameter(valid_564848, JString, required = true,
                                 default = nil)
  if valid_564848 != nil:
    section.add "partitionId", valid_564848
  var valid_564849 = path.getOrDefault("serviceId")
  valid_564849 = validateParameter(valid_564849, JString, required = true,
                                 default = nil)
  if valid_564849 != nil:
    section.add "serviceId", valid_564849
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   QuorumLossDuration: JInt (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   QuorumLossMode: JString (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564850 = query.getOrDefault("OperationId")
  valid_564850 = validateParameter(valid_564850, JString, required = true,
                                 default = nil)
  if valid_564850 != nil:
    section.add "OperationId", valid_564850
  var valid_564851 = query.getOrDefault("api-version")
  valid_564851 = validateParameter(valid_564851, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564851 != nil:
    section.add "api-version", valid_564851
  var valid_564852 = query.getOrDefault("timeout")
  valid_564852 = validateParameter(valid_564852, JInt, required = false,
                                 default = newJInt(60))
  if valid_564852 != nil:
    section.add "timeout", valid_564852
  var valid_564853 = query.getOrDefault("QuorumLossDuration")
  valid_564853 = validateParameter(valid_564853, JInt, required = true, default = nil)
  if valid_564853 != nil:
    section.add "QuorumLossDuration", valid_564853
  var valid_564854 = query.getOrDefault("QuorumLossMode")
  valid_564854 = validateParameter(valid_564854, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_564854 != nil:
    section.add "QuorumLossMode", valid_564854
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564855: Call_StartQuorumLoss_564845; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ## 
  let valid = call_564855.validator(path, query, header, formData, body)
  let scheme = call_564855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564855.url(scheme.get, call_564855.host, call_564855.base,
                         call_564855.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564855, url, valid)

proc call*(call_564856: Call_StartQuorumLoss_564845; OperationId: string;
          partitionId: string; QuorumLossDuration: int; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          QuorumLossMode: string = "Invalid"): Recallable =
  ## startQuorumLoss
  ## Induces quorum loss for a given stateful service partition.  This API is useful for a temporary quorum loss situation on your service.
  ## 
  ## Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with this API.
  ## 
  ## This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless services or stateful in-memory only services.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   QuorumLossDuration: int (required)
  ##                     : The amount of time for which the partition will be kept in quorum loss.  This must be specified in seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   QuorumLossMode: string (required)
  ##                 : This enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to induce.
  ##   - Invalid - Reserved.  Do not pass into API.
  ##   - QuorumReplicas - Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will cause a quorum loss.
  ##   - AllReplicas- Full Quorum loss mode : All replicas for a partition will be down that will cause a quorum loss.
  ## 
  var path_564857 = newJObject()
  var query_564858 = newJObject()
  add(query_564858, "OperationId", newJString(OperationId))
  add(query_564858, "api-version", newJString(apiVersion))
  add(query_564858, "timeout", newJInt(timeout))
  add(path_564857, "partitionId", newJString(partitionId))
  add(query_564858, "QuorumLossDuration", newJInt(QuorumLossDuration))
  add(path_564857, "serviceId", newJString(serviceId))
  add(query_564858, "QuorumLossMode", newJString(QuorumLossMode))
  result = call_564856.call(path_564857, query_564858, nil, nil, nil)

var startQuorumLoss* = Call_StartQuorumLoss_564845(name: "startQuorumLoss",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss",
    validator: validate_StartQuorumLoss_564846, base: "", url: url_StartQuorumLoss_564847,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartPartitionRestart_564859 = ref object of OpenApiRestCall_563565
proc url_StartPartitionRestart_564861(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Faults/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/StartRestart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_StartPartitionRestart_564860(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_564862 = path.getOrDefault("partitionId")
  valid_564862 = validateParameter(valid_564862, JString, required = true,
                                 default = nil)
  if valid_564862 != nil:
    section.add "partitionId", valid_564862
  var valid_564863 = path.getOrDefault("serviceId")
  valid_564863 = validateParameter(valid_564863, JString, required = true,
                                 default = nil)
  if valid_564863 != nil:
    section.add "serviceId", valid_564863
  result.add "path", section
  ## parameters in `query` object:
  ##   OperationId: JString (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: JString (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `OperationId` field"
  var valid_564864 = query.getOrDefault("OperationId")
  valid_564864 = validateParameter(valid_564864, JString, required = true,
                                 default = nil)
  if valid_564864 != nil:
    section.add "OperationId", valid_564864
  var valid_564865 = query.getOrDefault("api-version")
  valid_564865 = validateParameter(valid_564865, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564865 != nil:
    section.add "api-version", valid_564865
  var valid_564866 = query.getOrDefault("RestartPartitionMode")
  valid_564866 = validateParameter(valid_564866, JString, required = true,
                                 default = newJString("Invalid"))
  if valid_564866 != nil:
    section.add "RestartPartitionMode", valid_564866
  var valid_564867 = query.getOrDefault("timeout")
  valid_564867 = validateParameter(valid_564867, JInt, required = false,
                                 default = newJInt(60))
  if valid_564867 != nil:
    section.add "timeout", valid_564867
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564868: Call_StartPartitionRestart_564859; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ## 
  let valid = call_564868.validator(path, query, header, formData, body)
  let scheme = call_564868.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564868.url(scheme.get, call_564868.host, call_564868.base,
                         call_564868.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564868, url, valid)

proc call*(call_564869: Call_StartPartitionRestart_564859; OperationId: string;
          partitionId: string; serviceId: string; apiVersion: string = "6.0";
          RestartPartitionMode: string = "Invalid"; timeout: int = 60): Recallable =
  ## startPartitionRestart
  ## This API is useful for testing failover.
  ## 
  ## If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
  ## 
  ## Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
  ## 
  ##   OperationId: string (required)
  ##              : A GUID that identifies a call of this API.  This is passed into the corresponding GetProgress API
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   RestartPartitionMode: string (required)
  ##                       : - Invalid - Reserved.  Do not pass into API.
  ## - AllReplicasOrInstances - All replicas or instances in the partition are restarted at once.
  ## - OnlyActiveSecondaries - Only the secondary replicas are restarted.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_564870 = newJObject()
  var query_564871 = newJObject()
  add(query_564871, "OperationId", newJString(OperationId))
  add(query_564871, "api-version", newJString(apiVersion))
  add(query_564871, "RestartPartitionMode", newJString(RestartPartitionMode))
  add(query_564871, "timeout", newJInt(timeout))
  add(path_564870, "partitionId", newJString(partitionId))
  add(path_564870, "serviceId", newJString(serviceId))
  result = call_564869.call(path_564870, query_564871, nil, nil, nil)

var startPartitionRestart* = Call_StartPartitionRestart_564859(
    name: "startPartitionRestart", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart",
    validator: validate_StartPartitionRestart_564860, base: "",
    url: url_StartPartitionRestart_564861, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreRootContent_564872 = ref object of OpenApiRestCall_563565
proc url_GetImageStoreRootContent_564874(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetImageStoreRootContent_564873(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564875 = query.getOrDefault("api-version")
  valid_564875 = validateParameter(valid_564875, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564875 != nil:
    section.add "api-version", valid_564875
  var valid_564876 = query.getOrDefault("timeout")
  valid_564876 = validateParameter(valid_564876, JInt, required = false,
                                 default = newJInt(60))
  if valid_564876 != nil:
    section.add "timeout", valid_564876
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564877: Call_GetImageStoreRootContent_564872; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the root of the image store.
  ## 
  let valid = call_564877.validator(path, query, header, formData, body)
  let scheme = call_564877.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564877.url(scheme.get, call_564877.host, call_564877.base,
                         call_564877.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564877, url, valid)

proc call*(call_564878: Call_GetImageStoreRootContent_564872;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getImageStoreRootContent
  ## Returns the information about the image store content at the root of the image store.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564879 = newJObject()
  add(query_564879, "api-version", newJString(apiVersion))
  add(query_564879, "timeout", newJInt(timeout))
  result = call_564878.call(nil, query_564879, nil, nil, nil)

var getImageStoreRootContent* = Call_GetImageStoreRootContent_564872(
    name: "getImageStoreRootContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore",
    validator: validate_GetImageStoreRootContent_564873, base: "",
    url: url_GetImageStoreRootContent_564874, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CopyImageStoreContent_564880 = ref object of OpenApiRestCall_563565
proc url_CopyImageStoreContent_564882(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CopyImageStoreContent_564881(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564883 = query.getOrDefault("api-version")
  valid_564883 = validateParameter(valid_564883, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564883 != nil:
    section.add "api-version", valid_564883
  var valid_564884 = query.getOrDefault("timeout")
  valid_564884 = validateParameter(valid_564884, JInt, required = false,
                                 default = newJInt(60))
  if valid_564884 != nil:
    section.add "timeout", valid_564884
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564886: Call_CopyImageStoreContent_564880; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ## 
  let valid = call_564886.validator(path, query, header, formData, body)
  let scheme = call_564886.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564886.url(scheme.get, call_564886.host, call_564886.base,
                         call_564886.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564886, url, valid)

proc call*(call_564887: Call_CopyImageStoreContent_564880;
          ImageStoreCopyDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## copyImageStoreContent
  ## Copies the image store content from the source image store relative path to the destination image store relative path.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ImageStoreCopyDescription: JObject (required)
  ##                            : Describes the copy description for the image store.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564888 = newJObject()
  var body_564889 = newJObject()
  add(query_564888, "api-version", newJString(apiVersion))
  if ImageStoreCopyDescription != nil:
    body_564889 = ImageStoreCopyDescription
  add(query_564888, "timeout", newJInt(timeout))
  result = call_564887.call(nil, query_564888, nil, nil, body_564889)

var copyImageStoreContent* = Call_CopyImageStoreContent_564880(
    name: "copyImageStoreContent", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/ImageStore/$/Copy",
    validator: validate_CopyImageStoreContent_564881, base: "",
    url: url_CopyImageStoreContent_564882, schemes: {Scheme.Https, Scheme.Http})
type
  Call_UploadFile_564900 = ref object of OpenApiRestCall_563565
proc url_UploadFile_564902(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UploadFile_564901(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_564903 = path.getOrDefault("contentPath")
  valid_564903 = validateParameter(valid_564903, JString, required = true,
                                 default = nil)
  if valid_564903 != nil:
    section.add "contentPath", valid_564903
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564904 = query.getOrDefault("api-version")
  valid_564904 = validateParameter(valid_564904, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564904 != nil:
    section.add "api-version", valid_564904
  var valid_564905 = query.getOrDefault("timeout")
  valid_564905 = validateParameter(valid_564905, JInt, required = false,
                                 default = newJInt(60))
  if valid_564905 != nil:
    section.add "timeout", valid_564905
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564906: Call_UploadFile_564900; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ## 
  let valid = call_564906.validator(path, query, header, formData, body)
  let scheme = call_564906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564906.url(scheme.get, call_564906.host, call_564906.base,
                         call_564906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564906, url, valid)

proc call*(call_564907: Call_UploadFile_564900; contentPath: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## uploadFile
  ## Uploads contents of the file to the image store. Use this API if the file is small enough to upload again if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it last, to let the image store service know that the folder is complete.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564908 = newJObject()
  var query_564909 = newJObject()
  add(query_564909, "api-version", newJString(apiVersion))
  add(path_564908, "contentPath", newJString(contentPath))
  add(query_564909, "timeout", newJInt(timeout))
  result = call_564907.call(path_564908, query_564909, nil, nil, nil)

var uploadFile* = Call_UploadFile_564900(name: "uploadFile",
                                      meth: HttpMethod.HttpPut,
                                      host: "azure.local:19080",
                                      route: "/ImageStore/{contentPath}",
                                      validator: validate_UploadFile_564901,
                                      base: "", url: url_UploadFile_564902,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetImageStoreContent_564890 = ref object of OpenApiRestCall_563565
proc url_GetImageStoreContent_564892(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetImageStoreContent_564891(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_564893 = path.getOrDefault("contentPath")
  valid_564893 = validateParameter(valid_564893, JString, required = true,
                                 default = nil)
  if valid_564893 != nil:
    section.add "contentPath", valid_564893
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564894 = query.getOrDefault("api-version")
  valid_564894 = validateParameter(valid_564894, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564894 != nil:
    section.add "api-version", valid_564894
  var valid_564895 = query.getOrDefault("timeout")
  valid_564895 = validateParameter(valid_564895, JInt, required = false,
                                 default = newJInt(60))
  if valid_564895 != nil:
    section.add "timeout", valid_564895
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564896: Call_GetImageStoreContent_564890; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ## 
  let valid = call_564896.validator(path, query, header, formData, body)
  let scheme = call_564896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564896.url(scheme.get, call_564896.host, call_564896.base,
                         call_564896.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564896, url, valid)

proc call*(call_564897: Call_GetImageStoreContent_564890; contentPath: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getImageStoreContent
  ## Returns the information about the image store content at the specified contentPath relative to the root of the image store.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564898 = newJObject()
  var query_564899 = newJObject()
  add(query_564899, "api-version", newJString(apiVersion))
  add(path_564898, "contentPath", newJString(contentPath))
  add(query_564899, "timeout", newJInt(timeout))
  result = call_564897.call(path_564898, query_564899, nil, nil, nil)

var getImageStoreContent* = Call_GetImageStoreContent_564890(
    name: "getImageStoreContent", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_GetImageStoreContent_564891, base: "",
    url: url_GetImageStoreContent_564892, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteImageStoreContent_564910 = ref object of OpenApiRestCall_563565
proc url_DeleteImageStoreContent_564912(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "contentPath" in path, "`contentPath` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/ImageStore/"),
               (kind: VariableSegment, value: "contentPath")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteImageStoreContent_564911(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   contentPath: JString (required)
  ##              : Relative path to file or folder in the image store from its root.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `contentPath` field"
  var valid_564913 = path.getOrDefault("contentPath")
  valid_564913 = validateParameter(valid_564913, JString, required = true,
                                 default = nil)
  if valid_564913 != nil:
    section.add "contentPath", valid_564913
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564914 = query.getOrDefault("api-version")
  valid_564914 = validateParameter(valid_564914, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564914 != nil:
    section.add "api-version", valid_564914
  var valid_564915 = query.getOrDefault("timeout")
  valid_564915 = validateParameter(valid_564915, JInt, required = false,
                                 default = newJInt(60))
  if valid_564915 != nil:
    section.add "timeout", valid_564915
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564916: Call_DeleteImageStoreContent_564910; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ## 
  let valid = call_564916.validator(path, query, header, formData, body)
  let scheme = call_564916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564916.url(scheme.get, call_564916.host, call_564916.base,
                         call_564916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564916, url, valid)

proc call*(call_564917: Call_DeleteImageStoreContent_564910; contentPath: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## deleteImageStoreContent
  ## Deletes existing image store content being found within the given image store relative path. This can be used to delete uploaded application packages once they are provisioned.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   contentPath: string (required)
  ##              : Relative path to file or folder in the image store from its root.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var path_564918 = newJObject()
  var query_564919 = newJObject()
  add(query_564919, "api-version", newJString(apiVersion))
  add(path_564918, "contentPath", newJString(contentPath))
  add(query_564919, "timeout", newJInt(timeout))
  result = call_564917.call(path_564918, query_564919, nil, nil, nil)

var deleteImageStoreContent* = Call_DeleteImageStoreContent_564910(
    name: "deleteImageStoreContent", meth: HttpMethod.HttpDelete,
    host: "azure.local:19080", route: "/ImageStore/{contentPath}",
    validator: validate_DeleteImageStoreContent_564911, base: "",
    url: url_DeleteImageStoreContent_564912, schemes: {Scheme.Https, Scheme.Http})
type
  Call_CreateName_564920 = ref object of OpenApiRestCall_563565
proc url_CreateName_564922(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_CreateName_564921(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates the specified Service Fabric name.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564923 = query.getOrDefault("api-version")
  valid_564923 = validateParameter(valid_564923, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564923 != nil:
    section.add "api-version", valid_564923
  var valid_564924 = query.getOrDefault("timeout")
  valid_564924 = validateParameter(valid_564924, JInt, required = false,
                                 default = newJInt(60))
  if valid_564924 != nil:
    section.add "timeout", valid_564924
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564926: Call_CreateName_564920; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates the specified Service Fabric name.
  ## 
  let valid = call_564926.validator(path, query, header, formData, body)
  let scheme = call_564926.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564926.url(scheme.get, call_564926.host, call_564926.base,
                         call_564926.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564926, url, valid)

proc call*(call_564927: Call_CreateName_564920; NameDescription: JsonNode;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## createName
  ## Creates the specified Service Fabric name.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NameDescription: JObject (required)
  ##                  : Describes the Service Fabric name to be created.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_564928 = newJObject()
  var body_564929 = newJObject()
  add(query_564928, "api-version", newJString(apiVersion))
  if NameDescription != nil:
    body_564929 = NameDescription
  add(query_564928, "timeout", newJInt(timeout))
  result = call_564927.call(nil, query_564928, nil, nil, body_564929)

var createName* = Call_CreateName_564920(name: "createName",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Names/$/Create",
                                      validator: validate_CreateName_564921,
                                      base: "", url: url_CreateName_564922,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNameExistsInfo_564930 = ref object of OpenApiRestCall_563565
proc url_GetNameExistsInfo_564932(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNameExistsInfo_564931(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564933 = path.getOrDefault("nameId")
  valid_564933 = validateParameter(valid_564933, JString, required = true,
                                 default = nil)
  if valid_564933 != nil:
    section.add "nameId", valid_564933
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564934 = query.getOrDefault("api-version")
  valid_564934 = validateParameter(valid_564934, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564934 != nil:
    section.add "api-version", valid_564934
  var valid_564935 = query.getOrDefault("timeout")
  valid_564935 = validateParameter(valid_564935, JInt, required = false,
                                 default = newJInt(60))
  if valid_564935 != nil:
    section.add "timeout", valid_564935
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564936: Call_GetNameExistsInfo_564930; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns whether the specified Service Fabric name exists.
  ## 
  let valid = call_564936.validator(path, query, header, formData, body)
  let scheme = call_564936.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564936.url(scheme.get, call_564936.host, call_564936.base,
                         call_564936.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564936, url, valid)

proc call*(call_564937: Call_GetNameExistsInfo_564930; nameId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getNameExistsInfo
  ## Returns whether the specified Service Fabric name exists.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564938 = newJObject()
  var query_564939 = newJObject()
  add(query_564939, "api-version", newJString(apiVersion))
  add(query_564939, "timeout", newJInt(timeout))
  add(path_564938, "nameId", newJString(nameId))
  result = call_564937.call(path_564938, query_564939, nil, nil, nil)

var getNameExistsInfo* = Call_GetNameExistsInfo_564930(name: "getNameExistsInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Names/{nameId}",
    validator: validate_GetNameExistsInfo_564931, base: "",
    url: url_GetNameExistsInfo_564932, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteName_564940 = ref object of OpenApiRestCall_563565
proc url_DeleteName_564942(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteName_564941(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564943 = path.getOrDefault("nameId")
  valid_564943 = validateParameter(valid_564943, JString, required = true,
                                 default = nil)
  if valid_564943 != nil:
    section.add "nameId", valid_564943
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564944 = query.getOrDefault("api-version")
  valid_564944 = validateParameter(valid_564944, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564944 != nil:
    section.add "api-version", valid_564944
  var valid_564945 = query.getOrDefault("timeout")
  valid_564945 = validateParameter(valid_564945, JInt, required = false,
                                 default = newJInt(60))
  if valid_564945 != nil:
    section.add "timeout", valid_564945
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564946: Call_DeleteName_564940; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ## 
  let valid = call_564946.validator(path, query, header, formData, body)
  let scheme = call_564946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564946.url(scheme.get, call_564946.host, call_564946.base,
                         call_564946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564946, url, valid)

proc call*(call_564947: Call_DeleteName_564940; nameId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## deleteName
  ## Deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a name with child properties will fail.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564948 = newJObject()
  var query_564949 = newJObject()
  add(query_564949, "api-version", newJString(apiVersion))
  add(query_564949, "timeout", newJInt(timeout))
  add(path_564948, "nameId", newJString(nameId))
  result = call_564947.call(path_564948, query_564949, nil, nil, nil)

var deleteName* = Call_DeleteName_564940(name: "deleteName",
                                      meth: HttpMethod.HttpDelete,
                                      host: "azure.local:19080",
                                      route: "/Names/{nameId}",
                                      validator: validate_DeleteName_564941,
                                      base: "", url: url_DeleteName_564942,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfoList_564950 = ref object of OpenApiRestCall_563565
proc url_GetPropertyInfoList_564952(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfoList_564951(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564953 = path.getOrDefault("nameId")
  valid_564953 = validateParameter(valid_564953, JString, required = true,
                                 default = nil)
  if valid_564953 != nil:
    section.add "nameId", valid_564953
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   IncludeValues: JBool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  section = newJObject()
  var valid_564954 = query.getOrDefault("ContinuationToken")
  valid_564954 = validateParameter(valid_564954, JString, required = false,
                                 default = nil)
  if valid_564954 != nil:
    section.add "ContinuationToken", valid_564954
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564955 = query.getOrDefault("api-version")
  valid_564955 = validateParameter(valid_564955, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564955 != nil:
    section.add "api-version", valid_564955
  var valid_564956 = query.getOrDefault("timeout")
  valid_564956 = validateParameter(valid_564956, JInt, required = false,
                                 default = newJInt(60))
  if valid_564956 != nil:
    section.add "timeout", valid_564956
  var valid_564957 = query.getOrDefault("IncludeValues")
  valid_564957 = validateParameter(valid_564957, JBool, required = false,
                                 default = newJBool(false))
  if valid_564957 != nil:
    section.add "IncludeValues", valid_564957
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564958: Call_GetPropertyInfoList_564950; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets information on all Service Fabric properties under a given name.
  ## 
  let valid = call_564958.validator(path, query, header, formData, body)
  let scheme = call_564958.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564958.url(scheme.get, call_564958.host, call_564958.base,
                         call_564958.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564958, url, valid)

proc call*(call_564959: Call_GetPropertyInfoList_564950; nameId: string;
          ContinuationToken: string = ""; apiVersion: string = "6.0"; timeout: int = 60;
          IncludeValues: bool = false): Recallable =
  ## getPropertyInfoList
  ## Gets information on all Service Fabric properties under a given name.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   IncludeValues: bool
  ##                : Allows specifying whether to include the values of the properties returned. True if values should be returned with the metadata; False to return only property metadata.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564960 = newJObject()
  var query_564961 = newJObject()
  add(query_564961, "ContinuationToken", newJString(ContinuationToken))
  add(query_564961, "api-version", newJString(apiVersion))
  add(query_564961, "timeout", newJInt(timeout))
  add(query_564961, "IncludeValues", newJBool(IncludeValues))
  add(path_564960, "nameId", newJString(nameId))
  result = call_564959.call(path_564960, query_564961, nil, nil, nil)

var getPropertyInfoList* = Call_GetPropertyInfoList_564950(
    name: "getPropertyInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Names/{nameId}/$/GetProperties",
    validator: validate_GetPropertyInfoList_564951, base: "",
    url: url_GetPropertyInfoList_564952, schemes: {Scheme.Https, Scheme.Http})
type
  Call_SubmitPropertyBatch_564962 = ref object of OpenApiRestCall_563565
proc url_SubmitPropertyBatch_564964(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperties/$/SubmitBatch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_SubmitPropertyBatch_564963(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564965 = path.getOrDefault("nameId")
  valid_564965 = validateParameter(valid_564965, JString, required = true,
                                 default = nil)
  if valid_564965 != nil:
    section.add "nameId", valid_564965
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564966 = query.getOrDefault("api-version")
  valid_564966 = validateParameter(valid_564966, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564966 != nil:
    section.add "api-version", valid_564966
  var valid_564967 = query.getOrDefault("timeout")
  valid_564967 = validateParameter(valid_564967, JInt, required = false,
                                 default = newJInt(60))
  if valid_564967 != nil:
    section.add "timeout", valid_564967
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564969: Call_SubmitPropertyBatch_564962; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ## 
  let valid = call_564969.validator(path, query, header, formData, body)
  let scheme = call_564969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564969.url(scheme.get, call_564969.host, call_564969.base,
                         call_564969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564969, url, valid)

proc call*(call_564970: Call_SubmitPropertyBatch_564962;
          PropertyBatchDescriptionList: JsonNode; nameId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## submitPropertyBatch
  ## Submits a batch of property operations. Either all or none of the operations will be committed.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PropertyBatchDescriptionList: JObject (required)
  ##                               : Describes the property batch operations to be submitted.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564971 = newJObject()
  var query_564972 = newJObject()
  var body_564973 = newJObject()
  add(query_564972, "api-version", newJString(apiVersion))
  if PropertyBatchDescriptionList != nil:
    body_564973 = PropertyBatchDescriptionList
  add(query_564972, "timeout", newJInt(timeout))
  add(path_564971, "nameId", newJString(nameId))
  result = call_564970.call(path_564971, query_564972, nil, nil, body_564973)

var submitPropertyBatch* = Call_SubmitPropertyBatch_564962(
    name: "submitPropertyBatch", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperties/$/SubmitBatch",
    validator: validate_SubmitPropertyBatch_564963, base: "",
    url: url_SubmitPropertyBatch_564964, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PutProperty_564985 = ref object of OpenApiRestCall_563565
proc url_PutProperty_564987(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_PutProperty_564986(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564988 = path.getOrDefault("nameId")
  valid_564988 = validateParameter(valid_564988, JString, required = true,
                                 default = nil)
  if valid_564988 != nil:
    section.add "nameId", valid_564988
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564989 = query.getOrDefault("api-version")
  valid_564989 = validateParameter(valid_564989, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564989 != nil:
    section.add "api-version", valid_564989
  var valid_564990 = query.getOrDefault("timeout")
  valid_564990 = validateParameter(valid_564990, JInt, required = false,
                                 default = newJInt(60))
  if valid_564990 != nil:
    section.add "timeout", valid_564990
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_564992: Call_PutProperty_564985; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates or updates the specified Service Fabric property under a given name.
  ## 
  let valid = call_564992.validator(path, query, header, formData, body)
  let scheme = call_564992.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564992.url(scheme.get, call_564992.host, call_564992.base,
                         call_564992.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564992, url, valid)

proc call*(call_564993: Call_PutProperty_564985; PropertyDescription: JsonNode;
          nameId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## putProperty
  ## Creates or updates the specified Service Fabric property under a given name.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PropertyDescription: JObject (required)
  ##                      : Describes the Service Fabric property to be created.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564994 = newJObject()
  var query_564995 = newJObject()
  var body_564996 = newJObject()
  add(query_564995, "api-version", newJString(apiVersion))
  add(query_564995, "timeout", newJInt(timeout))
  if PropertyDescription != nil:
    body_564996 = PropertyDescription
  add(path_564994, "nameId", newJString(nameId))
  result = call_564993.call(path_564994, query_564995, nil, nil, body_564996)

var putProperty* = Call_PutProperty_564985(name: "putProperty",
                                        meth: HttpMethod.HttpPut,
                                        host: "azure.local:19080",
                                        route: "/Names/{nameId}/$/GetProperty",
                                        validator: validate_PutProperty_564986,
                                        base: "", url: url_PutProperty_564987,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPropertyInfo_564974 = ref object of OpenApiRestCall_563565
proc url_GetPropertyInfo_564976(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPropertyInfo_564975(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_564977 = path.getOrDefault("nameId")
  valid_564977 = validateParameter(valid_564977, JString, required = true,
                                 default = nil)
  if valid_564977 != nil:
    section.add "nameId", valid_564977
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_564978 = query.getOrDefault("api-version")
  valid_564978 = validateParameter(valid_564978, JString, required = true,
                                 default = newJString("6.0"))
  if valid_564978 != nil:
    section.add "api-version", valid_564978
  var valid_564979 = query.getOrDefault("timeout")
  valid_564979 = validateParameter(valid_564979, JInt, required = false,
                                 default = newJInt(60))
  if valid_564979 != nil:
    section.add "timeout", valid_564979
  var valid_564980 = query.getOrDefault("PropertyName")
  valid_564980 = validateParameter(valid_564980, JString, required = true,
                                 default = nil)
  if valid_564980 != nil:
    section.add "PropertyName", valid_564980
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_564981: Call_GetPropertyInfo_564974; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ## 
  let valid = call_564981.validator(path, query, header, formData, body)
  let scheme = call_564981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_564981.url(scheme.get, call_564981.host, call_564981.base,
                         call_564981.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_564981, url, valid)

proc call*(call_564982: Call_GetPropertyInfo_564974; PropertyName: string;
          nameId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getPropertyInfo
  ## Gets the specified Service Fabric property under a given name. This will always return both value and metadata.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_564983 = newJObject()
  var query_564984 = newJObject()
  add(query_564984, "api-version", newJString(apiVersion))
  add(query_564984, "timeout", newJInt(timeout))
  add(query_564984, "PropertyName", newJString(PropertyName))
  add(path_564983, "nameId", newJString(nameId))
  result = call_564982.call(path_564983, query_564984, nil, nil, nil)

var getPropertyInfo* = Call_GetPropertyInfo_564974(name: "getPropertyInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_GetPropertyInfo_564975,
    base: "", url: url_GetPropertyInfo_564976, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteProperty_564997 = ref object of OpenApiRestCall_563565
proc url_DeleteProperty_564999(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetProperty")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteProperty_564998(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_565000 = path.getOrDefault("nameId")
  valid_565000 = validateParameter(valid_565000, JString, required = true,
                                 default = nil)
  if valid_565000 != nil:
    section.add "nameId", valid_565000
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PropertyName: JString (required)
  ##               : Specifies the name of the property to get.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565001 = query.getOrDefault("api-version")
  valid_565001 = validateParameter(valid_565001, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565001 != nil:
    section.add "api-version", valid_565001
  var valid_565002 = query.getOrDefault("timeout")
  valid_565002 = validateParameter(valid_565002, JInt, required = false,
                                 default = newJInt(60))
  if valid_565002 != nil:
    section.add "timeout", valid_565002
  var valid_565003 = query.getOrDefault("PropertyName")
  valid_565003 = validateParameter(valid_565003, JString, required = true,
                                 default = nil)
  if valid_565003 != nil:
    section.add "PropertyName", valid_565003
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565004: Call_DeleteProperty_564997; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ## 
  let valid = call_565004.validator(path, query, header, formData, body)
  let scheme = call_565004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565004.url(scheme.get, call_565004.host, call_565004.base,
                         call_565004.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565004, url, valid)

proc call*(call_565005: Call_DeleteProperty_564997; PropertyName: string;
          nameId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## deleteProperty
  ## Deletes the specified Service Fabric property under a given name. A property must be created before it can be deleted.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PropertyName: string (required)
  ##               : Specifies the name of the property to get.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_565006 = newJObject()
  var query_565007 = newJObject()
  add(query_565007, "api-version", newJString(apiVersion))
  add(query_565007, "timeout", newJInt(timeout))
  add(query_565007, "PropertyName", newJString(PropertyName))
  add(path_565006, "nameId", newJString(nameId))
  result = call_565005.call(path_565006, query_565007, nil, nil, nil)

var deleteProperty* = Call_DeleteProperty_564997(name: "deleteProperty",
    meth: HttpMethod.HttpDelete, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetProperty", validator: validate_DeleteProperty_564998,
    base: "", url: url_DeleteProperty_564999, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetSubNameInfoList_565008 = ref object of OpenApiRestCall_563565
proc url_GetSubNameInfoList_565010(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nameId" in path, "`nameId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Names/"),
               (kind: VariableSegment, value: "nameId"),
               (kind: ConstantSegment, value: "/$/GetSubNames")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetSubNameInfoList_565009(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nameId: JString (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nameId` field"
  var valid_565011 = path.getOrDefault("nameId")
  valid_565011 = validateParameter(valid_565011, JString, required = true,
                                 default = nil)
  if valid_565011 != nil:
    section.add "nameId", valid_565011
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   Recursive: JBool
  ##            : Allows specifying that the search performed should be recursive.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565012 = query.getOrDefault("ContinuationToken")
  valid_565012 = validateParameter(valid_565012, JString, required = false,
                                 default = nil)
  if valid_565012 != nil:
    section.add "ContinuationToken", valid_565012
  var valid_565013 = query.getOrDefault("Recursive")
  valid_565013 = validateParameter(valid_565013, JBool, required = false,
                                 default = newJBool(false))
  if valid_565013 != nil:
    section.add "Recursive", valid_565013
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565014 = query.getOrDefault("api-version")
  valid_565014 = validateParameter(valid_565014, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565014 != nil:
    section.add "api-version", valid_565014
  var valid_565015 = query.getOrDefault("timeout")
  valid_565015 = validateParameter(valid_565015, JInt, required = false,
                                 default = newJInt(60))
  if valid_565015 != nil:
    section.add "timeout", valid_565015
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565016: Call_GetSubNameInfoList_565008; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ## 
  let valid = call_565016.validator(path, query, header, formData, body)
  let scheme = call_565016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565016.url(scheme.get, call_565016.host, call_565016.base,
                         call_565016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565016, url, valid)

proc call*(call_565017: Call_GetSubNameInfoList_565008; nameId: string;
          ContinuationToken: string = ""; Recursive: bool = false;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getSubNameInfoList
  ## Enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page, one page of results is returned as well as a continuation token which can be used to get the next page. Querying a name that doesn't exist will fail.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   Recursive: bool
  ##            : Allows specifying that the search performed should be recursive.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nameId: string (required)
  ##         : The Service Fabric name, without the 'fabric:' URI scheme.
  var path_565018 = newJObject()
  var query_565019 = newJObject()
  add(query_565019, "ContinuationToken", newJString(ContinuationToken))
  add(query_565019, "Recursive", newJBool(Recursive))
  add(query_565019, "api-version", newJString(apiVersion))
  add(query_565019, "timeout", newJInt(timeout))
  add(path_565018, "nameId", newJString(nameId))
  result = call_565017.call(path_565018, query_565019, nil, nil, nil)

var getSubNameInfoList* = Call_GetSubNameInfoList_565008(
    name: "getSubNameInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Names/{nameId}/$/GetSubNames",
    validator: validate_GetSubNameInfoList_565009, base: "",
    url: url_GetSubNameInfoList_565010, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfoList_565020 = ref object of OpenApiRestCall_563565
proc url_GetNodeInfoList_565022(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetNodeInfoList_565021(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: JString
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565023 = query.getOrDefault("ContinuationToken")
  valid_565023 = validateParameter(valid_565023, JString, required = false,
                                 default = nil)
  if valid_565023 != nil:
    section.add "ContinuationToken", valid_565023
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565024 = query.getOrDefault("api-version")
  valid_565024 = validateParameter(valid_565024, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565024 != nil:
    section.add "api-version", valid_565024
  var valid_565025 = query.getOrDefault("NodeStatusFilter")
  valid_565025 = validateParameter(valid_565025, JString, required = false,
                                 default = newJString("default"))
  if valid_565025 != nil:
    section.add "NodeStatusFilter", valid_565025
  var valid_565026 = query.getOrDefault("timeout")
  valid_565026 = validateParameter(valid_565026, JInt, required = false,
                                 default = newJInt(60))
  if valid_565026 != nil:
    section.add "timeout", valid_565026
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565027: Call_GetNodeInfoList_565020; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_565027.validator(path, query, header, formData, body)
  let scheme = call_565027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565027.url(scheme.get, call_565027.host, call_565027.base,
                         call_565027.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565027, url, valid)

proc call*(call_565028: Call_GetNodeInfoList_565020;
          ContinuationToken: string = ""; apiVersion: string = "6.0";
          NodeStatusFilter: string = "default"; timeout: int = 60): Recallable =
  ## getNodeInfoList
  ## The Nodes endpoint returns information about the nodes in the Service Fabric Cluster. The respons include the name, status, id, health, uptime and other details about the node.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   NodeStatusFilter: string
  ##                   : Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the specified filter value will be returned. The filter value can be one of the following.
  ## 
  ##   - default - This filter value will match all of the nodes excepts the ones with with status as Unknown or Removed.
  ##   - all - This filter value will match all of the nodes.
  ##   - up - This filter value will match nodes that are Up.
  ##   - down - This filter value will match nodes that are Down.
  ##   - enabling - This filter value will match nodes that are in the process of being enabled with status as Enabling.
  ##   - disabling - This filter value will match nodes that are in the process of being disabled with status as Disabling.
  ##   - disabled - This filter value will match nodes that are Disabled.
  ##   - unknown - This filter value will match nodes whose status is Unknown. A node would be in Unknown state if Service Fabric does not have authoritative information about that node. This can happen if the system learns about a node at runtime.
  ##   - removed - This filter value will match nodes whose status is Removed. These are the nodes that are removed from the cluster using the RemoveNodeState API.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_565029 = newJObject()
  add(query_565029, "ContinuationToken", newJString(ContinuationToken))
  add(query_565029, "api-version", newJString(apiVersion))
  add(query_565029, "NodeStatusFilter", newJString(NodeStatusFilter))
  add(query_565029, "timeout", newJInt(timeout))
  result = call_565028.call(nil, query_565029, nil, nil, nil)

var getNodeInfoList* = Call_GetNodeInfoList_565020(name: "getNodeInfoList",
    meth: HttpMethod.HttpGet, host: "azure.local:19080", route: "/Nodes",
    validator: validate_GetNodeInfoList_565021, base: "", url: url_GetNodeInfoList_565022,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeInfo_565030 = ref object of OpenApiRestCall_563565
proc url_GetNodeInfo_565032(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeInfo_565031(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565033 = path.getOrDefault("nodeName")
  valid_565033 = validateParameter(valid_565033, JString, required = true,
                                 default = nil)
  if valid_565033 != nil:
    section.add "nodeName", valid_565033
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565034 = query.getOrDefault("api-version")
  valid_565034 = validateParameter(valid_565034, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565034 != nil:
    section.add "api-version", valid_565034
  var valid_565035 = query.getOrDefault("timeout")
  valid_565035 = validateParameter(valid_565035, JInt, required = false,
                                 default = newJInt(60))
  if valid_565035 != nil:
    section.add "timeout", valid_565035
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565036: Call_GetNodeInfo_565030; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ## 
  let valid = call_565036.validator(path, query, header, formData, body)
  let scheme = call_565036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565036.url(scheme.get, call_565036.host, call_565036.base,
                         call_565036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565036, url, valid)

proc call*(call_565037: Call_GetNodeInfo_565030; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getNodeInfo
  ## Gets the information about a specific node in the Service Fabric Cluster.The respons include the name, status, id, health, uptime and other details about the node.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565038 = newJObject()
  var query_565039 = newJObject()
  add(query_565039, "api-version", newJString(apiVersion))
  add(query_565039, "timeout", newJInt(timeout))
  add(path_565038, "nodeName", newJString(nodeName))
  result = call_565037.call(path_565038, query_565039, nil, nil, nil)

var getNodeInfo* = Call_GetNodeInfo_565030(name: "getNodeInfo",
                                        meth: HttpMethod.HttpGet,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}",
                                        validator: validate_GetNodeInfo_565031,
                                        base: "", url: url_GetNodeInfo_565032,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_EnableNode_565040 = ref object of OpenApiRestCall_563565
proc url_EnableNode_565042(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Activate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_EnableNode_565041(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565043 = path.getOrDefault("nodeName")
  valid_565043 = validateParameter(valid_565043, JString, required = true,
                                 default = nil)
  if valid_565043 != nil:
    section.add "nodeName", valid_565043
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565044 = query.getOrDefault("api-version")
  valid_565044 = validateParameter(valid_565044, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565044 != nil:
    section.add "api-version", valid_565044
  var valid_565045 = query.getOrDefault("timeout")
  valid_565045 = validateParameter(valid_565045, JInt, required = false,
                                 default = newJInt(60))
  if valid_565045 != nil:
    section.add "timeout", valid_565045
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565046: Call_EnableNode_565040; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ## 
  let valid = call_565046.validator(path, query, header, formData, body)
  let scheme = call_565046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565046.url(scheme.get, call_565046.host, call_565046.base,
                         call_565046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565046, url, valid)

proc call*(call_565047: Call_EnableNode_565040; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## enableNode
  ## Activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be reactivated.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565048 = newJObject()
  var query_565049 = newJObject()
  add(query_565049, "api-version", newJString(apiVersion))
  add(query_565049, "timeout", newJInt(timeout))
  add(path_565048, "nodeName", newJString(nodeName))
  result = call_565047.call(path_565048, query_565049, nil, nil, nil)

var enableNode* = Call_EnableNode_565040(name: "enableNode",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Nodes/{nodeName}/$/Activate",
                                      validator: validate_EnableNode_565041,
                                      base: "", url: url_EnableNode_565042,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_DisableNode_565050 = ref object of OpenApiRestCall_563565
proc url_DisableNode_565052(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Deactivate")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DisableNode_565051(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565053 = path.getOrDefault("nodeName")
  valid_565053 = validateParameter(valid_565053, JString, required = true,
                                 default = nil)
  if valid_565053 != nil:
    section.add "nodeName", valid_565053
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565054 = query.getOrDefault("api-version")
  valid_565054 = validateParameter(valid_565054, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565054 != nil:
    section.add "api-version", valid_565054
  var valid_565055 = query.getOrDefault("timeout")
  valid_565055 = validateParameter(valid_565055, JInt, required = false,
                                 default = newJInt(60))
  if valid_565055 != nil:
    section.add "timeout", valid_565055
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565057: Call_DisableNode_565050; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ## 
  let valid = call_565057.validator(path, query, header, formData, body)
  let scheme = call_565057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565057.url(scheme.get, call_565057.host, call_565057.base,
                         call_565057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565057, url, valid)

proc call*(call_565058: Call_DisableNode_565050;
          DeactivationIntentDescription: JsonNode; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## disableNode
  ## Deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still need to be reactivated before services will be placed on that node.
  ##   DeactivationIntentDescription: JObject (required)
  ##                                : Describes the intent or reason for deactivating the node.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565059 = newJObject()
  var query_565060 = newJObject()
  var body_565061 = newJObject()
  if DeactivationIntentDescription != nil:
    body_565061 = DeactivationIntentDescription
  add(query_565060, "api-version", newJString(apiVersion))
  add(query_565060, "timeout", newJInt(timeout))
  add(path_565059, "nodeName", newJString(nodeName))
  result = call_565058.call(path_565059, query_565060, nil, nil, body_565061)

var disableNode* = Call_DisableNode_565050(name: "disableNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080", route: "/Nodes/{nodeName}/$/Deactivate",
                                        validator: validate_DisableNode_565051,
                                        base: "", url: url_DisableNode_565052,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeployedServicePackageToNode_565062 = ref object of OpenApiRestCall_563565
proc url_DeployedServicePackageToNode_565064(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/DeployServicePackage")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeployedServicePackageToNode_565063(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565065 = path.getOrDefault("nodeName")
  valid_565065 = validateParameter(valid_565065, JString, required = true,
                                 default = nil)
  if valid_565065 != nil:
    section.add "nodeName", valid_565065
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565066 = query.getOrDefault("api-version")
  valid_565066 = validateParameter(valid_565066, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565066 != nil:
    section.add "api-version", valid_565066
  var valid_565067 = query.getOrDefault("timeout")
  valid_565067 = validateParameter(valid_565067, JInt, required = false,
                                 default = newJInt(60))
  if valid_565067 != nil:
    section.add "timeout", valid_565067
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565069: Call_DeployedServicePackageToNode_565062; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ## 
  let valid = call_565069.validator(path, query, header, formData, body)
  let scheme = call_565069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565069.url(scheme.get, call_565069.host, call_565069.base,
                         call_565069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565069, url, valid)

proc call*(call_565070: Call_DeployedServicePackageToNode_565062;
          DeployServicePackageToNodeDescription: JsonNode; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## deployedServicePackageToNode
  ## Downloads packages associated with specified service manifest to image cache on specified node.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployServicePackageToNodeDescription: JObject (required)
  ##                                        : Describes information for deploying a service package to a Service Fabric node.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565071 = newJObject()
  var query_565072 = newJObject()
  var body_565073 = newJObject()
  add(query_565072, "api-version", newJString(apiVersion))
  if DeployServicePackageToNodeDescription != nil:
    body_565073 = DeployServicePackageToNodeDescription
  add(query_565072, "timeout", newJInt(timeout))
  add(path_565071, "nodeName", newJString(nodeName))
  result = call_565070.call(path_565071, query_565072, nil, nil, body_565073)

var deployedServicePackageToNode* = Call_DeployedServicePackageToNode_565062(
    name: "deployedServicePackageToNode", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/DeployServicePackage",
    validator: validate_DeployedServicePackageToNode_565063, base: "",
    url: url_DeployedServicePackageToNode_565064,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfoList_565074 = ref object of OpenApiRestCall_563565
proc url_GetDeployedApplicationInfoList_565076(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfoList_565075(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565077 = path.getOrDefault("nodeName")
  valid_565077 = validateParameter(valid_565077, JString, required = true,
                                 default = nil)
  if valid_565077 != nil:
    section.add "nodeName", valid_565077
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565078 = query.getOrDefault("api-version")
  valid_565078 = validateParameter(valid_565078, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565078 != nil:
    section.add "api-version", valid_565078
  var valid_565079 = query.getOrDefault("timeout")
  valid_565079 = validateParameter(valid_565079, JInt, required = false,
                                 default = newJInt(60))
  if valid_565079 != nil:
    section.add "timeout", valid_565079
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565080: Call_GetDeployedApplicationInfoList_565074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of applications deployed on a Service Fabric node.
  ## 
  let valid = call_565080.validator(path, query, header, formData, body)
  let scheme = call_565080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565080.url(scheme.get, call_565080.host, call_565080.base,
                         call_565080.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565080, url, valid)

proc call*(call_565081: Call_GetDeployedApplicationInfoList_565074;
          nodeName: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getDeployedApplicationInfoList
  ## Gets the list of applications deployed on a Service Fabric node.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565082 = newJObject()
  var query_565083 = newJObject()
  add(query_565083, "api-version", newJString(apiVersion))
  add(query_565083, "timeout", newJInt(timeout))
  add(path_565082, "nodeName", newJString(nodeName))
  result = call_565081.call(path_565082, query_565083, nil, nil, nil)

var getDeployedApplicationInfoList* = Call_GetDeployedApplicationInfoList_565074(
    name: "getDeployedApplicationInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications",
    validator: validate_GetDeployedApplicationInfoList_565075, base: "",
    url: url_GetDeployedApplicationInfoList_565076,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationInfo_565084 = ref object of OpenApiRestCall_563565
proc url_GetDeployedApplicationInfo_565086(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationInfo_565085(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565087 = path.getOrDefault("nodeName")
  valid_565087 = validateParameter(valid_565087, JString, required = true,
                                 default = nil)
  if valid_565087 != nil:
    section.add "nodeName", valid_565087
  var valid_565088 = path.getOrDefault("applicationId")
  valid_565088 = validateParameter(valid_565088, JString, required = true,
                                 default = nil)
  if valid_565088 != nil:
    section.add "applicationId", valid_565088
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565089 = query.getOrDefault("api-version")
  valid_565089 = validateParameter(valid_565089, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565089 != nil:
    section.add "api-version", valid_565089
  var valid_565090 = query.getOrDefault("timeout")
  valid_565090 = validateParameter(valid_565090, JInt, required = false,
                                 default = newJInt(60))
  if valid_565090 != nil:
    section.add "timeout", valid_565090
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565091: Call_GetDeployedApplicationInfo_565084; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about an application deployed on a Service Fabric node.
  ## 
  let valid = call_565091.validator(path, query, header, formData, body)
  let scheme = call_565091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565091.url(scheme.get, call_565091.host, call_565091.base,
                         call_565091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565091, url, valid)

proc call*(call_565092: Call_GetDeployedApplicationInfo_565084; nodeName: string;
          applicationId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getDeployedApplicationInfo
  ## Gets the information about an application deployed on a Service Fabric node.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565093 = newJObject()
  var query_565094 = newJObject()
  add(query_565094, "api-version", newJString(apiVersion))
  add(query_565094, "timeout", newJInt(timeout))
  add(path_565093, "nodeName", newJString(nodeName))
  add(path_565093, "applicationId", newJString(applicationId))
  result = call_565092.call(path_565093, query_565094, nil, nil, nil)

var getDeployedApplicationInfo* = Call_GetDeployedApplicationInfo_565084(
    name: "getDeployedApplicationInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}",
    validator: validate_GetDeployedApplicationInfo_565085, base: "",
    url: url_GetDeployedApplicationInfo_565086,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedCodePackageInfoList_565095 = ref object of OpenApiRestCall_563565
proc url_GetDeployedCodePackageInfoList_565097(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedCodePackageInfoList_565096(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565098 = path.getOrDefault("nodeName")
  valid_565098 = validateParameter(valid_565098, JString, required = true,
                                 default = nil)
  if valid_565098 != nil:
    section.add "nodeName", valid_565098
  var valid_565099 = path.getOrDefault("applicationId")
  valid_565099 = validateParameter(valid_565099, JString, required = true,
                                 default = nil)
  if valid_565099 != nil:
    section.add "applicationId", valid_565099
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   CodePackageName: JString
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565100 = query.getOrDefault("api-version")
  valid_565100 = validateParameter(valid_565100, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565100 != nil:
    section.add "api-version", valid_565100
  var valid_565101 = query.getOrDefault("timeout")
  valid_565101 = validateParameter(valid_565101, JInt, required = false,
                                 default = newJInt(60))
  if valid_565101 != nil:
    section.add "timeout", valid_565101
  var valid_565102 = query.getOrDefault("CodePackageName")
  valid_565102 = validateParameter(valid_565102, JString, required = false,
                                 default = nil)
  if valid_565102 != nil:
    section.add "CodePackageName", valid_565102
  var valid_565103 = query.getOrDefault("ServiceManifestName")
  valid_565103 = validateParameter(valid_565103, JString, required = false,
                                 default = nil)
  if valid_565103 != nil:
    section.add "ServiceManifestName", valid_565103
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565104: Call_GetDeployedCodePackageInfoList_565095; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_565104.validator(path, query, header, formData, body)
  let scheme = call_565104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565104.url(scheme.get, call_565104.host, call_565104.base,
                         call_565104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565104, url, valid)

proc call*(call_565105: Call_GetDeployedCodePackageInfoList_565095;
          nodeName: string; applicationId: string; apiVersion: string = "6.0";
          timeout: int = 60; CodePackageName: string = "";
          ServiceManifestName: string = ""): Recallable =
  ## getDeployedCodePackageInfoList
  ## Gets the list of code packages deployed on a Service Fabric node for the given application.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   CodePackageName: string
  ##                  : The name of code package specified in service manifest registered as part of an application type in a Service Fabric cluster.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565106 = newJObject()
  var query_565107 = newJObject()
  add(query_565107, "api-version", newJString(apiVersion))
  add(query_565107, "timeout", newJInt(timeout))
  add(path_565106, "nodeName", newJString(nodeName))
  add(query_565107, "CodePackageName", newJString(CodePackageName))
  add(query_565107, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_565106, "applicationId", newJString(applicationId))
  result = call_565105.call(path_565106, query_565107, nil, nil, nil)

var getDeployedCodePackageInfoList* = Call_GetDeployedCodePackageInfoList_565095(
    name: "getDeployedCodePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages",
    validator: validate_GetDeployedCodePackageInfoList_565096, base: "",
    url: url_GetDeployedCodePackageInfoList_565097,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartDeployedCodePackage_565108 = ref object of OpenApiRestCall_563565
proc url_RestartDeployedCodePackage_565110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetCodePackages/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartDeployedCodePackage_565109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565111 = path.getOrDefault("nodeName")
  valid_565111 = validateParameter(valid_565111, JString, required = true,
                                 default = nil)
  if valid_565111 != nil:
    section.add "nodeName", valid_565111
  var valid_565112 = path.getOrDefault("applicationId")
  valid_565112 = validateParameter(valid_565112, JString, required = true,
                                 default = nil)
  if valid_565112 != nil:
    section.add "applicationId", valid_565112
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565113 = query.getOrDefault("api-version")
  valid_565113 = validateParameter(valid_565113, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565113 != nil:
    section.add "api-version", valid_565113
  var valid_565114 = query.getOrDefault("timeout")
  valid_565114 = validateParameter(valid_565114, JInt, required = false,
                                 default = newJInt(60))
  if valid_565114 != nil:
    section.add "timeout", valid_565114
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565116: Call_RestartDeployedCodePackage_565108; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ## 
  let valid = call_565116.validator(path, query, header, formData, body)
  let scheme = call_565116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565116.url(scheme.get, call_565116.host, call_565116.base,
                         call_565116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565116, url, valid)

proc call*(call_565117: Call_RestartDeployedCodePackage_565108; nodeName: string;
          RestartDeployedCodePackageDescription: JsonNode; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## restartDeployedCodePackage
  ## Restarts a code package deployed on a Service Fabric node in a cluster. This aborts the code package process, which will restart all the user service replicas hosted in that process.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   RestartDeployedCodePackageDescription: JObject (required)
  ##                                        : Describes the deployed code package on Service Fabric node to restart.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565118 = newJObject()
  var query_565119 = newJObject()
  var body_565120 = newJObject()
  add(query_565119, "api-version", newJString(apiVersion))
  add(query_565119, "timeout", newJInt(timeout))
  add(path_565118, "nodeName", newJString(nodeName))
  if RestartDeployedCodePackageDescription != nil:
    body_565120 = RestartDeployedCodePackageDescription
  add(path_565118, "applicationId", newJString(applicationId))
  result = call_565117.call(path_565118, query_565119, nil, nil, body_565120)

var restartDeployedCodePackage* = Call_RestartDeployedCodePackage_565108(
    name: "restartDeployedCodePackage", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart",
    validator: validate_RestartDeployedCodePackage_565109, base: "",
    url: url_RestartDeployedCodePackage_565110,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealthUsingPolicy_565135 = ref object of OpenApiRestCall_563565
proc url_GetDeployedApplicationHealthUsingPolicy_565137(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealthUsingPolicy_565136(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565138 = path.getOrDefault("nodeName")
  valid_565138 = validateParameter(valid_565138, JString, required = true,
                                 default = nil)
  if valid_565138 != nil:
    section.add "nodeName", valid_565138
  var valid_565139 = path.getOrDefault("applicationId")
  valid_565139 = validateParameter(valid_565139, JString, required = true,
                                 default = nil)
  if valid_565139 != nil:
    section.add "applicationId", valid_565139
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565140 = query.getOrDefault("api-version")
  valid_565140 = validateParameter(valid_565140, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565140 != nil:
    section.add "api-version", valid_565140
  var valid_565141 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_565141 = validateParameter(valid_565141, JInt, required = false,
                                 default = newJInt(0))
  if valid_565141 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_565141
  var valid_565142 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565142 = validateParameter(valid_565142, JBool, required = false,
                                 default = newJBool(false))
  if valid_565142 != nil:
    section.add "ExcludeHealthStatistics", valid_565142
  var valid_565143 = query.getOrDefault("timeout")
  valid_565143 = validateParameter(valid_565143, JInt, required = false,
                                 default = newJInt(60))
  if valid_565143 != nil:
    section.add "timeout", valid_565143
  var valid_565144 = query.getOrDefault("EventsHealthStateFilter")
  valid_565144 = validateParameter(valid_565144, JInt, required = false,
                                 default = newJInt(0))
  if valid_565144 != nil:
    section.add "EventsHealthStateFilter", valid_565144
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565146: Call_GetDeployedApplicationHealthUsingPolicy_565135;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ## 
  let valid = call_565146.validator(path, query, header, formData, body)
  let scheme = call_565146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565146.url(scheme.get, call_565146.host, call_565146.base,
                         call_565146.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565146, url, valid)

proc call*(call_565147: Call_GetDeployedApplicationHealthUsingPolicy_565135;
          nodeName: string; applicationId: string;
          ApplicationHealthPolicy: JsonNode = nil; apiVersion: string = "6.0";
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealthUsingPolicy
  ## Gets the information about health of an application deployed on a Service Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed application.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565148 = newJObject()
  var query_565149 = newJObject()
  var body_565150 = newJObject()
  if ApplicationHealthPolicy != nil:
    body_565150 = ApplicationHealthPolicy
  add(query_565149, "api-version", newJString(apiVersion))
  add(query_565149, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_565149, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565149, "timeout", newJInt(timeout))
  add(path_565148, "nodeName", newJString(nodeName))
  add(query_565149, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565148, "applicationId", newJString(applicationId))
  result = call_565147.call(path_565148, query_565149, nil, nil, body_565150)

var getDeployedApplicationHealthUsingPolicy* = Call_GetDeployedApplicationHealthUsingPolicy_565135(
    name: "getDeployedApplicationHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealthUsingPolicy_565136, base: "",
    url: url_GetDeployedApplicationHealthUsingPolicy_565137,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedApplicationHealth_565121 = ref object of OpenApiRestCall_563565
proc url_GetDeployedApplicationHealth_565123(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedApplicationHealth_565122(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565124 = path.getOrDefault("nodeName")
  valid_565124 = validateParameter(valid_565124, JString, required = true,
                                 default = nil)
  if valid_565124 != nil:
    section.add "nodeName", valid_565124
  var valid_565125 = path.getOrDefault("applicationId")
  valid_565125 = validateParameter(valid_565125, JString, required = true,
                                 default = nil)
  if valid_565125 != nil:
    section.add "applicationId", valid_565125
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: JInt
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565126 = query.getOrDefault("api-version")
  valid_565126 = validateParameter(valid_565126, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565126 != nil:
    section.add "api-version", valid_565126
  var valid_565127 = query.getOrDefault("DeployedServicePackagesHealthStateFilter")
  valid_565127 = validateParameter(valid_565127, JInt, required = false,
                                 default = newJInt(0))
  if valid_565127 != nil:
    section.add "DeployedServicePackagesHealthStateFilter", valid_565127
  var valid_565128 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565128 = validateParameter(valid_565128, JBool, required = false,
                                 default = newJBool(false))
  if valid_565128 != nil:
    section.add "ExcludeHealthStatistics", valid_565128
  var valid_565129 = query.getOrDefault("timeout")
  valid_565129 = validateParameter(valid_565129, JInt, required = false,
                                 default = newJInt(60))
  if valid_565129 != nil:
    section.add "timeout", valid_565129
  var valid_565130 = query.getOrDefault("EventsHealthStateFilter")
  valid_565130 = validateParameter(valid_565130, JInt, required = false,
                                 default = newJInt(0))
  if valid_565130 != nil:
    section.add "EventsHealthStateFilter", valid_565130
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565131: Call_GetDeployedApplicationHealth_565121; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ## 
  let valid = call_565131.validator(path, query, header, formData, body)
  let scheme = call_565131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565131.url(scheme.get, call_565131.host, call_565131.base,
                         call_565131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565131, url, valid)

proc call*(call_565132: Call_GetDeployedApplicationHealth_565121; nodeName: string;
          applicationId: string; apiVersion: string = "6.0";
          DeployedServicePackagesHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedApplicationHealth
  ## Gets the information about health of an application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on health state.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   DeployedServicePackagesHealthStateFilter: int
  ##                                           : Allows filtering of the deployed service package health state objects returned in the result of deployed application health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only deployed service packages that match the filter are returned. All deployed service packages are used to evaluate the aggregated health state of the deployed application.
  ## If not specified, all entries are returned.
  ## The state values are flag based enumeration, so the value can be a combination of these value obtained using bitwise 'OR' operator.
  ## For example, if the provided value is 6 then health state of service packages with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565133 = newJObject()
  var query_565134 = newJObject()
  add(query_565134, "api-version", newJString(apiVersion))
  add(query_565134, "DeployedServicePackagesHealthStateFilter",
      newJInt(DeployedServicePackagesHealthStateFilter))
  add(query_565134, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565134, "timeout", newJInt(timeout))
  add(path_565133, "nodeName", newJString(nodeName))
  add(query_565134, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565133, "applicationId", newJString(applicationId))
  result = call_565132.call(path_565133, query_565134, nil, nil, nil)

var getDeployedApplicationHealth* = Call_GetDeployedApplicationHealth_565121(
    name: "getDeployedApplicationHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth",
    validator: validate_GetDeployedApplicationHealth_565122, base: "",
    url: url_GetDeployedApplicationHealth_565123,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaInfoList_565151 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServiceReplicaInfoList_565153(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaInfoList_565152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565154 = path.getOrDefault("nodeName")
  valid_565154 = validateParameter(valid_565154, JString, required = true,
                                 default = nil)
  if valid_565154 != nil:
    section.add "nodeName", valid_565154
  var valid_565155 = path.getOrDefault("applicationId")
  valid_565155 = validateParameter(valid_565155, JString, required = true,
                                 default = nil)
  if valid_565155 != nil:
    section.add "applicationId", valid_565155
  result.add "path", section
  ## parameters in `query` object:
  ##   PartitionId: JString
  ##              : The identity of the partition.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceManifestName: JString
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  section = newJObject()
  var valid_565156 = query.getOrDefault("PartitionId")
  valid_565156 = validateParameter(valid_565156, JString, required = false,
                                 default = nil)
  if valid_565156 != nil:
    section.add "PartitionId", valid_565156
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565157 = query.getOrDefault("api-version")
  valid_565157 = validateParameter(valid_565157, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565157 != nil:
    section.add "api-version", valid_565157
  var valid_565158 = query.getOrDefault("timeout")
  valid_565158 = validateParameter(valid_565158, JInt, required = false,
                                 default = newJInt(60))
  if valid_565158 != nil:
    section.add "timeout", valid_565158
  var valid_565159 = query.getOrDefault("ServiceManifestName")
  valid_565159 = validateParameter(valid_565159, JString, required = false,
                                 default = nil)
  if valid_565159 != nil:
    section.add "ServiceManifestName", valid_565159
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565160: Call_GetDeployedServiceReplicaInfoList_565151;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ## 
  let valid = call_565160.validator(path, query, header, formData, body)
  let scheme = call_565160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565160.url(scheme.get, call_565160.host, call_565160.base,
                         call_565160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565160, url, valid)

proc call*(call_565161: Call_GetDeployedServiceReplicaInfoList_565151;
          nodeName: string; applicationId: string; PartitionId: string = "";
          apiVersion: string = "6.0"; timeout: int = 60;
          ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceReplicaInfoList
  ## Gets the list containing the information about replicas deployed on a Service Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of the service type and other information. Use PartitionId or ServiceManifestName query parameters to return information about the deployed replicas matching the specified values for those parameters.
  ##   PartitionId: string
  ##              : The identity of the partition.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of a service manifest registered as part of an application type in a Service Fabric cluster.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565162 = newJObject()
  var query_565163 = newJObject()
  add(query_565163, "PartitionId", newJString(PartitionId))
  add(query_565163, "api-version", newJString(apiVersion))
  add(query_565163, "timeout", newJInt(timeout))
  add(path_565162, "nodeName", newJString(nodeName))
  add(query_565163, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_565162, "applicationId", newJString(applicationId))
  result = call_565161.call(path_565162, query_565163, nil, nil, nil)

var getDeployedServiceReplicaInfoList* = Call_GetDeployedServiceReplicaInfoList_565151(
    name: "getDeployedServiceReplicaInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaInfoList_565152, base: "",
    url: url_GetDeployedServiceReplicaInfoList_565153,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoList_565164 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServicePackageInfoList_565166(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoList_565165(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565167 = path.getOrDefault("nodeName")
  valid_565167 = validateParameter(valid_565167, JString, required = true,
                                 default = nil)
  if valid_565167 != nil:
    section.add "nodeName", valid_565167
  var valid_565168 = path.getOrDefault("applicationId")
  valid_565168 = validateParameter(valid_565168, JString, required = true,
                                 default = nil)
  if valid_565168 != nil:
    section.add "applicationId", valid_565168
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565169 = query.getOrDefault("api-version")
  valid_565169 = validateParameter(valid_565169, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565169 != nil:
    section.add "api-version", valid_565169
  var valid_565170 = query.getOrDefault("timeout")
  valid_565170 = validateParameter(valid_565170, JInt, required = false,
                                 default = newJInt(60))
  if valid_565170 != nil:
    section.add "timeout", valid_565170
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565171: Call_GetDeployedServicePackageInfoList_565164;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ## 
  let valid = call_565171.validator(path, query, header, formData, body)
  let scheme = call_565171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565171.url(scheme.get, call_565171.host, call_565171.base,
                         call_565171.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565171, url, valid)

proc call*(call_565172: Call_GetDeployedServicePackageInfoList_565164;
          nodeName: string; applicationId: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getDeployedServicePackageInfoList
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565173 = newJObject()
  var query_565174 = newJObject()
  add(query_565174, "api-version", newJString(apiVersion))
  add(query_565174, "timeout", newJInt(timeout))
  add(path_565173, "nodeName", newJString(nodeName))
  add(path_565173, "applicationId", newJString(applicationId))
  result = call_565172.call(path_565173, query_565174, nil, nil, nil)

var getDeployedServicePackageInfoList* = Call_GetDeployedServicePackageInfoList_565164(
    name: "getDeployedServicePackageInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages",
    validator: validate_GetDeployedServicePackageInfoList_565165, base: "",
    url: url_GetDeployedServicePackageInfoList_565166,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageInfoListByName_565175 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServicePackageInfoListByName_565177(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageInfoListByName_565176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `servicePackageName` field"
  var valid_565178 = path.getOrDefault("servicePackageName")
  valid_565178 = validateParameter(valid_565178, JString, required = true,
                                 default = nil)
  if valid_565178 != nil:
    section.add "servicePackageName", valid_565178
  var valid_565179 = path.getOrDefault("nodeName")
  valid_565179 = validateParameter(valid_565179, JString, required = true,
                                 default = nil)
  if valid_565179 != nil:
    section.add "nodeName", valid_565179
  var valid_565180 = path.getOrDefault("applicationId")
  valid_565180 = validateParameter(valid_565180, JString, required = true,
                                 default = nil)
  if valid_565180 != nil:
    section.add "applicationId", valid_565180
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565181 = query.getOrDefault("api-version")
  valid_565181 = validateParameter(valid_565181, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565181 != nil:
    section.add "api-version", valid_565181
  var valid_565182 = query.getOrDefault("timeout")
  valid_565182 = validateParameter(valid_565182, JInt, required = false,
                                 default = newJInt(60))
  if valid_565182 != nil:
    section.add "timeout", valid_565182
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565183: Call_GetDeployedServicePackageInfoListByName_565175;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ## 
  let valid = call_565183.validator(path, query, header, formData, body)
  let scheme = call_565183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565183.url(scheme.get, call_565183.host, call_565183.base,
                         call_565183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565183, url, valid)

proc call*(call_565184: Call_GetDeployedServicePackageInfoListByName_565175;
          servicePackageName: string; nodeName: string; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getDeployedServicePackageInfoListByName
  ## Returns the information about the service packages deployed on a Service Fabric node for the given application. These results are of service packages whose name match exactly the service package name specified as the parameter.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565185 = newJObject()
  var query_565186 = newJObject()
  add(path_565185, "servicePackageName", newJString(servicePackageName))
  add(query_565186, "api-version", newJString(apiVersion))
  add(query_565186, "timeout", newJInt(timeout))
  add(path_565185, "nodeName", newJString(nodeName))
  add(path_565185, "applicationId", newJString(applicationId))
  result = call_565184.call(path_565185, query_565186, nil, nil, nil)

var getDeployedServicePackageInfoListByName* = Call_GetDeployedServicePackageInfoListByName_565175(
    name: "getDeployedServicePackageInfoListByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}",
    validator: validate_GetDeployedServicePackageInfoListByName_565176, base: "",
    url: url_GetDeployedServicePackageInfoListByName_565177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealthUsingPolicy_565200 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServicePackageHealthUsingPolicy_565202(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealthUsingPolicy_565201(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `servicePackageName` field"
  var valid_565203 = path.getOrDefault("servicePackageName")
  valid_565203 = validateParameter(valid_565203, JString, required = true,
                                 default = nil)
  if valid_565203 != nil:
    section.add "servicePackageName", valid_565203
  var valid_565204 = path.getOrDefault("nodeName")
  valid_565204 = validateParameter(valid_565204, JString, required = true,
                                 default = nil)
  if valid_565204 != nil:
    section.add "nodeName", valid_565204
  var valid_565205 = path.getOrDefault("applicationId")
  valid_565205 = validateParameter(valid_565205, JString, required = true,
                                 default = nil)
  if valid_565205 != nil:
    section.add "applicationId", valid_565205
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565206 = query.getOrDefault("api-version")
  valid_565206 = validateParameter(valid_565206, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565206 != nil:
    section.add "api-version", valid_565206
  var valid_565207 = query.getOrDefault("timeout")
  valid_565207 = validateParameter(valid_565207, JInt, required = false,
                                 default = newJInt(60))
  if valid_565207 != nil:
    section.add "timeout", valid_565207
  var valid_565208 = query.getOrDefault("EventsHealthStateFilter")
  valid_565208 = validateParameter(valid_565208, JInt, required = false,
                                 default = newJInt(0))
  if valid_565208 != nil:
    section.add "EventsHealthStateFilter", valid_565208
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565210: Call_GetDeployedServicePackageHealthUsingPolicy_565200;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ## 
  let valid = call_565210.validator(path, query, header, formData, body)
  let scheme = call_565210.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565210.url(scheme.get, call_565210.host, call_565210.base,
                         call_565210.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565210, url, valid)

proc call*(call_565211: Call_GetDeployedServicePackageHealthUsingPolicy_565200;
          servicePackageName: string; nodeName: string; applicationId: string;
          ApplicationHealthPolicy: JsonNode = nil; apiVersion: string = "6.0";
          timeout: int = 60; EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealthUsingPolicy
  ## Gets the information about health of an service package for a specific application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the deployed service package.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565212 = newJObject()
  var query_565213 = newJObject()
  var body_565214 = newJObject()
  if ApplicationHealthPolicy != nil:
    body_565214 = ApplicationHealthPolicy
  add(path_565212, "servicePackageName", newJString(servicePackageName))
  add(query_565213, "api-version", newJString(apiVersion))
  add(query_565213, "timeout", newJInt(timeout))
  add(path_565212, "nodeName", newJString(nodeName))
  add(query_565213, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565212, "applicationId", newJString(applicationId))
  result = call_565211.call(path_565212, query_565213, nil, nil, body_565214)

var getDeployedServicePackageHealthUsingPolicy* = Call_GetDeployedServicePackageHealthUsingPolicy_565200(
    name: "getDeployedServicePackageHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealthUsingPolicy_565201,
    base: "", url: url_GetDeployedServicePackageHealthUsingPolicy_565202,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServicePackageHealth_565187 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServicePackageHealth_565189(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServicePackageHealth_565188(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `servicePackageName` field"
  var valid_565190 = path.getOrDefault("servicePackageName")
  valid_565190 = validateParameter(valid_565190, JString, required = true,
                                 default = nil)
  if valid_565190 != nil:
    section.add "servicePackageName", valid_565190
  var valid_565191 = path.getOrDefault("nodeName")
  valid_565191 = validateParameter(valid_565191, JString, required = true,
                                 default = nil)
  if valid_565191 != nil:
    section.add "nodeName", valid_565191
  var valid_565192 = path.getOrDefault("applicationId")
  valid_565192 = validateParameter(valid_565192, JString, required = true,
                                 default = nil)
  if valid_565192 != nil:
    section.add "applicationId", valid_565192
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565193 = query.getOrDefault("api-version")
  valid_565193 = validateParameter(valid_565193, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565193 != nil:
    section.add "api-version", valid_565193
  var valid_565194 = query.getOrDefault("timeout")
  valid_565194 = validateParameter(valid_565194, JInt, required = false,
                                 default = newJInt(60))
  if valid_565194 != nil:
    section.add "timeout", valid_565194
  var valid_565195 = query.getOrDefault("EventsHealthStateFilter")
  valid_565195 = validateParameter(valid_565195, JInt, required = false,
                                 default = newJInt(0))
  if valid_565195 != nil:
    section.add "EventsHealthStateFilter", valid_565195
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565196: Call_GetDeployedServicePackageHealth_565187;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ## 
  let valid = call_565196.validator(path, query, header, formData, body)
  let scheme = call_565196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565196.url(scheme.get, call_565196.host, call_565196.base,
                         call_565196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565196, url, valid)

proc call*(call_565197: Call_GetDeployedServicePackageHealth_565187;
          servicePackageName: string; nodeName: string; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getDeployedServicePackageHealth
  ## Gets the information about health of service package for a specific application deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed service package based on health state.
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565198 = newJObject()
  var query_565199 = newJObject()
  add(path_565198, "servicePackageName", newJString(servicePackageName))
  add(query_565199, "api-version", newJString(apiVersion))
  add(query_565199, "timeout", newJInt(timeout))
  add(path_565198, "nodeName", newJString(nodeName))
  add(query_565199, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565198, "applicationId", newJString(applicationId))
  result = call_565197.call(path_565198, query_565199, nil, nil, nil)

var getDeployedServicePackageHealth* = Call_GetDeployedServicePackageHealth_565187(
    name: "getDeployedServicePackageHealth", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth",
    validator: validate_GetDeployedServicePackageHealth_565188, base: "",
    url: url_GetDeployedServicePackageHealth_565189,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedServicePackageHealth_565215 = ref object of OpenApiRestCall_563565
proc url_ReportDeployedServicePackageHealth_565217(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "servicePackageName" in path,
        "`servicePackageName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServicePackages/"),
               (kind: VariableSegment, value: "servicePackageName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedServicePackageHealth_565216(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   servicePackageName: JString (required)
  ##                     : The name of the service package.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `servicePackageName` field"
  var valid_565218 = path.getOrDefault("servicePackageName")
  valid_565218 = validateParameter(valid_565218, JString, required = true,
                                 default = nil)
  if valid_565218 != nil:
    section.add "servicePackageName", valid_565218
  var valid_565219 = path.getOrDefault("nodeName")
  valid_565219 = validateParameter(valid_565219, JString, required = true,
                                 default = nil)
  if valid_565219 != nil:
    section.add "nodeName", valid_565219
  var valid_565220 = path.getOrDefault("applicationId")
  valid_565220 = validateParameter(valid_565220, JString, required = true,
                                 default = nil)
  if valid_565220 != nil:
    section.add "applicationId", valid_565220
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565221 = query.getOrDefault("Immediate")
  valid_565221 = validateParameter(valid_565221, JBool, required = false,
                                 default = newJBool(false))
  if valid_565221 != nil:
    section.add "Immediate", valid_565221
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565222 = query.getOrDefault("api-version")
  valid_565222 = validateParameter(valid_565222, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565222 != nil:
    section.add "api-version", valid_565222
  var valid_565223 = query.getOrDefault("timeout")
  valid_565223 = validateParameter(valid_565223, JInt, required = false,
                                 default = newJInt(60))
  if valid_565223 != nil:
    section.add "timeout", valid_565223
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565225: Call_ReportDeployedServicePackageHealth_565215;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565225.validator(path, query, header, formData, body)
  let scheme = call_565225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565225.url(scheme.get, call_565225.host, call_565225.base,
                         call_565225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565225, url, valid)

proc call*(call_565226: Call_ReportDeployedServicePackageHealth_565215;
          servicePackageName: string; HealthInformation: JsonNode; nodeName: string;
          applicationId: string; Immediate: bool = false; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## reportDeployedServicePackageHealth
  ## Reports health state of the service package of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed service package health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   servicePackageName: string (required)
  ##                     : The name of the service package.
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565227 = newJObject()
  var query_565228 = newJObject()
  var body_565229 = newJObject()
  add(query_565228, "Immediate", newJBool(Immediate))
  add(path_565227, "servicePackageName", newJString(servicePackageName))
  if HealthInformation != nil:
    body_565229 = HealthInformation
  add(query_565228, "api-version", newJString(apiVersion))
  add(query_565228, "timeout", newJInt(timeout))
  add(path_565227, "nodeName", newJString(nodeName))
  add(path_565227, "applicationId", newJString(applicationId))
  result = call_565226.call(path_565227, query_565228, nil, nil, body_565229)

var reportDeployedServicePackageHealth* = Call_ReportDeployedServicePackageHealth_565215(
    name: "reportDeployedServicePackageHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth",
    validator: validate_ReportDeployedServicePackageHealth_565216, base: "",
    url: url_ReportDeployedServicePackageHealth_565217,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoList_565230 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServiceTypeInfoList_565232(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoList_565231(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565233 = path.getOrDefault("nodeName")
  valid_565233 = validateParameter(valid_565233, JString, required = true,
                                 default = nil)
  if valid_565233 != nil:
    section.add "nodeName", valid_565233
  var valid_565234 = path.getOrDefault("applicationId")
  valid_565234 = validateParameter(valid_565234, JString, required = true,
                                 default = nil)
  if valid_565234 != nil:
    section.add "applicationId", valid_565234
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565235 = query.getOrDefault("api-version")
  valid_565235 = validateParameter(valid_565235, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565235 != nil:
    section.add "api-version", valid_565235
  var valid_565236 = query.getOrDefault("timeout")
  valid_565236 = validateParameter(valid_565236, JInt, required = false,
                                 default = newJInt(60))
  if valid_565236 != nil:
    section.add "timeout", valid_565236
  var valid_565237 = query.getOrDefault("ServiceManifestName")
  valid_565237 = validateParameter(valid_565237, JString, required = false,
                                 default = nil)
  if valid_565237 != nil:
    section.add "ServiceManifestName", valid_565237
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565238: Call_GetDeployedServiceTypeInfoList_565230; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ## 
  let valid = call_565238.validator(path, query, header, formData, body)
  let scheme = call_565238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565238.url(scheme.get, call_565238.host, call_565238.base,
                         call_565238.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565238, url, valid)

proc call*(call_565239: Call_GetDeployedServiceTypeInfoList_565230;
          nodeName: string; applicationId: string; apiVersion: string = "6.0";
          timeout: int = 60; ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoList
  ## Gets the list containing the information about service types from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565240 = newJObject()
  var query_565241 = newJObject()
  add(query_565241, "api-version", newJString(apiVersion))
  add(query_565241, "timeout", newJInt(timeout))
  add(path_565240, "nodeName", newJString(nodeName))
  add(query_565241, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_565240, "applicationId", newJString(applicationId))
  result = call_565239.call(path_565240, query_565241, nil, nil, nil)

var getDeployedServiceTypeInfoList* = Call_GetDeployedServiceTypeInfoList_565230(
    name: "getDeployedServiceTypeInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes",
    validator: validate_GetDeployedServiceTypeInfoList_565231, base: "",
    url: url_GetDeployedServiceTypeInfoList_565232,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceTypeInfoByName_565242 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServiceTypeInfoByName_565244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  assert "serviceTypeName" in path, "`serviceTypeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/GetServiceTypes/"),
               (kind: VariableSegment, value: "serviceTypeName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceTypeInfoByName_565243(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceTypeName: JString (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `serviceTypeName` field"
  var valid_565245 = path.getOrDefault("serviceTypeName")
  valid_565245 = validateParameter(valid_565245, JString, required = true,
                                 default = nil)
  if valid_565245 != nil:
    section.add "serviceTypeName", valid_565245
  var valid_565246 = path.getOrDefault("nodeName")
  valid_565246 = validateParameter(valid_565246, JString, required = true,
                                 default = nil)
  if valid_565246 != nil:
    section.add "nodeName", valid_565246
  var valid_565247 = path.getOrDefault("applicationId")
  valid_565247 = validateParameter(valid_565247, JString, required = true,
                                 default = nil)
  if valid_565247 != nil:
    section.add "applicationId", valid_565247
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ServiceManifestName: JString
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565248 = query.getOrDefault("api-version")
  valid_565248 = validateParameter(valid_565248, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565248 != nil:
    section.add "api-version", valid_565248
  var valid_565249 = query.getOrDefault("timeout")
  valid_565249 = validateParameter(valid_565249, JInt, required = false,
                                 default = newJInt(60))
  if valid_565249 != nil:
    section.add "timeout", valid_565249
  var valid_565250 = query.getOrDefault("ServiceManifestName")
  valid_565250 = validateParameter(valid_565250, JString, required = false,
                                 default = nil)
  if valid_565250 != nil:
    section.add "ServiceManifestName", valid_565250
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565251: Call_GetDeployedServiceTypeInfoByName_565242;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ## 
  let valid = call_565251.validator(path, query, header, formData, body)
  let scheme = call_565251.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565251.url(scheme.get, call_565251.host, call_565251.base,
                         call_565251.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565251, url, valid)

proc call*(call_565252: Call_GetDeployedServiceTypeInfoByName_565242;
          serviceTypeName: string; nodeName: string; applicationId: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          ServiceManifestName: string = ""): Recallable =
  ## getDeployedServiceTypeInfoByName
  ## Gets the list containing the information about a specific service type from the applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration status, the code package that registered it and activation id of the service package. Each entry represents one activation of a service type, differentiated by the activation id.
  ##   serviceTypeName: string (required)
  ##                  : Specifies the name of a Service Fabric service type.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   ServiceManifestName: string
  ##                      : The name of the service manifest to filter the list of deployed service type information. If specified, the response will only contain the information about service types that are defined in this service manifest.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565253 = newJObject()
  var query_565254 = newJObject()
  add(path_565253, "serviceTypeName", newJString(serviceTypeName))
  add(query_565254, "api-version", newJString(apiVersion))
  add(query_565254, "timeout", newJInt(timeout))
  add(path_565253, "nodeName", newJString(nodeName))
  add(query_565254, "ServiceManifestName", newJString(ServiceManifestName))
  add(path_565253, "applicationId", newJString(applicationId))
  result = call_565252.call(path_565253, query_565254, nil, nil, nil)

var getDeployedServiceTypeInfoByName* = Call_GetDeployedServiceTypeInfoByName_565242(
    name: "getDeployedServiceTypeInfoByName", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}",
    validator: validate_GetDeployedServiceTypeInfoByName_565243, base: "",
    url: url_GetDeployedServiceTypeInfoByName_565244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportDeployedApplicationHealth_565255 = ref object of OpenApiRestCall_563565
proc url_ReportDeployedApplicationHealth_565257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "applicationId" in path, "`applicationId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetApplications/"),
               (kind: VariableSegment, value: "applicationId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportDeployedApplicationHealth_565256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   applicationId: JString (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565258 = path.getOrDefault("nodeName")
  valid_565258 = validateParameter(valid_565258, JString, required = true,
                                 default = nil)
  if valid_565258 != nil:
    section.add "nodeName", valid_565258
  var valid_565259 = path.getOrDefault("applicationId")
  valid_565259 = validateParameter(valid_565259, JString, required = true,
                                 default = nil)
  if valid_565259 != nil:
    section.add "applicationId", valid_565259
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565260 = query.getOrDefault("Immediate")
  valid_565260 = validateParameter(valid_565260, JBool, required = false,
                                 default = newJBool(false))
  if valid_565260 != nil:
    section.add "Immediate", valid_565260
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565261 = query.getOrDefault("api-version")
  valid_565261 = validateParameter(valid_565261, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565261 != nil:
    section.add "api-version", valid_565261
  var valid_565262 = query.getOrDefault("timeout")
  valid_565262 = validateParameter(valid_565262, JInt, required = false,
                                 default = newJInt(60))
  if valid_565262 != nil:
    section.add "timeout", valid_565262
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565264: Call_ReportDeployedApplicationHealth_565255;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565264.validator(path, query, header, formData, body)
  let scheme = call_565264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565264.url(scheme.get, call_565264.host, call_565264.base,
                         call_565264.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565264, url, valid)

proc call*(call_565265: Call_ReportDeployedApplicationHealth_565255;
          HealthInformation: JsonNode; nodeName: string; applicationId: string;
          Immediate: bool = false; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## reportDeployedApplicationHealth
  ## Reports health state of the application deployed on a Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, get deployed application health and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   applicationId: string (required)
  ##                : The identity of the application. This is typically the full name of the application without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the application name is "fabric://myapp/app1", the application identity would be "myapp~app1" in 6.0+ and "myapp/app1" in previous versions.
  var path_565266 = newJObject()
  var query_565267 = newJObject()
  var body_565268 = newJObject()
  add(query_565267, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_565268 = HealthInformation
  add(query_565267, "api-version", newJString(apiVersion))
  add(query_565267, "timeout", newJInt(timeout))
  add(path_565266, "nodeName", newJString(nodeName))
  add(path_565266, "applicationId", newJString(applicationId))
  result = call_565265.call(path_565266, query_565267, nil, nil, body_565268)

var reportDeployedApplicationHealth* = Call_ReportDeployedApplicationHealth_565255(
    name: "reportDeployedApplicationHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth",
    validator: validate_ReportDeployedApplicationHealth_565256, base: "",
    url: url_ReportDeployedApplicationHealth_565257,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealthUsingPolicy_565280 = ref object of OpenApiRestCall_563565
proc url_GetNodeHealthUsingPolicy_565282(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealthUsingPolicy_565281(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565283 = path.getOrDefault("nodeName")
  valid_565283 = validateParameter(valid_565283, JString, required = true,
                                 default = nil)
  if valid_565283 != nil:
    section.add "nodeName", valid_565283
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565284 = query.getOrDefault("api-version")
  valid_565284 = validateParameter(valid_565284, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565284 != nil:
    section.add "api-version", valid_565284
  var valid_565285 = query.getOrDefault("timeout")
  valid_565285 = validateParameter(valid_565285, JInt, required = false,
                                 default = newJInt(60))
  if valid_565285 != nil:
    section.add "timeout", valid_565285
  var valid_565286 = query.getOrDefault("EventsHealthStateFilter")
  valid_565286 = validateParameter(valid_565286, JInt, required = false,
                                 default = newJInt(0))
  if valid_565286 != nil:
    section.add "EventsHealthStateFilter", valid_565286
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565288: Call_GetNodeHealthUsingPolicy_565280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_565288.validator(path, query, header, formData, body)
  let scheme = call_565288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565288.url(scheme.get, call_565288.host, call_565288.base,
                         call_565288.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565288, url, valid)

proc call*(call_565289: Call_GetNodeHealthUsingPolicy_565280; nodeName: string;
          apiVersion: string = "6.0"; ClusterHealthPolicy: JsonNode = nil;
          timeout: int = 60; EventsHealthStateFilter: int = 0): Recallable =
  ## getNodeHealthUsingPolicy
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body to override the health policies used to evaluate the health. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ClusterHealthPolicy: JObject
  ##                      : Describes the health policies used to evaluate the health of a cluster or node. If not present, the health evaluation uses the health policy from cluster manifest or the default health policy.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565290 = newJObject()
  var query_565291 = newJObject()
  var body_565292 = newJObject()
  add(query_565291, "api-version", newJString(apiVersion))
  if ClusterHealthPolicy != nil:
    body_565292 = ClusterHealthPolicy
  add(query_565291, "timeout", newJInt(timeout))
  add(path_565290, "nodeName", newJString(nodeName))
  add(query_565291, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_565289.call(path_565290, query_565291, nil, nil, body_565292)

var getNodeHealthUsingPolicy* = Call_GetNodeHealthUsingPolicy_565280(
    name: "getNodeHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetHealth",
    validator: validate_GetNodeHealthUsingPolicy_565281, base: "",
    url: url_GetNodeHealthUsingPolicy_565282, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeHealth_565269 = ref object of OpenApiRestCall_563565
proc url_GetNodeHealth_565271(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeHealth_565270(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565272 = path.getOrDefault("nodeName")
  valid_565272 = validateParameter(valid_565272, JString, required = true,
                                 default = nil)
  if valid_565272 != nil:
    section.add "nodeName", valid_565272
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565273 = query.getOrDefault("api-version")
  valid_565273 = validateParameter(valid_565273, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565273 != nil:
    section.add "api-version", valid_565273
  var valid_565274 = query.getOrDefault("timeout")
  valid_565274 = validateParameter(valid_565274, JInt, required = false,
                                 default = newJInt(60))
  if valid_565274 != nil:
    section.add "timeout", valid_565274
  var valid_565275 = query.getOrDefault("EventsHealthStateFilter")
  valid_565275 = validateParameter(valid_565275, JInt, required = false,
                                 default = newJInt(0))
  if valid_565275 != nil:
    section.add "EventsHealthStateFilter", valid_565275
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565276: Call_GetNodeHealth_565269; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ## 
  let valid = call_565276.validator(path, query, header, formData, body)
  let scheme = call_565276.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565276.url(scheme.get, call_565276.host, call_565276.base,
                         call_565276.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565276, url, valid)

proc call*(call_565277: Call_GetNodeHealth_565269; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getNodeHealth
  ## Gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of health events reported on the node based on the health state. If the node that you specify by name does not exist in the health store, this returns an error.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565278 = newJObject()
  var query_565279 = newJObject()
  add(query_565279, "api-version", newJString(apiVersion))
  add(query_565279, "timeout", newJInt(timeout))
  add(path_565278, "nodeName", newJString(nodeName))
  add(query_565279, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_565277.call(path_565278, query_565279, nil, nil, nil)

var getNodeHealth* = Call_GetNodeHealth_565269(name: "getNodeHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetHealth", validator: validate_GetNodeHealth_565270,
    base: "", url: url_GetNodeHealth_565271, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetNodeLoadInfo_565293 = ref object of OpenApiRestCall_563565
proc url_GetNodeLoadInfo_565295(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetNodeLoadInfo_565294(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Gets the load information of a Service Fabric node.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565296 = path.getOrDefault("nodeName")
  valid_565296 = validateParameter(valid_565296, JString, required = true,
                                 default = nil)
  if valid_565296 != nil:
    section.add "nodeName", valid_565296
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565297 = query.getOrDefault("api-version")
  valid_565297 = validateParameter(valid_565297, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565297 != nil:
    section.add "api-version", valid_565297
  var valid_565298 = query.getOrDefault("timeout")
  valid_565298 = validateParameter(valid_565298, JInt, required = false,
                                 default = newJInt(60))
  if valid_565298 != nil:
    section.add "timeout", valid_565298
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565299: Call_GetNodeLoadInfo_565293; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the load information of a Service Fabric node.
  ## 
  let valid = call_565299.validator(path, query, header, formData, body)
  let scheme = call_565299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565299.url(scheme.get, call_565299.host, call_565299.base,
                         call_565299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565299, url, valid)

proc call*(call_565300: Call_GetNodeLoadInfo_565293; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getNodeLoadInfo
  ## Gets the load information of a Service Fabric node.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565301 = newJObject()
  var query_565302 = newJObject()
  add(query_565302, "api-version", newJString(apiVersion))
  add(query_565302, "timeout", newJInt(timeout))
  add(path_565301, "nodeName", newJString(nodeName))
  result = call_565300.call(path_565301, query_565302, nil, nil, nil)

var getNodeLoadInfo* = Call_GetNodeLoadInfo_565293(name: "getNodeLoadInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetLoadInformation",
    validator: validate_GetNodeLoadInfo_565294, base: "", url: url_GetNodeLoadInfo_565295,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfoByPartitionId_565303 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServiceReplicaDetailInfoByPartitionId_565305(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfoByPartitionId_565304(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565306 = path.getOrDefault("nodeName")
  valid_565306 = validateParameter(valid_565306, JString, required = true,
                                 default = nil)
  if valid_565306 != nil:
    section.add "nodeName", valid_565306
  var valid_565307 = path.getOrDefault("partitionId")
  valid_565307 = validateParameter(valid_565307, JString, required = true,
                                 default = nil)
  if valid_565307 != nil:
    section.add "partitionId", valid_565307
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565308 = query.getOrDefault("api-version")
  valid_565308 = validateParameter(valid_565308, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565308 != nil:
    section.add "api-version", valid_565308
  var valid_565309 = query.getOrDefault("timeout")
  valid_565309 = validateParameter(valid_565309, JInt, required = false,
                                 default = newJInt(60))
  if valid_565309 != nil:
    section.add "timeout", valid_565309
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565310: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_565303;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_565310.validator(path, query, header, formData, body)
  let scheme = call_565310.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565310.url(scheme.get, call_565310.host, call_565310.base,
                         call_565310.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565310, url, valid)

proc call*(call_565311: Call_GetDeployedServiceReplicaDetailInfoByPartitionId_565303;
          nodeName: string; partitionId: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## getDeployedServiceReplicaDetailInfoByPartitionId
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565312 = newJObject()
  var query_565313 = newJObject()
  add(query_565313, "api-version", newJString(apiVersion))
  add(query_565313, "timeout", newJInt(timeout))
  add(path_565312, "nodeName", newJString(nodeName))
  add(path_565312, "partitionId", newJString(partitionId))
  result = call_565311.call(path_565312, query_565313, nil, nil, nil)

var getDeployedServiceReplicaDetailInfoByPartitionId* = Call_GetDeployedServiceReplicaDetailInfoByPartitionId_565303(
    name: "getDeployedServiceReplicaDetailInfoByPartitionId",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas",
    validator: validate_GetDeployedServiceReplicaDetailInfoByPartitionId_565304,
    base: "", url: url_GetDeployedServiceReplicaDetailInfoByPartitionId_565305,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveReplica_565314 = ref object of OpenApiRestCall_563565
proc url_RemoveReplica_565316(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveReplica_565315(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565317 = path.getOrDefault("replicaId")
  valid_565317 = validateParameter(valid_565317, JString, required = true,
                                 default = nil)
  if valid_565317 != nil:
    section.add "replicaId", valid_565317
  var valid_565318 = path.getOrDefault("nodeName")
  valid_565318 = validateParameter(valid_565318, JString, required = true,
                                 default = nil)
  if valid_565318 != nil:
    section.add "nodeName", valid_565318
  var valid_565319 = path.getOrDefault("partitionId")
  valid_565319 = validateParameter(valid_565319, JString, required = true,
                                 default = nil)
  if valid_565319 != nil:
    section.add "partitionId", valid_565319
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565320 = query.getOrDefault("api-version")
  valid_565320 = validateParameter(valid_565320, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565320 != nil:
    section.add "api-version", valid_565320
  var valid_565321 = query.getOrDefault("timeout")
  valid_565321 = validateParameter(valid_565321, JInt, required = false,
                                 default = newJInt(60))
  if valid_565321 != nil:
    section.add "timeout", valid_565321
  var valid_565322 = query.getOrDefault("ForceRemove")
  valid_565322 = validateParameter(valid_565322, JBool, required = false, default = nil)
  if valid_565322 != nil:
    section.add "ForceRemove", valid_565322
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565323: Call_RemoveReplica_565314; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ## 
  let valid = call_565323.validator(path, query, header, formData, body)
  let scheme = call_565323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565323.url(scheme.get, call_565323.host, call_565323.base,
                         call_565323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565323, url, valid)

proc call*(call_565324: Call_RemoveReplica_565314; replicaId: string;
          nodeName: string; partitionId: string; apiVersion: string = "6.0";
          timeout: int = 60; ForceRemove: bool = false): Recallable =
  ## removeReplica
  ## This API simulates a Service Fabric replica failure by removing a replica from a Service Fabric cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state information of the replica from the cluster. This API tests the replica state removal path, and simulates the report fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all other replicas hosted in the same process.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  var path_565325 = newJObject()
  var query_565326 = newJObject()
  add(path_565325, "replicaId", newJString(replicaId))
  add(query_565326, "api-version", newJString(apiVersion))
  add(query_565326, "timeout", newJInt(timeout))
  add(path_565325, "nodeName", newJString(nodeName))
  add(path_565325, "partitionId", newJString(partitionId))
  add(query_565326, "ForceRemove", newJBool(ForceRemove))
  result = call_565324.call(path_565325, query_565326, nil, nil, nil)

var removeReplica* = Call_RemoveReplica_565314(name: "removeReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete",
    validator: validate_RemoveReplica_565315, base: "", url: url_RemoveReplica_565316,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeployedServiceReplicaDetailInfo_565327 = ref object of OpenApiRestCall_563565
proc url_GetDeployedServiceReplicaDetailInfo_565329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetDetail")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetDeployedServiceReplicaDetailInfo_565328(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565330 = path.getOrDefault("replicaId")
  valid_565330 = validateParameter(valid_565330, JString, required = true,
                                 default = nil)
  if valid_565330 != nil:
    section.add "replicaId", valid_565330
  var valid_565331 = path.getOrDefault("nodeName")
  valid_565331 = validateParameter(valid_565331, JString, required = true,
                                 default = nil)
  if valid_565331 != nil:
    section.add "nodeName", valid_565331
  var valid_565332 = path.getOrDefault("partitionId")
  valid_565332 = validateParameter(valid_565332, JString, required = true,
                                 default = nil)
  if valid_565332 != nil:
    section.add "partitionId", valid_565332
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565333 = query.getOrDefault("api-version")
  valid_565333 = validateParameter(valid_565333, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565333 != nil:
    section.add "api-version", valid_565333
  var valid_565334 = query.getOrDefault("timeout")
  valid_565334 = validateParameter(valid_565334, JInt, required = false,
                                 default = newJInt(60))
  if valid_565334 != nil:
    section.add "timeout", valid_565334
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565335: Call_GetDeployedServiceReplicaDetailInfo_565327;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ## 
  let valid = call_565335.validator(path, query, header, formData, body)
  let scheme = call_565335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565335.url(scheme.get, call_565335.host, call_565335.base,
                         call_565335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565335, url, valid)

proc call*(call_565336: Call_GetDeployedServiceReplicaDetailInfo_565327;
          replicaId: string; nodeName: string; partitionId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getDeployedServiceReplicaDetailInfo
  ## Gets the details of the replica deployed on a Service Fabric node. The information include service kind, service name, current service operation, current service operation start date time, partition id, replica/instance id, reported load and other information.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565337 = newJObject()
  var query_565338 = newJObject()
  add(path_565337, "replicaId", newJString(replicaId))
  add(query_565338, "api-version", newJString(apiVersion))
  add(query_565338, "timeout", newJInt(timeout))
  add(path_565337, "nodeName", newJString(nodeName))
  add(path_565337, "partitionId", newJString(partitionId))
  result = call_565336.call(path_565337, query_565338, nil, nil, nil)

var getDeployedServiceReplicaDetailInfo* = Call_GetDeployedServiceReplicaDetailInfo_565327(
    name: "getDeployedServiceReplicaDetailInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail",
    validator: validate_GetDeployedServiceReplicaDetailInfo_565328, base: "",
    url: url_GetDeployedServiceReplicaDetailInfo_565329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartReplica_565339 = ref object of OpenApiRestCall_563565
proc url_RestartReplica_565341(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/GetPartitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartReplica_565340(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   nodeName: JString (required)
  ##           : The name of the node.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565342 = path.getOrDefault("replicaId")
  valid_565342 = validateParameter(valid_565342, JString, required = true,
                                 default = nil)
  if valid_565342 != nil:
    section.add "replicaId", valid_565342
  var valid_565343 = path.getOrDefault("nodeName")
  valid_565343 = validateParameter(valid_565343, JString, required = true,
                                 default = nil)
  if valid_565343 != nil:
    section.add "nodeName", valid_565343
  var valid_565344 = path.getOrDefault("partitionId")
  valid_565344 = validateParameter(valid_565344, JString, required = true,
                                 default = nil)
  if valid_565344 != nil:
    section.add "partitionId", valid_565344
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565345 = query.getOrDefault("api-version")
  valid_565345 = validateParameter(valid_565345, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565345 != nil:
    section.add "api-version", valid_565345
  var valid_565346 = query.getOrDefault("timeout")
  valid_565346 = validateParameter(valid_565346, JInt, required = false,
                                 default = newJInt(60))
  if valid_565346 != nil:
    section.add "timeout", valid_565346
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565347: Call_RestartReplica_565339; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ## 
  let valid = call_565347.validator(path, query, header, formData, body)
  let scheme = call_565347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565347.url(scheme.get, call_565347.host, call_565347.base,
                         call_565347.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565347, url, valid)

proc call*(call_565348: Call_RestartReplica_565339; replicaId: string;
          nodeName: string; partitionId: string; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## restartReplica
  ## Restarts a service replica of a persisted service running on a node. Warning - There are no safety checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful services.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565349 = newJObject()
  var query_565350 = newJObject()
  add(path_565349, "replicaId", newJString(replicaId))
  add(query_565350, "api-version", newJString(apiVersion))
  add(query_565350, "timeout", newJInt(timeout))
  add(path_565349, "nodeName", newJString(nodeName))
  add(path_565349, "partitionId", newJString(partitionId))
  result = call_565348.call(path_565349, query_565350, nil, nil, nil)

var restartReplica* = Call_RestartReplica_565339(name: "restartReplica",
    meth: HttpMethod.HttpPost, host: "azure.local:19080", route: "/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart",
    validator: validate_RestartReplica_565340, base: "", url: url_RestartReplica_565341,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_RemoveNodeState_565351 = ref object of OpenApiRestCall_563565
proc url_RemoveNodeState_565353(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/RemoveNodeState")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RemoveNodeState_565352(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565354 = path.getOrDefault("nodeName")
  valid_565354 = validateParameter(valid_565354, JString, required = true,
                                 default = nil)
  if valid_565354 != nil:
    section.add "nodeName", valid_565354
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565355 = query.getOrDefault("api-version")
  valid_565355 = validateParameter(valid_565355, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565355 != nil:
    section.add "api-version", valid_565355
  var valid_565356 = query.getOrDefault("timeout")
  valid_565356 = validateParameter(valid_565356, JInt, required = false,
                                 default = newJInt(60))
  if valid_565356 != nil:
    section.add "timeout", valid_565356
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565357: Call_RemoveNodeState_565351; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ## 
  let valid = call_565357.validator(path, query, header, formData, body)
  let scheme = call_565357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565357.url(scheme.get, call_565357.host, call_565357.base,
                         call_565357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565357, url, valid)

proc call*(call_565358: Call_RemoveNodeState_565351; nodeName: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## removeNodeState
  ## Notifies Service Fabric that the persisted state on a node has been permanently removed or lost.  This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful. This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been removed and the node can comes back up with its state intact.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565359 = newJObject()
  var query_565360 = newJObject()
  add(query_565360, "api-version", newJString(apiVersion))
  add(query_565360, "timeout", newJInt(timeout))
  add(path_565359, "nodeName", newJString(nodeName))
  result = call_565358.call(path_565359, query_565360, nil, nil, nil)

var removeNodeState* = Call_RemoveNodeState_565351(name: "removeNodeState",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/RemoveNodeState",
    validator: validate_RemoveNodeState_565352, base: "", url: url_RemoveNodeState_565353,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportNodeHealth_565361 = ref object of OpenApiRestCall_563565
proc url_ReportNodeHealth_565363(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportNodeHealth_565362(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565364 = path.getOrDefault("nodeName")
  valid_565364 = validateParameter(valid_565364, JString, required = true,
                                 default = nil)
  if valid_565364 != nil:
    section.add "nodeName", valid_565364
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565365 = query.getOrDefault("Immediate")
  valid_565365 = validateParameter(valid_565365, JBool, required = false,
                                 default = newJBool(false))
  if valid_565365 != nil:
    section.add "Immediate", valid_565365
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565366 = query.getOrDefault("api-version")
  valid_565366 = validateParameter(valid_565366, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565366 != nil:
    section.add "api-version", valid_565366
  var valid_565367 = query.getOrDefault("timeout")
  valid_565367 = validateParameter(valid_565367, JInt, required = false,
                                 default = newJInt(60))
  if valid_565367 != nil:
    section.add "timeout", valid_565367
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565369: Call_ReportNodeHealth_565361; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565369.validator(path, query, header, formData, body)
  let scheme = call_565369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565369.url(scheme.get, call_565369.host, call_565369.base,
                         call_565369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565369, url, valid)

proc call*(call_565370: Call_ReportNodeHealth_565361; HealthInformation: JsonNode;
          nodeName: string; Immediate: bool = false; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## reportNodeHealth
  ## Reports health state of the specified Service Fabric node. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway node, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  var path_565371 = newJObject()
  var query_565372 = newJObject()
  var body_565373 = newJObject()
  add(query_565372, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_565373 = HealthInformation
  add(query_565372, "api-version", newJString(apiVersion))
  add(query_565372, "timeout", newJInt(timeout))
  add(path_565371, "nodeName", newJString(nodeName))
  result = call_565370.call(path_565371, query_565372, nil, nil, body_565373)

var reportNodeHealth* = Call_ReportNodeHealth_565361(name: "reportNodeHealth",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Nodes/{nodeName}/$/ReportHealth",
    validator: validate_ReportNodeHealth_565362, base: "",
    url: url_ReportNodeHealth_565363, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RestartNode_565374 = ref object of OpenApiRestCall_563565
proc url_RestartNode_565376(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "nodeName" in path, "`nodeName` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Nodes/"),
               (kind: VariableSegment, value: "nodeName"),
               (kind: ConstantSegment, value: "/$/Restart")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RestartNode_565375(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   nodeName: JString (required)
  ##           : The name of the node.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `nodeName` field"
  var valid_565377 = path.getOrDefault("nodeName")
  valid_565377 = validateParameter(valid_565377, JString, required = true,
                                 default = nil)
  if valid_565377 != nil:
    section.add "nodeName", valid_565377
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565378 = query.getOrDefault("api-version")
  valid_565378 = validateParameter(valid_565378, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565378 != nil:
    section.add "api-version", valid_565378
  var valid_565379 = query.getOrDefault("timeout")
  valid_565379 = validateParameter(valid_565379, JInt, required = false,
                                 default = newJInt(60))
  if valid_565379 != nil:
    section.add "timeout", valid_565379
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565381: Call_RestartNode_565374; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Restarts a Service Fabric cluster node that is already started.
  ## 
  let valid = call_565381.validator(path, query, header, formData, body)
  let scheme = call_565381.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565381.url(scheme.get, call_565381.host, call_565381.base,
                         call_565381.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565381, url, valid)

proc call*(call_565382: Call_RestartNode_565374; nodeName: string;
          RestartNodeDescription: JsonNode; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## restartNode
  ## Restarts a Service Fabric cluster node that is already started.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   nodeName: string (required)
  ##           : The name of the node.
  ##   RestartNodeDescription: JObject (required)
  ##                         : The instance of the node to be restarted and a flag indicating the need to take dump of the fabric process.
  var path_565383 = newJObject()
  var query_565384 = newJObject()
  var body_565385 = newJObject()
  add(query_565384, "api-version", newJString(apiVersion))
  add(query_565384, "timeout", newJInt(timeout))
  add(path_565383, "nodeName", newJString(nodeName))
  if RestartNodeDescription != nil:
    body_565385 = RestartNodeDescription
  result = call_565382.call(path_565383, query_565384, nil, nil, body_565385)

var restartNode* = Call_RestartNode_565374(name: "restartNode",
                                        meth: HttpMethod.HttpPost,
                                        host: "azure.local:19080",
                                        route: "/Nodes/{nodeName}/$/Restart",
                                        validator: validate_RestartNode_565375,
                                        base: "", url: url_RestartNode_565376,
                                        schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfo_565386 = ref object of OpenApiRestCall_563565
proc url_GetPartitionInfo_565388(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfo_565387(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565389 = path.getOrDefault("partitionId")
  valid_565389 = validateParameter(valid_565389, JString, required = true,
                                 default = nil)
  if valid_565389 != nil:
    section.add "partitionId", valid_565389
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565390 = query.getOrDefault("api-version")
  valid_565390 = validateParameter(valid_565390, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565390 != nil:
    section.add "api-version", valid_565390
  var valid_565391 = query.getOrDefault("timeout")
  valid_565391 = validateParameter(valid_565391, JInt, required = false,
                                 default = newJInt(60))
  if valid_565391 != nil:
    section.add "timeout", valid_565391
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565392: Call_GetPartitionInfo_565386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_565392.validator(path, query, header, formData, body)
  let scheme = call_565392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565392.url(scheme.get, call_565392.host, call_565392.base,
                         call_565392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565392, url, valid)

proc call*(call_565393: Call_GetPartitionInfo_565386; partitionId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getPartitionInfo
  ## The Partitions endpoint returns information about the specified partition. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565394 = newJObject()
  var query_565395 = newJObject()
  add(query_565395, "api-version", newJString(apiVersion))
  add(query_565395, "timeout", newJInt(timeout))
  add(path_565394, "partitionId", newJString(partitionId))
  result = call_565393.call(path_565394, query_565395, nil, nil, nil)

var getPartitionInfo* = Call_GetPartitionInfo_565386(name: "getPartitionInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}", validator: validate_GetPartitionInfo_565387,
    base: "", url: url_GetPartitionInfo_565388, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealthUsingPolicy_565409 = ref object of OpenApiRestCall_563565
proc url_GetPartitionHealthUsingPolicy_565411(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealthUsingPolicy_565410(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565412 = path.getOrDefault("partitionId")
  valid_565412 = validateParameter(valid_565412, JString, required = true,
                                 default = nil)
  if valid_565412 != nil:
    section.add "partitionId", valid_565412
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565413 = query.getOrDefault("api-version")
  valid_565413 = validateParameter(valid_565413, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565413 != nil:
    section.add "api-version", valid_565413
  var valid_565414 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565414 = validateParameter(valid_565414, JBool, required = false,
                                 default = newJBool(false))
  if valid_565414 != nil:
    section.add "ExcludeHealthStatistics", valid_565414
  var valid_565415 = query.getOrDefault("timeout")
  valid_565415 = validateParameter(valid_565415, JInt, required = false,
                                 default = newJInt(60))
  if valid_565415 != nil:
    section.add "timeout", valid_565415
  var valid_565416 = query.getOrDefault("EventsHealthStateFilter")
  valid_565416 = validateParameter(valid_565416, JInt, required = false,
                                 default = newJInt(0))
  if valid_565416 != nil:
    section.add "EventsHealthStateFilter", valid_565416
  var valid_565417 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_565417 = validateParameter(valid_565417, JInt, required = false,
                                 default = newJInt(0))
  if valid_565417 != nil:
    section.add "ReplicasHealthStateFilter", valid_565417
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565419: Call_GetPartitionHealthUsingPolicy_565409; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_565419.validator(path, query, header, formData, body)
  let scheme = call_565419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565419.url(scheme.get, call_565419.host, call_565419.base,
                         call_565419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565419, url, valid)

proc call*(call_565420: Call_GetPartitionHealthUsingPolicy_565409;
          partitionId: string; ApplicationHealthPolicy: JsonNode = nil;
          apiVersion: string = "6.0"; ExcludeHealthStatistics: bool = false;
          timeout: int = 60; EventsHealthStateFilter: int = 0;
          ReplicasHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealthUsingPolicy
  ## Gets the health information of the specified partition.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565421 = newJObject()
  var query_565422 = newJObject()
  var body_565423 = newJObject()
  if ApplicationHealthPolicy != nil:
    body_565423 = ApplicationHealthPolicy
  add(query_565422, "api-version", newJString(apiVersion))
  add(query_565422, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565422, "timeout", newJInt(timeout))
  add(path_565421, "partitionId", newJString(partitionId))
  add(query_565422, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_565422, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  result = call_565420.call(path_565421, query_565422, nil, nil, body_565423)

var getPartitionHealthUsingPolicy* = Call_GetPartitionHealthUsingPolicy_565409(
    name: "getPartitionHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealthUsingPolicy_565410, base: "",
    url: url_GetPartitionHealthUsingPolicy_565411,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionHealth_565396 = ref object of OpenApiRestCall_563565
proc url_GetPartitionHealth_565398(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionHealth_565397(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565399 = path.getOrDefault("partitionId")
  valid_565399 = validateParameter(valid_565399, JString, required = true,
                                 default = nil)
  if valid_565399 != nil:
    section.add "partitionId", valid_565399
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ReplicasHealthStateFilter: JInt
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565400 = query.getOrDefault("api-version")
  valid_565400 = validateParameter(valid_565400, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565400 != nil:
    section.add "api-version", valid_565400
  var valid_565401 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565401 = validateParameter(valid_565401, JBool, required = false,
                                 default = newJBool(false))
  if valid_565401 != nil:
    section.add "ExcludeHealthStatistics", valid_565401
  var valid_565402 = query.getOrDefault("timeout")
  valid_565402 = validateParameter(valid_565402, JInt, required = false,
                                 default = newJInt(60))
  if valid_565402 != nil:
    section.add "timeout", valid_565402
  var valid_565403 = query.getOrDefault("EventsHealthStateFilter")
  valid_565403 = validateParameter(valid_565403, JInt, required = false,
                                 default = newJInt(0))
  if valid_565403 != nil:
    section.add "EventsHealthStateFilter", valid_565403
  var valid_565404 = query.getOrDefault("ReplicasHealthStateFilter")
  valid_565404 = validateParameter(valid_565404, JInt, required = false,
                                 default = newJInt(0))
  if valid_565404 != nil:
    section.add "ReplicasHealthStateFilter", valid_565404
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565405: Call_GetPartitionHealth_565396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_565405.validator(path, query, header, formData, body)
  let scheme = call_565405.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565405.url(scheme.get, call_565405.host, call_565405.base,
                         call_565405.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565405, url, valid)

proc call*(call_565406: Call_GetPartitionHealth_565396; partitionId: string;
          apiVersion: string = "6.0"; ExcludeHealthStatistics: bool = false;
          timeout: int = 60; EventsHealthStateFilter: int = 0;
          ReplicasHealthStateFilter: int = 0): Recallable =
  ## getPartitionHealth
  ## Gets the health information of the specified partition.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
  ## If you specify a partition that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ReplicasHealthStateFilter: int
  ##                            : Allows filtering the collection of ReplicaHealthState objects on the partition. The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas that match the filter will be returned. All replicas will be used to evaluate the aggregated health state. If not specified, all entries will be returned.The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The possible values for this parameter include integer value of one of the following health states.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565407 = newJObject()
  var query_565408 = newJObject()
  add(query_565408, "api-version", newJString(apiVersion))
  add(query_565408, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565408, "timeout", newJInt(timeout))
  add(path_565407, "partitionId", newJString(partitionId))
  add(query_565408, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(query_565408, "ReplicasHealthStateFilter",
      newJInt(ReplicasHealthStateFilter))
  result = call_565406.call(path_565407, query_565408, nil, nil, nil)

var getPartitionHealth* = Call_GetPartitionHealth_565396(
    name: "getPartitionHealth", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetHealth",
    validator: validate_GetPartitionHealth_565397, base: "",
    url: url_GetPartitionHealth_565398, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionLoadInformation_565424 = ref object of OpenApiRestCall_563565
proc url_GetPartitionLoadInformation_565426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetLoadInformation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionLoadInformation_565425(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565427 = path.getOrDefault("partitionId")
  valid_565427 = validateParameter(valid_565427, JString, required = true,
                                 default = nil)
  if valid_565427 != nil:
    section.add "partitionId", valid_565427
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565428 = query.getOrDefault("api-version")
  valid_565428 = validateParameter(valid_565428, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565428 != nil:
    section.add "api-version", valid_565428
  var valid_565429 = query.getOrDefault("timeout")
  valid_565429 = validateParameter(valid_565429, JInt, required = false,
                                 default = newJInt(60))
  if valid_565429 != nil:
    section.add "timeout", valid_565429
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565430: Call_GetPartitionLoadInformation_565424; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ## 
  let valid = call_565430.validator(path, query, header, formData, body)
  let scheme = call_565430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565430.url(scheme.get, call_565430.host, call_565430.base,
                         call_565430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565430, url, valid)

proc call*(call_565431: Call_GetPartitionLoadInformation_565424;
          partitionId: string; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getPartitionLoadInformation
  ## Returns information about the specified partition.
  ## The response includes a list of load information.
  ## Each information includes load metric name, value and last reported time in UTC.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565432 = newJObject()
  var query_565433 = newJObject()
  add(query_565433, "api-version", newJString(apiVersion))
  add(query_565433, "timeout", newJInt(timeout))
  add(path_565432, "partitionId", newJString(partitionId))
  result = call_565431.call(path_565432, query_565433, nil, nil, nil)

var getPartitionLoadInformation* = Call_GetPartitionLoadInformation_565424(
    name: "getPartitionLoadInformation", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetLoadInformation",
    validator: validate_GetPartitionLoadInformation_565425, base: "",
    url: url_GetPartitionLoadInformation_565426,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfoList_565434 = ref object of OpenApiRestCall_563565
proc url_GetReplicaInfoList_565436(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfoList_565435(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565437 = path.getOrDefault("partitionId")
  valid_565437 = validateParameter(valid_565437, JString, required = true,
                                 default = nil)
  if valid_565437 != nil:
    section.add "partitionId", valid_565437
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565438 = query.getOrDefault("ContinuationToken")
  valid_565438 = validateParameter(valid_565438, JString, required = false,
                                 default = nil)
  if valid_565438 != nil:
    section.add "ContinuationToken", valid_565438
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565439 = query.getOrDefault("api-version")
  valid_565439 = validateParameter(valid_565439, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565439 != nil:
    section.add "api-version", valid_565439
  var valid_565440 = query.getOrDefault("timeout")
  valid_565440 = validateParameter(valid_565440, JInt, required = false,
                                 default = newJInt(60))
  if valid_565440 != nil:
    section.add "timeout", valid_565440
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565441: Call_GetReplicaInfoList_565434; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_565441.validator(path, query, header, formData, body)
  let scheme = call_565441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565441.url(scheme.get, call_565441.host, call_565441.base,
                         call_565441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565441, url, valid)

proc call*(call_565442: Call_GetReplicaInfoList_565434; partitionId: string;
          ContinuationToken: string = ""; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getReplicaInfoList
  ## The GetReplicas endpoint returns information about the replicas of the specified partition. The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565443 = newJObject()
  var query_565444 = newJObject()
  add(query_565444, "ContinuationToken", newJString(ContinuationToken))
  add(query_565444, "api-version", newJString(apiVersion))
  add(query_565444, "timeout", newJInt(timeout))
  add(path_565443, "partitionId", newJString(partitionId))
  result = call_565442.call(path_565443, query_565444, nil, nil, nil)

var getReplicaInfoList* = Call_GetReplicaInfoList_565434(
    name: "getReplicaInfoList", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas",
    validator: validate_GetReplicaInfoList_565435, base: "",
    url: url_GetReplicaInfoList_565436, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaInfo_565445 = ref object of OpenApiRestCall_563565
proc url_GetReplicaInfo_565447(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaInfo_565446(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565448 = path.getOrDefault("replicaId")
  valid_565448 = validateParameter(valid_565448, JString, required = true,
                                 default = nil)
  if valid_565448 != nil:
    section.add "replicaId", valid_565448
  var valid_565449 = path.getOrDefault("partitionId")
  valid_565449 = validateParameter(valid_565449, JString, required = true,
                                 default = nil)
  if valid_565449 != nil:
    section.add "partitionId", valid_565449
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565450 = query.getOrDefault("ContinuationToken")
  valid_565450 = validateParameter(valid_565450, JString, required = false,
                                 default = nil)
  if valid_565450 != nil:
    section.add "ContinuationToken", valid_565450
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565451 = query.getOrDefault("api-version")
  valid_565451 = validateParameter(valid_565451, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565451 != nil:
    section.add "api-version", valid_565451
  var valid_565452 = query.getOrDefault("timeout")
  valid_565452 = validateParameter(valid_565452, JInt, required = false,
                                 default = newJInt(60))
  if valid_565452 != nil:
    section.add "timeout", valid_565452
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565453: Call_GetReplicaInfo_565445; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ## 
  let valid = call_565453.validator(path, query, header, formData, body)
  let scheme = call_565453.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565453.url(scheme.get, call_565453.host, call_565453.base,
                         call_565453.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565453, url, valid)

proc call*(call_565454: Call_GetReplicaInfo_565445; replicaId: string;
          partitionId: string; ContinuationToken: string = "";
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getReplicaInfo
  ## The respons include the id, role, status, health, node name, uptime, and other details about the replica.
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565455 = newJObject()
  var query_565456 = newJObject()
  add(path_565455, "replicaId", newJString(replicaId))
  add(query_565456, "ContinuationToken", newJString(ContinuationToken))
  add(query_565456, "api-version", newJString(apiVersion))
  add(query_565456, "timeout", newJInt(timeout))
  add(path_565455, "partitionId", newJString(partitionId))
  result = call_565454.call(path_565455, query_565456, nil, nil, nil)

var getReplicaInfo* = Call_GetReplicaInfo_565445(name: "getReplicaInfo",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}",
    validator: validate_GetReplicaInfo_565446, base: "", url: url_GetReplicaInfo_565447,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealthUsingPolicy_565469 = ref object of OpenApiRestCall_563565
proc url_GetReplicaHealthUsingPolicy_565471(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealthUsingPolicy_565470(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565472 = path.getOrDefault("replicaId")
  valid_565472 = validateParameter(valid_565472, JString, required = true,
                                 default = nil)
  if valid_565472 != nil:
    section.add "replicaId", valid_565472
  var valid_565473 = path.getOrDefault("partitionId")
  valid_565473 = validateParameter(valid_565473, JString, required = true,
                                 default = nil)
  if valid_565473 != nil:
    section.add "partitionId", valid_565473
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565474 = query.getOrDefault("api-version")
  valid_565474 = validateParameter(valid_565474, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565474 != nil:
    section.add "api-version", valid_565474
  var valid_565475 = query.getOrDefault("timeout")
  valid_565475 = validateParameter(valid_565475, JInt, required = false,
                                 default = newJInt(60))
  if valid_565475 != nil:
    section.add "timeout", valid_565475
  var valid_565476 = query.getOrDefault("EventsHealthStateFilter")
  valid_565476 = validateParameter(valid_565476, JInt, required = false,
                                 default = newJInt(0))
  if valid_565476 != nil:
    section.add "EventsHealthStateFilter", valid_565476
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565478: Call_GetReplicaHealthUsingPolicy_565469; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ## 
  let valid = call_565478.validator(path, query, header, formData, body)
  let scheme = call_565478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565478.url(scheme.get, call_565478.host, call_565478.base,
                         call_565478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565478, url, valid)

proc call*(call_565479: Call_GetReplicaHealthUsingPolicy_565469; replicaId: string;
          partitionId: string; ApplicationHealthPolicy: JsonNode = nil;
          apiVersion: string = "6.0"; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealthUsingPolicy
  ## Gets the health of a Service Fabric stateful service replica or stateless service instance.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health state.
  ## Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating the health of the replica.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565480 = newJObject()
  var query_565481 = newJObject()
  var body_565482 = newJObject()
  add(path_565480, "replicaId", newJString(replicaId))
  if ApplicationHealthPolicy != nil:
    body_565482 = ApplicationHealthPolicy
  add(query_565481, "api-version", newJString(apiVersion))
  add(query_565481, "timeout", newJInt(timeout))
  add(path_565480, "partitionId", newJString(partitionId))
  add(query_565481, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_565479.call(path_565480, query_565481, nil, nil, body_565482)

var getReplicaHealthUsingPolicy* = Call_GetReplicaHealthUsingPolicy_565469(
    name: "getReplicaHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealthUsingPolicy_565470, base: "",
    url: url_GetReplicaHealthUsingPolicy_565471,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetReplicaHealth_565457 = ref object of OpenApiRestCall_563565
proc url_GetReplicaHealth_565459(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetReplicaHealth_565458(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565460 = path.getOrDefault("replicaId")
  valid_565460 = validateParameter(valid_565460, JString, required = true,
                                 default = nil)
  if valid_565460 != nil:
    section.add "replicaId", valid_565460
  var valid_565461 = path.getOrDefault("partitionId")
  valid_565461 = validateParameter(valid_565461, JString, required = true,
                                 default = nil)
  if valid_565461 != nil:
    section.add "partitionId", valid_565461
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565462 = query.getOrDefault("api-version")
  valid_565462 = validateParameter(valid_565462, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565462 != nil:
    section.add "api-version", valid_565462
  var valid_565463 = query.getOrDefault("timeout")
  valid_565463 = validateParameter(valid_565463, JInt, required = false,
                                 default = newJInt(60))
  if valid_565463 != nil:
    section.add "timeout", valid_565463
  var valid_565464 = query.getOrDefault("EventsHealthStateFilter")
  valid_565464 = validateParameter(valid_565464, JInt, required = false,
                                 default = newJInt(0))
  if valid_565464 != nil:
    section.add "EventsHealthStateFilter", valid_565464
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565465: Call_GetReplicaHealth_565457; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ## 
  let valid = call_565465.validator(path, query, header, formData, body)
  let scheme = call_565465.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565465.url(scheme.get, call_565465.host, call_565465.base,
                         call_565465.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565465, url, valid)

proc call*(call_565466: Call_GetReplicaHealth_565457; replicaId: string;
          partitionId: string; apiVersion: string = "6.0"; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getReplicaHealth
  ## Gets the health of a Service Fabric replica.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health state.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  var path_565467 = newJObject()
  var query_565468 = newJObject()
  add(path_565467, "replicaId", newJString(replicaId))
  add(query_565468, "api-version", newJString(apiVersion))
  add(query_565468, "timeout", newJInt(timeout))
  add(path_565467, "partitionId", newJString(partitionId))
  add(query_565468, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  result = call_565466.call(path_565467, query_565468, nil, nil, nil)

var getReplicaHealth* = Call_GetReplicaHealth_565457(name: "getReplicaHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth",
    validator: validate_GetReplicaHealth_565458, base: "",
    url: url_GetReplicaHealth_565459, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportReplicaHealth_565483 = ref object of OpenApiRestCall_563565
proc url_ReportReplicaHealth_565485(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  assert "replicaId" in path, "`replicaId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetReplicas/"),
               (kind: VariableSegment, value: "replicaId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportReplicaHealth_565484(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   replicaId: JString (required)
  ##            : The identifier of the replica.
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `replicaId` field"
  var valid_565486 = path.getOrDefault("replicaId")
  valid_565486 = validateParameter(valid_565486, JString, required = true,
                                 default = nil)
  if valid_565486 != nil:
    section.add "replicaId", valid_565486
  var valid_565487 = path.getOrDefault("partitionId")
  valid_565487 = validateParameter(valid_565487, JString, required = true,
                                 default = nil)
  if valid_565487 != nil:
    section.add "partitionId", valid_565487
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceKind: JString (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565488 = query.getOrDefault("Immediate")
  valid_565488 = validateParameter(valid_565488, JBool, required = false,
                                 default = newJBool(false))
  if valid_565488 != nil:
    section.add "Immediate", valid_565488
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565489 = query.getOrDefault("api-version")
  valid_565489 = validateParameter(valid_565489, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565489 != nil:
    section.add "api-version", valid_565489
  var valid_565490 = query.getOrDefault("ServiceKind")
  valid_565490 = validateParameter(valid_565490, JString, required = true,
                                 default = newJString("Stateful"))
  if valid_565490 != nil:
    section.add "ServiceKind", valid_565490
  var valid_565491 = query.getOrDefault("timeout")
  valid_565491 = validateParameter(valid_565491, JInt, required = false,
                                 default = newJInt(60))
  if valid_565491 != nil:
    section.add "timeout", valid_565491
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565493: Call_ReportReplicaHealth_565483; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565493.validator(path, query, header, formData, body)
  let scheme = call_565493.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565493.url(scheme.get, call_565493.host, call_565493.base,
                         call_565493.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565493, url, valid)

proc call*(call_565494: Call_ReportReplicaHealth_565483; replicaId: string;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          apiVersion: string = "6.0"; ServiceKind: string = "Stateful";
          timeout: int = 60): Recallable =
  ## reportReplicaHealth
  ## Reports health state of the specified Service Fabric replica. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   replicaId: string (required)
  ##            : The identifier of the replica.
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceKind: string (required)
  ##              : The kind of service replica (Stateless or Stateful) for which the health is being reported. Following are the possible values.
  ## - Stateless - Does not use Service Fabric to make its state highly available or reliable. The value is 1
  ## - Stateful - Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565495 = newJObject()
  var query_565496 = newJObject()
  var body_565497 = newJObject()
  add(path_565495, "replicaId", newJString(replicaId))
  add(query_565496, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_565497 = HealthInformation
  add(query_565496, "api-version", newJString(apiVersion))
  add(query_565496, "ServiceKind", newJString(ServiceKind))
  add(query_565496, "timeout", newJInt(timeout))
  add(path_565495, "partitionId", newJString(partitionId))
  result = call_565494.call(path_565495, query_565496, nil, nil, body_565497)

var reportReplicaHealth* = Call_ReportReplicaHealth_565483(
    name: "reportReplicaHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth",
    validator: validate_ReportReplicaHealth_565484, base: "",
    url: url_ReportReplicaHealth_565485, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceNameInfo_565498 = ref object of OpenApiRestCall_563565
proc url_GetServiceNameInfo_565500(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/GetServiceName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceNameInfo_565499(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565501 = path.getOrDefault("partitionId")
  valid_565501 = validateParameter(valid_565501, JString, required = true,
                                 default = nil)
  if valid_565501 != nil:
    section.add "partitionId", valid_565501
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565502 = query.getOrDefault("api-version")
  valid_565502 = validateParameter(valid_565502, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565502 != nil:
    section.add "api-version", valid_565502
  var valid_565503 = query.getOrDefault("timeout")
  valid_565503 = validateParameter(valid_565503, JInt, required = false,
                                 default = newJInt(60))
  if valid_565503 != nil:
    section.add "timeout", valid_565503
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565504: Call_GetServiceNameInfo_565498; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ## 
  let valid = call_565504.validator(path, query, header, formData, body)
  let scheme = call_565504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565504.url(scheme.get, call_565504.host, call_565504.base,
                         call_565504.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565504, url, valid)

proc call*(call_565505: Call_GetServiceNameInfo_565498; partitionId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceNameInfo
  ## The GetServiceName endpoint returns the name of the service for the specified partition.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565506 = newJObject()
  var query_565507 = newJObject()
  add(query_565507, "api-version", newJString(apiVersion))
  add(query_565507, "timeout", newJInt(timeout))
  add(path_565506, "partitionId", newJString(partitionId))
  result = call_565505.call(path_565506, query_565507, nil, nil, nil)

var getServiceNameInfo* = Call_GetServiceNameInfo_565498(
    name: "getServiceNameInfo", meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/GetServiceName",
    validator: validate_GetServiceNameInfo_565499, base: "",
    url: url_GetServiceNameInfo_565500, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverPartition_565508 = ref object of OpenApiRestCall_563565
proc url_RecoverPartition_565510(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverPartition_565509(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565511 = path.getOrDefault("partitionId")
  valid_565511 = validateParameter(valid_565511, JString, required = true,
                                 default = nil)
  if valid_565511 != nil:
    section.add "partitionId", valid_565511
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565512 = query.getOrDefault("api-version")
  valid_565512 = validateParameter(valid_565512, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565512 != nil:
    section.add "api-version", valid_565512
  var valid_565513 = query.getOrDefault("timeout")
  valid_565513 = validateParameter(valid_565513, JInt, required = false,
                                 default = newJInt(60))
  if valid_565513 != nil:
    section.add "timeout", valid_565513
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565514: Call_RecoverPartition_565508; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_565514.validator(path, query, header, formData, body)
  let scheme = call_565514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565514.url(scheme.get, call_565514.host, call_565514.base,
                         call_565514.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565514, url, valid)

proc call*(call_565515: Call_RecoverPartition_565508; partitionId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## recoverPartition
  ## Indicates to the Service Fabric cluster that it should attempt to recover a specific partition which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565516 = newJObject()
  var query_565517 = newJObject()
  add(query_565517, "api-version", newJString(apiVersion))
  add(query_565517, "timeout", newJInt(timeout))
  add(path_565516, "partitionId", newJString(partitionId))
  result = call_565515.call(path_565516, query_565517, nil, nil, nil)

var recoverPartition* = Call_RecoverPartition_565508(name: "recoverPartition",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Partitions/{partitionId}/$/Recover",
    validator: validate_RecoverPartition_565509, base: "",
    url: url_RecoverPartition_565510, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportPartitionHealth_565518 = ref object of OpenApiRestCall_563565
proc url_ReportPartitionHealth_565520(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportPartitionHealth_565519(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565521 = path.getOrDefault("partitionId")
  valid_565521 = validateParameter(valid_565521, JString, required = true,
                                 default = nil)
  if valid_565521 != nil:
    section.add "partitionId", valid_565521
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565522 = query.getOrDefault("Immediate")
  valid_565522 = validateParameter(valid_565522, JBool, required = false,
                                 default = newJBool(false))
  if valid_565522 != nil:
    section.add "Immediate", valid_565522
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565523 = query.getOrDefault("api-version")
  valid_565523 = validateParameter(valid_565523, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565523 != nil:
    section.add "api-version", valid_565523
  var valid_565524 = query.getOrDefault("timeout")
  valid_565524 = validateParameter(valid_565524, JInt, required = false,
                                 default = newJInt(60))
  if valid_565524 != nil:
    section.add "timeout", valid_565524
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565526: Call_ReportPartitionHealth_565518; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565526.validator(path, query, header, formData, body)
  let scheme = call_565526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565526.url(scheme.get, call_565526.host, call_565526.base,
                         call_565526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565526, url, valid)

proc call*(call_565527: Call_ReportPartitionHealth_565518;
          HealthInformation: JsonNode; partitionId: string; Immediate: bool = false;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## reportPartitionHealth
  ## Reports health state of the specified Service Fabric partition. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565528 = newJObject()
  var query_565529 = newJObject()
  var body_565530 = newJObject()
  add(query_565529, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_565530 = HealthInformation
  add(query_565529, "api-version", newJString(apiVersion))
  add(query_565529, "timeout", newJInt(timeout))
  add(path_565528, "partitionId", newJString(partitionId))
  result = call_565527.call(path_565528, query_565529, nil, nil, body_565530)

var reportPartitionHealth* = Call_ReportPartitionHealth_565518(
    name: "reportPartitionHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ReportHealth",
    validator: validate_ReportPartitionHealth_565519, base: "",
    url: url_ReportPartitionHealth_565520, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResetPartitionLoad_565531 = ref object of OpenApiRestCall_563565
proc url_ResetPartitionLoad_565533(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "partitionId" in path, "`partitionId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Partitions/"),
               (kind: VariableSegment, value: "partitionId"),
               (kind: ConstantSegment, value: "/$/ResetLoad")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResetPartitionLoad_565532(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   partitionId: JString (required)
  ##              : The identity of the partition.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `partitionId` field"
  var valid_565534 = path.getOrDefault("partitionId")
  valid_565534 = validateParameter(valid_565534, JString, required = true,
                                 default = nil)
  if valid_565534 != nil:
    section.add "partitionId", valid_565534
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565535 = query.getOrDefault("api-version")
  valid_565535 = validateParameter(valid_565535, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565535 != nil:
    section.add "api-version", valid_565535
  var valid_565536 = query.getOrDefault("timeout")
  valid_565536 = validateParameter(valid_565536, JInt, required = false,
                                 default = newJInt(60))
  if valid_565536 != nil:
    section.add "timeout", valid_565536
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565537: Call_ResetPartitionLoad_565531; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ## 
  let valid = call_565537.validator(path, query, header, formData, body)
  let scheme = call_565537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565537.url(scheme.get, call_565537.host, call_565537.base,
                         call_565537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565537, url, valid)

proc call*(call_565538: Call_ResetPartitionLoad_565531; partitionId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## resetPartitionLoad
  ## Resets the current load of a Service Fabric partition to the default load for the service.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   partitionId: string (required)
  ##              : The identity of the partition.
  var path_565539 = newJObject()
  var query_565540 = newJObject()
  add(query_565540, "api-version", newJString(apiVersion))
  add(query_565540, "timeout", newJInt(timeout))
  add(path_565539, "partitionId", newJString(partitionId))
  result = call_565538.call(path_565539, query_565540, nil, nil, nil)

var resetPartitionLoad* = Call_ResetPartitionLoad_565531(
    name: "resetPartitionLoad", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Partitions/{partitionId}/$/ResetLoad",
    validator: validate_ResetPartitionLoad_565532, base: "",
    url: url_ResetPartitionLoad_565533, schemes: {Scheme.Https, Scheme.Http})
type
  Call_RecoverServicePartitions_565541 = ref object of OpenApiRestCall_563565
proc url_RecoverServicePartitions_565543(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/$/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions/$/Recover")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_RecoverServicePartitions_565542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565544 = path.getOrDefault("serviceId")
  valid_565544 = validateParameter(valid_565544, JString, required = true,
                                 default = nil)
  if valid_565544 != nil:
    section.add "serviceId", valid_565544
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565545 = query.getOrDefault("api-version")
  valid_565545 = validateParameter(valid_565545, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565545 != nil:
    section.add "api-version", valid_565545
  var valid_565546 = query.getOrDefault("timeout")
  valid_565546 = validateParameter(valid_565546, JInt, required = false,
                                 default = newJInt(60))
  if valid_565546 != nil:
    section.add "timeout", valid_565546
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565547: Call_RecoverServicePartitions_565541; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ## 
  let valid = call_565547.validator(path, query, header, formData, body)
  let scheme = call_565547.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565547.url(scheme.get, call_565547.host, call_565547.base,
                         call_565547.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565547, url, valid)

proc call*(call_565548: Call_RecoverServicePartitions_565541; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## recoverServicePartitions
  ## Indicates to the Service Fabric cluster that it should attempt to recover the specified service which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565549 = newJObject()
  var query_565550 = newJObject()
  add(query_565550, "api-version", newJString(apiVersion))
  add(query_565550, "timeout", newJInt(timeout))
  add(path_565549, "serviceId", newJString(serviceId))
  result = call_565548.call(path_565549, query_565550, nil, nil, nil)

var recoverServicePartitions* = Call_RecoverServicePartitions_565541(
    name: "recoverServicePartitions", meth: HttpMethod.HttpPost,
    host: "azure.local:19080",
    route: "/Services/$/{serviceId}/$/GetPartitions/$/Recover",
    validator: validate_RecoverServicePartitions_565542, base: "",
    url: url_RecoverServicePartitions_565543, schemes: {Scheme.Https, Scheme.Http})
type
  Call_DeleteService_565551 = ref object of OpenApiRestCall_563565
proc url_DeleteService_565553(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Delete")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_DeleteService_565552(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565554 = path.getOrDefault("serviceId")
  valid_565554 = validateParameter(valid_565554, JString, required = true,
                                 default = nil)
  if valid_565554 != nil:
    section.add "serviceId", valid_565554
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ForceRemove: JBool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565555 = query.getOrDefault("api-version")
  valid_565555 = validateParameter(valid_565555, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565555 != nil:
    section.add "api-version", valid_565555
  var valid_565556 = query.getOrDefault("timeout")
  valid_565556 = validateParameter(valid_565556, JInt, required = false,
                                 default = newJInt(60))
  if valid_565556 != nil:
    section.add "timeout", valid_565556
  var valid_565557 = query.getOrDefault("ForceRemove")
  valid_565557 = validateParameter(valid_565557, JBool, required = false, default = nil)
  if valid_565557 != nil:
    section.add "ForceRemove", valid_565557
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565558: Call_DeleteService_565551; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ## 
  let valid = call_565558.validator(path, query, header, formData, body)
  let scheme = call_565558.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565558.url(scheme.get, call_565558.host, call_565558.base,
                         call_565558.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565558, url, valid)

proc call*(call_565559: Call_DeleteService_565551; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60; ForceRemove: bool = false): Recallable =
  ## deleteService
  ## Deletes an existing Service Fabric service. A service must be created before it can be deleted. By default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ForceRemove: bool
  ##              : Remove a Service Fabric application or service forcefully without going through the graceful shutdown sequence. This parameter can be used to forcefully delete an application or service for which delete is timing out due to issues in the service code that prevents graceful close of replicas.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565560 = newJObject()
  var query_565561 = newJObject()
  add(query_565561, "api-version", newJString(apiVersion))
  add(query_565561, "timeout", newJInt(timeout))
  add(query_565561, "ForceRemove", newJBool(ForceRemove))
  add(path_565560, "serviceId", newJString(serviceId))
  result = call_565559.call(path_565560, query_565561, nil, nil, nil)

var deleteService* = Call_DeleteService_565551(name: "deleteService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Delete", validator: validate_DeleteService_565552,
    base: "", url: url_DeleteService_565553, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetApplicationNameInfo_565562 = ref object of OpenApiRestCall_563565
proc url_GetApplicationNameInfo_565564(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetApplicationName")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetApplicationNameInfo_565563(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565565 = path.getOrDefault("serviceId")
  valid_565565 = validateParameter(valid_565565, JString, required = true,
                                 default = nil)
  if valid_565565 != nil:
    section.add "serviceId", valid_565565
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565566 = query.getOrDefault("api-version")
  valid_565566 = validateParameter(valid_565566, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565566 != nil:
    section.add "api-version", valid_565566
  var valid_565567 = query.getOrDefault("timeout")
  valid_565567 = validateParameter(valid_565567, JInt, required = false,
                                 default = newJInt(60))
  if valid_565567 != nil:
    section.add "timeout", valid_565567
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565568: Call_GetApplicationNameInfo_565562; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ## 
  let valid = call_565568.validator(path, query, header, formData, body)
  let scheme = call_565568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565568.url(scheme.get, call_565568.host, call_565568.base,
                         call_565568.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565568, url, valid)

proc call*(call_565569: Call_GetApplicationNameInfo_565562; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getApplicationNameInfo
  ## The GetApplicationName endpoint returns the name of the application for the specified service.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565570 = newJObject()
  var query_565571 = newJObject()
  add(query_565571, "api-version", newJString(apiVersion))
  add(query_565571, "timeout", newJInt(timeout))
  add(path_565570, "serviceId", newJString(serviceId))
  result = call_565569.call(path_565570, query_565571, nil, nil, nil)

var getApplicationNameInfo* = Call_GetApplicationNameInfo_565562(
    name: "getApplicationNameInfo", meth: HttpMethod.HttpGet,
    host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetApplicationName",
    validator: validate_GetApplicationNameInfo_565563, base: "",
    url: url_GetApplicationNameInfo_565564, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceDescription_565572 = ref object of OpenApiRestCall_563565
proc url_GetServiceDescription_565574(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetDescription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceDescription_565573(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565575 = path.getOrDefault("serviceId")
  valid_565575 = validateParameter(valid_565575, JString, required = true,
                                 default = nil)
  if valid_565575 != nil:
    section.add "serviceId", valid_565575
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565576 = query.getOrDefault("api-version")
  valid_565576 = validateParameter(valid_565576, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565576 != nil:
    section.add "api-version", valid_565576
  var valid_565577 = query.getOrDefault("timeout")
  valid_565577 = validateParameter(valid_565577, JInt, required = false,
                                 default = newJInt(60))
  if valid_565577 != nil:
    section.add "timeout", valid_565577
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565578: Call_GetServiceDescription_565572; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ## 
  let valid = call_565578.validator(path, query, header, formData, body)
  let scheme = call_565578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565578.url(scheme.get, call_565578.host, call_565578.base,
                         call_565578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565578, url, valid)

proc call*(call_565579: Call_GetServiceDescription_565572; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getServiceDescription
  ## Gets the description of an existing Service Fabric service. A service must be created before its description can be obtained.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565580 = newJObject()
  var query_565581 = newJObject()
  add(query_565581, "api-version", newJString(apiVersion))
  add(query_565581, "timeout", newJInt(timeout))
  add(path_565580, "serviceId", newJString(serviceId))
  result = call_565579.call(path_565580, query_565581, nil, nil, nil)

var getServiceDescription* = Call_GetServiceDescription_565572(
    name: "getServiceDescription", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetDescription",
    validator: validate_GetServiceDescription_565573, base: "",
    url: url_GetServiceDescription_565574, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealthUsingPolicy_565595 = ref object of OpenApiRestCall_563565
proc url_GetServiceHealthUsingPolicy_565597(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealthUsingPolicy_565596(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565598 = path.getOrDefault("serviceId")
  valid_565598 = validateParameter(valid_565598, JString, required = true,
                                 default = nil)
  if valid_565598 != nil:
    section.add "serviceId", valid_565598
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565599 = query.getOrDefault("api-version")
  valid_565599 = validateParameter(valid_565599, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565599 != nil:
    section.add "api-version", valid_565599
  var valid_565600 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_565600 = validateParameter(valid_565600, JInt, required = false,
                                 default = newJInt(0))
  if valid_565600 != nil:
    section.add "PartitionsHealthStateFilter", valid_565600
  var valid_565601 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565601 = validateParameter(valid_565601, JBool, required = false,
                                 default = newJBool(false))
  if valid_565601 != nil:
    section.add "ExcludeHealthStatistics", valid_565601
  var valid_565602 = query.getOrDefault("timeout")
  valid_565602 = validateParameter(valid_565602, JInt, required = false,
                                 default = newJInt(60))
  if valid_565602 != nil:
    section.add "timeout", valid_565602
  var valid_565603 = query.getOrDefault("EventsHealthStateFilter")
  valid_565603 = validateParameter(valid_565603, JInt, required = false,
                                 default = newJInt(0))
  if valid_565603 != nil:
    section.add "EventsHealthStateFilter", valid_565603
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  section = validateParameter(body, JObject, required = false, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565605: Call_GetServiceHealthUsingPolicy_565595; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_565605.validator(path, query, header, formData, body)
  let scheme = call_565605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565605.url(scheme.get, call_565605.host, call_565605.base,
                         call_565605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565605, url, valid)

proc call*(call_565606: Call_GetServiceHealthUsingPolicy_565595; serviceId: string;
          ApplicationHealthPolicy: JsonNode = nil; apiVersion: string = "6.0";
          PartitionsHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealthUsingPolicy
  ## Gets the health information of the specified service.
  ## If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
  ## If the policy is not specified, the health evaluation uses the application health policy defined in the application manifest, or the default health policy, if no policy is defined in the manifest.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   ApplicationHealthPolicy: JObject
  ##                          : Describes the health policies used to evaluate the health of an application or one of its children.
  ## If not present, the health evaluation uses the health policy from application manifest or the default health policy.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565607 = newJObject()
  var query_565608 = newJObject()
  var body_565609 = newJObject()
  if ApplicationHealthPolicy != nil:
    body_565609 = ApplicationHealthPolicy
  add(query_565608, "api-version", newJString(apiVersion))
  add(query_565608, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  add(query_565608, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565608, "timeout", newJInt(timeout))
  add(query_565608, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565607, "serviceId", newJString(serviceId))
  result = call_565606.call(path_565607, query_565608, nil, nil, body_565609)

var getServiceHealthUsingPolicy* = Call_GetServiceHealthUsingPolicy_565595(
    name: "getServiceHealthUsingPolicy", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealthUsingPolicy_565596, base: "",
    url: url_GetServiceHealthUsingPolicy_565597,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetServiceHealth_565582 = ref object of OpenApiRestCall_563565
proc url_GetServiceHealth_565584(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetServiceHealth_565583(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565585 = path.getOrDefault("serviceId")
  valid_565585 = validateParameter(valid_565585, JString, required = true,
                                 default = nil)
  if valid_565585 != nil:
    section.add "serviceId", valid_565585
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionsHealthStateFilter: JInt
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: JBool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: JInt
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565586 = query.getOrDefault("api-version")
  valid_565586 = validateParameter(valid_565586, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565586 != nil:
    section.add "api-version", valid_565586
  var valid_565587 = query.getOrDefault("PartitionsHealthStateFilter")
  valid_565587 = validateParameter(valid_565587, JInt, required = false,
                                 default = newJInt(0))
  if valid_565587 != nil:
    section.add "PartitionsHealthStateFilter", valid_565587
  var valid_565588 = query.getOrDefault("ExcludeHealthStatistics")
  valid_565588 = validateParameter(valid_565588, JBool, required = false,
                                 default = newJBool(false))
  if valid_565588 != nil:
    section.add "ExcludeHealthStatistics", valid_565588
  var valid_565589 = query.getOrDefault("timeout")
  valid_565589 = validateParameter(valid_565589, JInt, required = false,
                                 default = newJInt(60))
  if valid_565589 != nil:
    section.add "timeout", valid_565589
  var valid_565590 = query.getOrDefault("EventsHealthStateFilter")
  valid_565590 = validateParameter(valid_565590, JInt, required = false,
                                 default = newJInt(0))
  if valid_565590 != nil:
    section.add "EventsHealthStateFilter", valid_565590
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565591: Call_GetServiceHealth_565582; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ## 
  let valid = call_565591.validator(path, query, header, formData, body)
  let scheme = call_565591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565591.url(scheme.get, call_565591.host, call_565591.base,
                         call_565591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565591, url, valid)

proc call*(call_565592: Call_GetServiceHealth_565582; serviceId: string;
          apiVersion: string = "6.0"; PartitionsHealthStateFilter: int = 0;
          ExcludeHealthStatistics: bool = false; timeout: int = 60;
          EventsHealthStateFilter: int = 0): Recallable =
  ## getServiceHealth
  ## Gets the health information of the specified service.
  ## Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health state.
  ## Use PartitionsHealthStateFilter to filter the collection of partitions returned.
  ## If you specify a service that does not exist in the health store, this cmdlet returns an error.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionsHealthStateFilter: int
  ##                              : Allows filtering of the partitions health state objects returned in the result of service health query based on their health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value
  ## obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   ExcludeHealthStatistics: bool
  ##                          : Indicates whether the health statistics should be returned as part of the query result. False by default.
  ## The statistics show the number of children entities in health state Ok, Warning, and Error.
  ## 
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EventsHealthStateFilter: int
  ##                          : Allows filtering the collection of HealthEvent objects returned based on health state.
  ## The possible values for this parameter include integer value of one of the following health states.
  ## Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
  ## If not specified, all entries are returned. The state values are flag based enumeration, so the value could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
  ## 
  ## - Default - Default value. Matches any HealthState. The value is zero.
  ## - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given collection of states. The value is 1.
  ## - Ok - Filter that matches input with HealthState value Ok. The value is 2.
  ## - Warning - Filter that matches input with HealthState value Warning. The value is 4.
  ## - Error - Filter that matches input with HealthState value Error. The value is 8.
  ## - All - Filter that matches input with any HealthState value. The value is 65535.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565593 = newJObject()
  var query_565594 = newJObject()
  add(query_565594, "api-version", newJString(apiVersion))
  add(query_565594, "PartitionsHealthStateFilter",
      newJInt(PartitionsHealthStateFilter))
  add(query_565594, "ExcludeHealthStatistics", newJBool(ExcludeHealthStatistics))
  add(query_565594, "timeout", newJInt(timeout))
  add(query_565594, "EventsHealthStateFilter", newJInt(EventsHealthStateFilter))
  add(path_565593, "serviceId", newJString(serviceId))
  result = call_565592.call(path_565593, query_565594, nil, nil, nil)

var getServiceHealth* = Call_GetServiceHealth_565582(name: "getServiceHealth",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/GetHealth",
    validator: validate_GetServiceHealth_565583, base: "",
    url: url_GetServiceHealth_565584, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPartitionInfoList_565610 = ref object of OpenApiRestCall_563565
proc url_GetPartitionInfoList_565612(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/GetPartitions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_GetPartitionInfoList_565611(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565613 = path.getOrDefault("serviceId")
  valid_565613 = validateParameter(valid_565613, JString, required = true,
                                 default = nil)
  if valid_565613 != nil:
    section.add "serviceId", valid_565613
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565614 = query.getOrDefault("ContinuationToken")
  valid_565614 = validateParameter(valid_565614, JString, required = false,
                                 default = nil)
  if valid_565614 != nil:
    section.add "ContinuationToken", valid_565614
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565615 = query.getOrDefault("api-version")
  valid_565615 = validateParameter(valid_565615, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565615 != nil:
    section.add "api-version", valid_565615
  var valid_565616 = query.getOrDefault("timeout")
  valid_565616 = validateParameter(valid_565616, JInt, required = false,
                                 default = newJInt(60))
  if valid_565616 != nil:
    section.add "timeout", valid_565616
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565617: Call_GetPartitionInfoList_565610; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ## 
  let valid = call_565617.validator(path, query, header, formData, body)
  let scheme = call_565617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565617.url(scheme.get, call_565617.host, call_565617.base,
                         call_565617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565617, url, valid)

proc call*(call_565618: Call_GetPartitionInfoList_565610; serviceId: string;
          ContinuationToken: string = ""; apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## getPartitionInfoList
  ## Gets the list of partitions of a Service Fabric service. The response include the partition id, partitioning scheme information, keys supported by the partition, status, health and other details about the partition.
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565619 = newJObject()
  var query_565620 = newJObject()
  add(query_565620, "ContinuationToken", newJString(ContinuationToken))
  add(query_565620, "api-version", newJString(apiVersion))
  add(query_565620, "timeout", newJInt(timeout))
  add(path_565619, "serviceId", newJString(serviceId))
  result = call_565618.call(path_565619, query_565620, nil, nil, nil)

var getPartitionInfoList* = Call_GetPartitionInfoList_565610(
    name: "getPartitionInfoList", meth: HttpMethod.HttpGet,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/GetPartitions",
    validator: validate_GetPartitionInfoList_565611, base: "",
    url: url_GetPartitionInfoList_565612, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ReportServiceHealth_565621 = ref object of OpenApiRestCall_563565
proc url_ReportServiceHealth_565623(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ReportHealth")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ReportServiceHealth_565622(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565624 = path.getOrDefault("serviceId")
  valid_565624 = validateParameter(valid_565624, JString, required = true,
                                 default = nil)
  if valid_565624 != nil:
    section.add "serviceId", valid_565624
  result.add "path", section
  ## parameters in `query` object:
  ##   Immediate: JBool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  var valid_565625 = query.getOrDefault("Immediate")
  valid_565625 = validateParameter(valid_565625, JBool, required = false,
                                 default = newJBool(false))
  if valid_565625 != nil:
    section.add "Immediate", valid_565625
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565626 = query.getOrDefault("api-version")
  valid_565626 = validateParameter(valid_565626, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565626 != nil:
    section.add "api-version", valid_565626
  var valid_565627 = query.getOrDefault("timeout")
  valid_565627 = validateParameter(valid_565627, JInt, required = false,
                                 default = newJInt(60))
  if valid_565627 != nil:
    section.add "timeout", valid_565627
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565629: Call_ReportServiceHealth_565621; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ## 
  let valid = call_565629.validator(path, query, header, formData, body)
  let scheme = call_565629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565629.url(scheme.get, call_565629.host, call_565629.base,
                         call_565629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565629, url, valid)

proc call*(call_565630: Call_ReportServiceHealth_565621;
          HealthInformation: JsonNode; serviceId: string; Immediate: bool = false;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## reportServiceHealth
  ## Reports health state of the specified Service Fabric service. The report must contain the information about the source of the health report and property on which it is reported.
  ## The report is sent to a Service Fabric gateway Service, which forwards to the health store.
  ## The report may be accepted by the gateway, but rejected by the health store after extra validation.
  ## For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
  ## To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in the HealthEvents section.
  ## 
  ##   Immediate: bool
  ##            : A flag which indicates whether the report should be sent immediately.
  ## A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
  ## If Immediate is set to true, the report is sent immediately from Http Gateway to the health store, regardless of the fabric client settings that the Http Gateway Application is using.
  ## This is useful for critical reports that should be sent as soon as possible.
  ## Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway is closed or the message doesn't reach the Gateway.
  ## If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway. Therefore, it will be batched according to the HealthReportSendInterval configuration.
  ## This is the recommended setting because it allows the health client to optimize health reporting messages to health store as well as health report processing.
  ## By default, reports are not sent immediately.
  ## 
  ##   HealthInformation: JObject (required)
  ##                    : Describes the health information for the health report. This information needs to be present in all of the health reports sent to the health manager.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565631 = newJObject()
  var query_565632 = newJObject()
  var body_565633 = newJObject()
  add(query_565632, "Immediate", newJBool(Immediate))
  if HealthInformation != nil:
    body_565633 = HealthInformation
  add(query_565632, "api-version", newJString(apiVersion))
  add(query_565632, "timeout", newJInt(timeout))
  add(path_565631, "serviceId", newJString(serviceId))
  result = call_565630.call(path_565631, query_565632, nil, nil, body_565633)

var reportServiceHealth* = Call_ReportServiceHealth_565621(
    name: "reportServiceHealth", meth: HttpMethod.HttpPost,
    host: "azure.local:19080", route: "/Services/{serviceId}/$/ReportHealth",
    validator: validate_ReportServiceHealth_565622, base: "",
    url: url_ReportServiceHealth_565623, schemes: {Scheme.Https, Scheme.Http})
type
  Call_ResolveService_565634 = ref object of OpenApiRestCall_563565
proc url_ResolveService_565636(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/ResolvePartition")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_ResolveService_565635(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565637 = path.getOrDefault("serviceId")
  valid_565637 = validateParameter(valid_565637, JString, required = true,
                                 default = nil)
  if valid_565637 != nil:
    section.add "serviceId", valid_565637
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyValue: JString
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyType: JInt
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   PreviousRspVersion: JString
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565638 = query.getOrDefault("api-version")
  valid_565638 = validateParameter(valid_565638, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565638 != nil:
    section.add "api-version", valid_565638
  var valid_565639 = query.getOrDefault("PartitionKeyValue")
  valid_565639 = validateParameter(valid_565639, JString, required = false,
                                 default = nil)
  if valid_565639 != nil:
    section.add "PartitionKeyValue", valid_565639
  var valid_565640 = query.getOrDefault("timeout")
  valid_565640 = validateParameter(valid_565640, JInt, required = false,
                                 default = newJInt(60))
  if valid_565640 != nil:
    section.add "timeout", valid_565640
  var valid_565641 = query.getOrDefault("PartitionKeyType")
  valid_565641 = validateParameter(valid_565641, JInt, required = false, default = nil)
  if valid_565641 != nil:
    section.add "PartitionKeyType", valid_565641
  var valid_565642 = query.getOrDefault("PreviousRspVersion")
  valid_565642 = validateParameter(valid_565642, JString, required = false,
                                 default = nil)
  if valid_565642 != nil:
    section.add "PreviousRspVersion", valid_565642
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565643: Call_ResolveService_565634; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ## 
  let valid = call_565643.validator(path, query, header, formData, body)
  let scheme = call_565643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565643.url(scheme.get, call_565643.host, call_565643.base,
                         call_565643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565643, url, valid)

proc call*(call_565644: Call_ResolveService_565634; serviceId: string;
          apiVersion: string = "6.0"; PartitionKeyValue: string = ""; timeout: int = 60;
          PartitionKeyType: int = 0; PreviousRspVersion: string = ""): Recallable =
  ## resolveService
  ## Resolve a Service Fabric service partition, to get the endpoints of the service replicas.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   PartitionKeyValue: string
  ##                    : Partition key. This is required if the partition scheme for the service is Int64Range or Named.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   PartitionKeyType: int
  ##                   : Key type for the partition. This parameter is required if the partition scheme for the service is Int64Range or Named. The possible values are following.
  ## - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
  ## - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
  ## - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid for the partitions with partitioning scheme as Named. The value is 3.
  ## 
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  ##   PreviousRspVersion: string
  ##                     : The value in the Version field of the response that was received previously. This is required if the user knows that the result that was got previously is stale.
  var path_565645 = newJObject()
  var query_565646 = newJObject()
  add(query_565646, "api-version", newJString(apiVersion))
  add(query_565646, "PartitionKeyValue", newJString(PartitionKeyValue))
  add(query_565646, "timeout", newJInt(timeout))
  add(query_565646, "PartitionKeyType", newJInt(PartitionKeyType))
  add(path_565645, "serviceId", newJString(serviceId))
  add(query_565646, "PreviousRspVersion", newJString(PreviousRspVersion))
  result = call_565644.call(path_565645, query_565646, nil, nil, nil)

var resolveService* = Call_ResolveService_565634(name: "resolveService",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/ResolvePartition",
    validator: validate_ResolveService_565635, base: "", url: url_ResolveService_565636,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_UpdateService_565647 = ref object of OpenApiRestCall_563565
proc url_UpdateService_565649(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "serviceId" in path, "`serviceId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/Services/"),
               (kind: VariableSegment, value: "serviceId"),
               (kind: ConstantSegment, value: "/$/Update")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  result.path = base & hydrated.get

proc validate_UpdateService_565648(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Updates the specified service using the given update description.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   serviceId: JString (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `serviceId` field"
  var valid_565650 = path.getOrDefault("serviceId")
  valid_565650 = validateParameter(valid_565650, JString, required = true,
                                 default = nil)
  if valid_565650 != nil:
    section.add "serviceId", valid_565650
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565651 = query.getOrDefault("api-version")
  valid_565651 = validateParameter(valid_565651, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565651 != nil:
    section.add "api-version", valid_565651
  var valid_565652 = query.getOrDefault("timeout")
  valid_565652 = validateParameter(valid_565652, JInt, required = false,
                                 default = newJInt(60))
  if valid_565652 != nil:
    section.add "timeout", valid_565652
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565654: Call_UpdateService_565647; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Updates the specified service using the given update description.
  ## 
  let valid = call_565654.validator(path, query, header, formData, body)
  let scheme = call_565654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565654.url(scheme.get, call_565654.host, call_565654.base,
                         call_565654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565654, url, valid)

proc call*(call_565655: Call_UpdateService_565647;
          ServiceUpdateDescription: JsonNode; serviceId: string;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## updateService
  ## Updates the specified service using the given update description.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   ServiceUpdateDescription: JObject (required)
  ##                           : The information necessary to update a service.
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   serviceId: string (required)
  ##            : The identity of the service. This is typically the full name of the service without the 'fabric:' URI scheme. Starting from version 6.0, hierarchical names are delimited with the "~" character. For example, if the service name is "fabric://myapp/app1/svc1", the service identity would be "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
  var path_565656 = newJObject()
  var query_565657 = newJObject()
  var body_565658 = newJObject()
  add(query_565657, "api-version", newJString(apiVersion))
  if ServiceUpdateDescription != nil:
    body_565658 = ServiceUpdateDescription
  add(query_565657, "timeout", newJInt(timeout))
  add(path_565656, "serviceId", newJString(serviceId))
  result = call_565655.call(path_565656, query_565657, nil, nil, body_565658)

var updateService* = Call_UpdateService_565647(name: "updateService",
    meth: HttpMethod.HttpPost, host: "azure.local:19080",
    route: "/Services/{serviceId}/$/Update", validator: validate_UpdateService_565648,
    base: "", url: url_UpdateService_565649, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetChaosReport_565659 = ref object of OpenApiRestCall_563565
proc url_GetChaosReport_565661(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetChaosReport_565660(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ContinuationToken: JString
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EndTimeUtc: JString
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   StartTimeUtc: JString
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  section = newJObject()
  var valid_565662 = query.getOrDefault("ContinuationToken")
  valid_565662 = validateParameter(valid_565662, JString, required = false,
                                 default = nil)
  if valid_565662 != nil:
    section.add "ContinuationToken", valid_565662
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565663 = query.getOrDefault("api-version")
  valid_565663 = validateParameter(valid_565663, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565663 != nil:
    section.add "api-version", valid_565663
  var valid_565664 = query.getOrDefault("timeout")
  valid_565664 = validateParameter(valid_565664, JInt, required = false,
                                 default = newJInt(60))
  if valid_565664 != nil:
    section.add "timeout", valid_565664
  var valid_565665 = query.getOrDefault("EndTimeUtc")
  valid_565665 = validateParameter(valid_565665, JString, required = false,
                                 default = nil)
  if valid_565665 != nil:
    section.add "EndTimeUtc", valid_565665
  var valid_565666 = query.getOrDefault("StartTimeUtc")
  valid_565666 = validateParameter(valid_565666, JString, required = false,
                                 default = nil)
  if valid_565666 != nil:
    section.add "StartTimeUtc", valid_565666
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565667: Call_GetChaosReport_565659; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ## 
  let valid = call_565667.validator(path, query, header, formData, body)
  let scheme = call_565667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565667.url(scheme.get, call_565667.host, call_565667.base,
                         call_565667.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565667, url, valid)

proc call*(call_565668: Call_GetChaosReport_565659; ContinuationToken: string = "";
          apiVersion: string = "6.0"; timeout: int = 60; EndTimeUtc: string = "";
          StartTimeUtc: string = ""): Recallable =
  ## getChaosReport
  ## You can either specify the ContinuationToken to get the next segment of the Chaos report or you can specify the time-range
  ## through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the same call.
  ## When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more than 100 Chaos events.
  ## 
  ##   ContinuationToken: string
  ##                    : The continuation token parameter is used to obtain next set of results. A continuation token with a non empty value is included in the response of the API when the results from the system do not fit in a single response. When this value is passed to the next API call, the API returns next set of results. If there are no further results then the continuation token does not contain a value. The value of this parameter should not be URL encoded.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   EndTimeUtc: string
  ##             : The count of ticks representing the end time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  ##   StartTimeUtc: string
  ##               : The count of ticks representing the start time of the time range for which a Chaos report is to be generated. Please consult [DateTime.Ticks 
  ## Property](https://msdn.microsoft.com/en-us/library/system.datetime.ticks%28v=vs.110%29) for details about tick.
  var query_565669 = newJObject()
  add(query_565669, "ContinuationToken", newJString(ContinuationToken))
  add(query_565669, "api-version", newJString(apiVersion))
  add(query_565669, "timeout", newJInt(timeout))
  add(query_565669, "EndTimeUtc", newJString(EndTimeUtc))
  add(query_565669, "StartTimeUtc", newJString(StartTimeUtc))
  result = call_565668.call(nil, query_565669, nil, nil, nil)

var getChaosReport* = Call_GetChaosReport_565659(name: "getChaosReport",
    meth: HttpMethod.HttpGet, host: "azure.local:19080",
    route: "/Tools/Chaos/$/Report", validator: validate_GetChaosReport_565660,
    base: "", url: url_GetChaosReport_565661, schemes: {Scheme.Https, Scheme.Http})
type
  Call_StartChaos_565670 = ref object of OpenApiRestCall_563565
proc url_StartChaos_565672(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StartChaos_565671(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565673 = query.getOrDefault("api-version")
  valid_565673 = validateParameter(valid_565673, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565673 != nil:
    section.add "api-version", valid_565673
  var valid_565674 = query.getOrDefault("timeout")
  valid_565674 = validateParameter(valid_565674, JInt, required = false,
                                 default = newJInt(60))
  if valid_565674 != nil:
    section.add "timeout", valid_565674
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_565676: Call_StartChaos_565670; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ## 
  let valid = call_565676.validator(path, query, header, formData, body)
  let scheme = call_565676.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565676.url(scheme.get, call_565676.host, call_565676.base,
                         call_565676.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565676, url, valid)

proc call*(call_565677: Call_StartChaos_565670; ChaosParameters: JsonNode;
          apiVersion: string = "6.0"; timeout: int = 60): Recallable =
  ## startChaos
  ## If Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
  ## If Chaos is already running when this call is made, the call fails with the error code FABRIC_E_CHAOS_ALREADY_RUNNING.
  ## Please refer to the article [Induce controlled Chaos in Service Fabric clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
  ## 
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  ##   ChaosParameters: JObject (required)
  ##                  : Describes all the parameters to configure a Chaos run.
  var query_565678 = newJObject()
  var body_565679 = newJObject()
  add(query_565678, "api-version", newJString(apiVersion))
  add(query_565678, "timeout", newJInt(timeout))
  if ChaosParameters != nil:
    body_565679 = ChaosParameters
  result = call_565677.call(nil, query_565678, nil, nil, body_565679)

var startChaos* = Call_StartChaos_565670(name: "startChaos",
                                      meth: HttpMethod.HttpPost,
                                      host: "azure.local:19080",
                                      route: "/Tools/Chaos/$/Start",
                                      validator: validate_StartChaos_565671,
                                      base: "", url: url_StartChaos_565672,
                                      schemes: {Scheme.Https, Scheme.Http})
type
  Call_StopChaos_565680 = ref object of OpenApiRestCall_563565
proc url_StopChaos_565682(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_StopChaos_565681(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   api-version: JString (required)
  ##              : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: JInt
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `api-version` field"
  var valid_565683 = query.getOrDefault("api-version")
  valid_565683 = validateParameter(valid_565683, JString, required = true,
                                 default = newJString("6.0"))
  if valid_565683 != nil:
    section.add "api-version", valid_565683
  var valid_565684 = query.getOrDefault("timeout")
  valid_565684 = validateParameter(valid_565684, JInt, required = false,
                                 default = newJInt(60))
  if valid_565684 != nil:
    section.add "timeout", valid_565684
  result.add "query", section
  section = newJObject()
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_565685: Call_StopChaos_565680; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ## 
  let valid = call_565685.validator(path, query, header, formData, body)
  let scheme = call_565685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_565685.url(scheme.get, call_565685.host, call_565685.base,
                         call_565685.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_565685, url, valid)

proc call*(call_565686: Call_StopChaos_565680; apiVersion: string = "6.0";
          timeout: int = 60): Recallable =
  ## stopChaos
  ## Stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
  ##   apiVersion: string (required)
  ##             : The version of the API. This is a required parameter and it's value must be "6.0".
  ##   timeout: int
  ##          : The server timeout for performing the operation in seconds. This specifies the time duration that the client is willing to wait for the requested operation to complete. The default value for this parameter is 60 seconds.
  var query_565687 = newJObject()
  add(query_565687, "api-version", newJString(apiVersion))
  add(query_565687, "timeout", newJInt(timeout))
  result = call_565686.call(nil, query_565687, nil, nil, nil)

var stopChaos* = Call_StopChaos_565680(name: "stopChaos", meth: HttpMethod.HttpPost,
                                    host: "azure.local:19080",
                                    route: "/Tools/Chaos/$/Stop",
                                    validator: validate_StopChaos_565681,
                                    base: "", url: url_StopChaos_565682,
                                    schemes: {Scheme.Https, Scheme.Http})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
